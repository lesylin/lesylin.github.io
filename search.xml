<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode-BFS&amp;DFS</title>
    <url>/2020/07/04/leetcode-BFS-DFS/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾BFS和DFS算法后，完成BFS和DFS算法在leetcode的经典题。</p>
<ul>
<li>BFS
<ul>
<li>1091-二进制矩阵中的最短路径</li>
<li>279-完全平方数</li>
<li>127-单词接龙</li>
</ul>
</li>
<li>DFS
<ul>
<li>695-岛屿的最大面积</li>
<li>200-岛屿数量</li>
<li>547-朋友圈</li>
<li>130-被围绕的区域</li>
<li>417-太平洋大西洋水流问题</li>
</ul>
</li>
</ul>
<h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1>
<h2 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h2>
<h3 id="单向bfs终点未知"><a class="markdownIt-Anchor" href="#单向bfs终点未知"></a> 单向BFS（终点未知）</h3>
<p> 广度优先搜索就是把一些问题抽象成一个图，然后一层一层进行遍历，每层遍历都是以上一层遍历的结果为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次遍历。</p>
<ul>
<li><strong>本质</strong>：<strong>就是让你在一幅「图」中找到从起点</strong> <strong><code>start</code></strong> <strong>到终点</strong> <strong><code>target</code></strong> <strong>的最近距离</strong>。（图是无权图，无权图是指从一个节点到另一个节点的代价都记为 1。）</li>
<li>我们写 BFS 算法都是用**「队列」**这种数据结构，<strong>每次将一个节点周围的所有节点加入队列</strong>。</li>
</ul>
<p> 在程序实现BFS时需要考虑以下问题：</p>
<ul>
<li><strong>队列：用来存储每一轮遍历得到的节点；</strong></li>
<li><strong>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</strong></li>
</ul>
<h3 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/bham/p/11746312.html" target="_blank" rel="noopener">https://www.cnblogs.com/bham/p/11746312.html</a></p>
</blockquote>
<h3 id="双向bfs终点已知"><a class="markdownIt-Anchor" href="#双向bfs终点已知"></a> 双向BFS（终点已知）</h3>
<p> 单向BFS是从起点不断遍历，直到遇到终点。双向BFS则是，从起点和终点不断遍历，直到遇到相交点。和单向BFS不同之处在于，使用的数据结构不再是队列，而是使用哈希表快速判断两个集合是否有想相交点。</p>
<h3 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dBFS</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    front = []</span><br><span class="line">    back = []</span><br><span class="line">    front.append(start)</span><br><span class="line">    back.append(end)</span><br><span class="line">    <span class="keyword">while</span> front <span class="keyword">and</span> back:</span><br><span class="line">        nodes = set()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> front:</span><br><span class="line">            visited.add(node) <span class="comment">#加入访问</span></span><br><span class="line">            process(node) <span class="comment"># 处理当前node</span></span><br><span class="line">            nodes.append(generate_related_nodes(node)) <span class="comment">#获取子节点</span></span><br><span class="line">        front = nodes</span><br><span class="line">        <span class="comment"># 从较小的set开始</span></span><br><span class="line">        <span class="keyword">if</span> len(back) &lt; len(front):</span><br><span class="line">            front, back = back, front</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么从较小的set开始？
<ul>
<li>因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</li>
</ul>
</li>
</ul>
<h1 id="1091-二进制矩阵中的最短路径"><a class="markdownIt-Anchor" href="#1091-二进制矩阵中的最短路径"></a> 1091-二进制矩阵中的最短路径</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：中等：</p>
</li>
<li>
<p>题目：在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。一条从左上角到右下角、长度为 <code>k</code> 的畅通路径，由满足下述条件的单元格 <code>C_1, C_2, ..., C_k</code> 组成：</p>
<ul>
<li>相邻单元格 <code>C_i</code> 和 <code>C_{i+1}</code> 在八个方向之一上连通（此时，<code>C_i</code> 和 <code>C_{i+1}</code> 不同且共享边或角）</li>
<li><code>C_1</code> 位于 <code>(0, 0)</code>（即，值为 <code>grid[0][0]</code>）</li>
<li><code>C_k</code> 位于 <code>(N-1, N-1)</code>（即，值为 <code>grid[N-1][N-1]</code>）</li>
<li>如果 <code>C_i</code> 位于 <code>(r, c)</code>，则 <code>grid[r][c]</code> 为空（即，<code>grid[r][c] == 0</code>）</li>
</ul>
<p>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[0,1],[1,0]]</span><br><span class="line"></span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[0,0,0],[1,1,0],[1,1,0]]</span><br><span class="line"></span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>从左上角到右下角的最短畅通路径长度，即从左上角到右下角状态为0的最短路径。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单向BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        res = <span class="number">1</span> </span><br><span class="line">        path = deque()</span><br><span class="line">        <span class="comment">#先压入起点</span></span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>]) </span><br><span class="line">        <span class="comment">#BFS模板</span></span><br><span class="line">        <span class="keyword">while</span> path: </span><br><span class="line">          	<span class="comment">#对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(path)): </span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment">#下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  </span><br><span class="line">                      	<span class="comment">#如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="comment">#扩展的点超出边界，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若扩展的点为阻塞，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若扩展的点已经访问过，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">-1</span>:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若为通畅点</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>: </span><br><span class="line">                      	<span class="comment">#当前层次下已经访问该点</span></span><br><span class="line">                        grid[new_x][new_y] = <span class="number">-1</span></span><br><span class="line">                        <span class="comment">#将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">                        path.append([new_x, new_y])  </span><br><span class="line">            res += <span class="number">1</span>  <span class="comment">#对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#双向BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        direcitons = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">1</span>)]</span><br><span class="line">        front,end = set([(<span class="number">0</span>,<span class="number">0</span>)]),set([(n<span class="number">-1</span>,n<span class="number">-1</span>)])</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> front <span class="keyword">and</span> end:</span><br><span class="line">            <span class="keyword">if</span> len(front) &gt; len(end):</span><br><span class="line">                <span class="comment"># 两端走, 哪边的值少走哪边, front也就是当前队列</span></span><br><span class="line">                front,end = end,front</span><br><span class="line">            next_queue = set() <span class="comment"># 下一个队列</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(front)):</span><br><span class="line">                i,j= front.pop()</span><br><span class="line">                <span class="keyword">for</span> dx,dy <span class="keyword">in</span> direcitons:</span><br><span class="line">                    x,y = i+dx, j+dy</span><br><span class="line">                    <span class="keyword">if</span> (x,y) <span class="keyword">in</span> end:</span><br><span class="line">                        <span class="comment">#结果坐标在尾队列，结束</span></span><br><span class="line">                        <span class="keyword">return</span> count +<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 已经走过则 赋值为 1, 好马不吃回头草</span></span><br><span class="line">                        grid[x][y] = <span class="number">1</span></span><br><span class="line">                        next_queue.add((x,y))</span><br><span class="line">            front = next_queue</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>单向BFS和双向BFS，从大O时间复杂度上看是一样的，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点。<strong>掌握BFS就可以了~</strong></li>
<li>时间复杂度：O(n)，因为每个元素遍历了一次，n为元素的个数</li>
<li>空间复杂度：O(k)，k为过程中队列的最大元素个数。</li>
</ul>
<h1 id="279-完全平方数"><a class="markdownIt-Anchor" href="#279-完全平方数"></a> 279-完全平方数</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p>分析：若干个完全平方数之和等于n，且个数最少。因此，我们查找的完全平方数的大小区间是[1，n)。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化完全平方数列表</span></span><br><span class="line">        square_nums = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始化返回结果</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化队列遍历保存每一次差值</span></span><br><span class="line">        queue = [n]</span><br><span class="line">        <span class="comment">#BFS遍历</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            next_queue = []   <span class="comment">#next_queue = set()</span></span><br><span class="line">            <span class="keyword">for</span> remainder <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">for</span> square_num <span class="keyword">in</span> square_nums:  </span><br><span class="line">                    <span class="keyword">if</span> remainder == square_num:</span><br><span class="line">                        <span class="keyword">return</span> count  </span><br><span class="line">                    <span class="keyword">elif</span> remainder &lt; square_num:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        next_queue.append(remainder - square_num)  <span class="comment">#next_queue.add(remainder - square_num)</span></span><br><span class="line">            queue = next_queue</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：在典型的 BFS 算法中，queue 变量通常是数组或列表类型。这里可以使用 set 类型，以消除同一级别中的剩余项的冗余。事实证明，这个小技巧甚至可以增加 5 倍的运行加速。</li>
<li>set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</li>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mfrac><mi>h</mi><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{\frac{h}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22902em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.97902em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <code>h</code> 是 N 元树的高度。</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><msup><mo stretchy="false">)</mo><mi>h</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((\sqrt{n})^h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这也是在 <code>h</code> 级可以出现的最大节点数。可以看到，虽然我们保留了一个完全平方数列表，但是空间的主要消耗是队列变量，它跟踪给定 N 元树级别上要访问的剩余节点。</li>
</ul>
<h1 id="127-单词接龙"><a class="markdownIt-Anchor" href="#127-单词接龙"></a> 127-单词接龙</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ul>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ul>
</li>
<li>
<p>说明：</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>题解参考：<a href="https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/</a></li>
</ul>
</blockquote>
<ul>
<li>Python的<code>defaultdict</code>：
<ul>
<li><a href="https://segmentfault.com/a/1190000010081065" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010081065</a></li>
<li>这里使用的是<code>collections.defaultdict</code>类。
<ul>
<li>defaultdict是Python内建dict类的一个子类，第一个参数为default_factory属性提供初始值，默认为None。它覆盖一个方法并添加一个可写实例变量。它的其他功能与dict相同，但会为一个不存在的键提供默认值，从而避免KeyError异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以list类名称作为参数，当访问不存在的键，会添加并返回默认值（一个空列表）</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对给定的 wordList 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line">                </span><br><span class="line">				<span class="comment"># 将包含 beginWord 和 1 的元组放入队列中，1 代表节点的层次。</span></span><br><span class="line">        <span class="comment"># 我们需要返回 endWord 的层次也就是从 beginWord 出发的最短距离。</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 为了防止出现环，使用访问数组记录。</span></span><br><span class="line">        visited = &#123;beginWord: <span class="literal">True</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当队列中有元素的时候，取出第一个元素，记为 current_word。</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 找到current_word所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 all_combo_dict 来实现。</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="comment"># 从 all_combo_dict 获得的所有单词，都和 current_word 共有一个通用状态，所以都和 current_word 相连</span></span><br><span class="line">                <span class="comment"># 因此将他们加入到队列中。</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="literal">True</span></span><br><span class="line">                        <span class="comment"># 对于新获得的所有单词，向队列中加入元素 (word, level + 1) 其中 level 是 current_word 的层次。</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(M×N)，其中 M 是单词的长度 ，N 是单词表中单词的总数。找到所有的变换需要对每个单词做 M次操作。同时，最坏情况下广度优先搜索也要访问所有的 N 个单词。</li>
<li>空间复杂度：O(M×N)，要在 all_combo_dict 字典中记录每个单词的 M个通用状态。访问数组的大小是 N。广搜队列最坏情况下需要存储 N个单词。</li>
</ul>
<h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1>
<h2 id="思想-2"><a class="markdownIt-Anchor" href="#思想-2"></a> 思想</h2>
<p> 深度优先搜索就是把一些问题抽象成一个图，然后一个结点一个结点的遍历，直到没有新的结点可以遍历。</p>
<ul>
<li>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong> 问题。</li>
<li>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</strong></li>
</ul>
<p> 在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li><strong>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</strong></li>
<li><strong>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</strong></li>
</ul>
<h1 id="695-岛屿最大面积"><a class="markdownIt-Anchor" href="#695-岛屿最大面积"></a> 695-岛屿最大面积</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个包含了一些 <code>0</code> 和 <code>1</code> 的非空二维数组 <code>grid</code> 。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">对于上面这个给定的矩阵, 返回 0。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：给定的矩阵<code>grid</code> 的长度和宽度都不超过 50。</p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>深度优先搜索：遍历网格，在每个网格上，搜索上、下、左、右四个方向的网格的1，连接起来的就是岛屿的面积</li>
<li>需求求解最大面积，因此，不断更新当前岛屿的最大面积</li>
<li>避免重复遍历，将已经搜索过的网格值置为0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n <span class="keyword">and</span> grid[i][j]:</span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, i + <span class="number">1</span>, j) + dfs(grid, i - <span class="number">1</span>, j) + dfs(grid, i, j + <span class="number">1</span>) + dfs(grid, i, j <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                result = max(result, dfs(grid, x, y))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m，n分别是网格行数和列数，每个网格最多遍历一遍</li>
<li>空间复杂度：O(m * n)，递归的深度最大可能是整个网格的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200-岛屿数量</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>本题和695题思路是一样的，不一样的地方在于，695题是找上下左右1的最大总数为题目所求，本题是搜索次数为题目所求。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i ,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; len(grid) <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[i][j] == <span class="string">'1'</span>:  </span><br><span class="line">                grid[i][j] = <span class="string">'0'</span></span><br><span class="line">                dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">                dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">                dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m，n分别是网格行数和列数，每个网格最多遍历一遍</li>
<li>空间复杂度：O(m * n)，递归的深度最大可能是整个网格的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="547-朋友圈"><a class="markdownIt-Anchor" href="#547-朋友圈"></a> 547-朋友圈</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[ i ] [ j ] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：</p>
<ul>
<li>N 在[1,200]的范围内。</li>
<li>对于所有学生，有M [ i  ] [ i ] = 1。</li>
<li>如果有M [ i ] [ j ]  = 1，则有M [ j ] [ i ]  = 1。</li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>
<p>给定的矩阵可以看成图的邻接矩阵。这样我们的问题可以变成无向图连通块的个数。</p>
</li>
<li>
<p>从每一个结点开始，我们使用一个大小为N的visited的数组（M的大小为N*N），这样visited[i]表示第 i 个元素是否被深度优先搜索访问过。</p>
</li>
<li>
<p>我们首先选择一个节点，访问任一相邻的节点。然后再访问这一节点的任一相邻节点。这样不断遍历到没有未访问的相邻节点时，回溯到之前的节点进行访问。</p>
</li>
<li>
<p>连通块就是可以从任意起点到达的所有节点。</p>
</li>
<li>
<p>因此，连通块的个数，我们从每个未被访问的节点开始深搜，每开始一次搜索就增加 count计数器一次。</p>
</li>
<li>
<blockquote>
<p>扩展：<a href="https://leetcode-cn.com/problems/friend-circles/solution/python-shen-du-you-xian-sou-suo-by-alg_bingoxiaodo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/friend-circles/solution/python-shen-du-you-xian-sou-suo-by-alg_bingoxiaodo/</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, visited)</span>:</span></span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[j] <span class="keyword">and</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dfs(j, visited)</span><br><span class="line"></span><br><span class="line">        visited = [<span class="number">0</span>] * len(M)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">                dfs(i, visited)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n^2)，整个矩阵都要被遍历，大小为 n^2</li>
<li>空间复杂度：O(n)，visited 数组的大小。</li>
</ul>
<h1 id="130-被围绕的区域"><a class="markdownIt-Anchor" href="#130-被围绕的区域"></a> 130-被围绕的区域</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解释：</p>
<ul>
<li>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li>先处理边界上的O，把边界上的O先变成B，然后遍历整个二维矩阵，把O变成X，把B变成O。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        </span><br><span class="line">        row = len(board)</span><br><span class="line">        col = len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            board[i][j] = <span class="string">'B'</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                tmp_i = i + x</span><br><span class="line">                tmp_j = j + y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt;= tmp_i &lt; row <span class="keyword">and</span> <span class="number">1</span> &lt;= tmp_j &lt; col <span class="keyword">and</span> board[tmp_i][tmp_j] == <span class="string">'O'</span>:</span><br><span class="line">                    dfs(tmp_i, tmp_j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            <span class="comment"># 第一行</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(<span class="number">0</span>, j)</span><br><span class="line">            <span class="comment"># 最后一行</span></span><br><span class="line">            <span class="keyword">if</span> board[row - <span class="number">1</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(row - <span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="comment"># 第一列</span></span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(i, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 最后一列</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col - <span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(i, col - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="comment"># O 变成 X</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">"O"</span>:</span><br><span class="line">                    board[i][j] = <span class="string">"X"</span></span><br><span class="line">                <span class="comment"># B 变成 O</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">"B"</span>:</span><br><span class="line">                    board[i][j] = <span class="string">"O"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(mn)，m和n分别是行数和列数</li>
<li>空间复杂度：O(mn)，递归的深度最大可能是整个矩阵的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="417-太平洋大西洋水流问题"><a class="markdownIt-Anchor" href="#417-太平洋大西洋水流问题"></a> 417-太平洋大西洋水流问题</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p>
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p>
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
</li>
<li>
<p>提示：</p>
<ul>
<li>输出坐标的顺序不重要</li>
<li><em>m</em> 和 <em>n</em> 都小于150</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>分别从太平洋和大西洋的边界位置开始遍历，两次遍历的交集，就是所求。</li>
<li>遍历就是按照高度，从高到底，找下一个大于或等于当前的点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 流向太平洋的位置</span></span><br><span class="line">        res1 = set()</span><br><span class="line">        <span class="comment"># 流向大西洋的位置</span></span><br><span class="line">        res2 = set()</span><br><span class="line">        row = len(matrix)</span><br><span class="line">        col = len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从边界遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, cur, res)</span>:</span></span><br><span class="line">            res.add((i, j))</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>]]:</span><br><span class="line">                tmp_i = i + x</span><br><span class="line">                tmp_j = j + y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= tmp_i &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= tmp_j &lt; col <span class="keyword">and</span> matrix[i][j] &lt;= matrix[tmp_i][tmp_j] <span class="keyword">and</span> (tmp_i, tmp_j) <span class="keyword">not</span> <span class="keyword">in</span> res: </span><br><span class="line">                    dfs(tmp_i, tmp_j, matrix[i][j], res)</span><br><span class="line">        <span class="comment"># 太平洋</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            dfs(i, <span class="number">0</span>, <span class="number">0</span>, res1)</span><br><span class="line">        <span class="comment"># 太平洋</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            dfs(<span class="number">0</span>, j, <span class="number">0</span>, res1)</span><br><span class="line">        <span class="comment"># 大西洋</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            dfs(i, col - <span class="number">1</span>, <span class="number">0</span>, res2)</span><br><span class="line">        <span class="comment"># 大西洋</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            dfs(row - <span class="number">1</span>, j, <span class="number">0</span>, res2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1 &amp; res2</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-分治</title>
    <url>/2020/07/03/leetcode-%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾一下分治思想和leetcode上分治思想的经典题。</p>
<ul>
<li>241-为运算表达式设计优先级</li>
<li>95-不同的二叉搜索树II</li>
</ul>
<h1 id="分治"><a class="markdownIt-Anchor" href="#分治"></a> 分治</h1>
<p>分治的思想总结，下面两篇文章写的蛮详细的：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/45986027" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45986027</a></li>
<li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html</a></li>
</ol>
<p>这里就简单列举，可使用分治法求解的一些经典问题：</p>
<ol>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>Strassen矩阵乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li>汉诺塔</li>
</ol>
<ul>
<li>注意：分治的子问题独立，动态的子问题重叠</li>
</ul>
<h1 id="241-为运算表达式设计优先级"><a class="markdownIt-Anchor" href="#241-为运算表达式设计优先级"></a> 241-为运算表达式设计优先级</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;2-1-1&quot;</span><br><span class="line">输出: [0, 2]</span><br><span class="line">解释: </span><br><span class="line">((2-1)-1) &#x3D; 0 </span><br><span class="line">(2-(1-1)) &#x3D; 2</span><br><span class="line"></span><br><span class="line">输入: &quot;2*3-4*5&quot;</span><br><span class="line">输出: [-34, -14, -10, -10, 10]</span><br><span class="line">解释: </span><br><span class="line">(2*(3-(4*5))) &#x3D; -34 </span><br><span class="line">((2*3)-(4*5)) &#x3D; -14 </span><br><span class="line">((2*(3-4))*5) &#x3D; -10 </span><br><span class="line">(2*((3-4)*5)) &#x3D; -10 </span><br><span class="line">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>对于一个形如 <code>x op y</code>（op为运算符，x和y为数）的算式而言，<strong>它的结果组合取决于x和y的结果组合数</strong>，而x和y又可以写成形如<code>x op y</code>的算式。</li>
<li>因此，该问题的子问题就是 <code>x op y</code> 中的 <code>x</code> 和 <code>y</code>：<strong>以运算符分隔的左右两侧算式解</strong>。</li>
<li>然后我们来进行<strong>分治算法三步走</strong>：
<ol>
<li>分治：按运算符分成左右两部分，分别求解</li>
<li>求解：实现一个递归函数，输入算式，返回算式解</li>
<li>合并：根据运算符合并左右两部分的解，得出最终解</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type input: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> input.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [int(input)]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> input:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(input):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(input[:i])</span><br><span class="line">                right = self.diffWaysToCompute(input[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">'-'</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(Catalan(N)) = O((2n!)/n!(n-1)!)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h1 id="95-不同的二叉搜索树ii"><a class="markdownIt-Anchor" href="#95-不同的二叉搜索树ii"></a> 95-不同的二叉搜索树II</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：0 &lt;= n &lt;= 8</p>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li><strong>卡特兰数问题</strong>：<a href="https://www.jianshu.com/p/98191e939f00" target="_blank" rel="noopener">https://www.jianshu.com/p/98191e939f00</a>
<ul>
<li>什么是卡特兰数：卡特兰数又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。</li>
<li>一般项公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mfrac><mrow><mn>2</mn><mi>n</mi><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mi>n</mi><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_n = \frac{2n!}{(n+1)!n!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li><strong>二叉搜索树性质</strong>
<ul>
<li>中序遍历数列是递增的</li>
<li>若根节点为i，则左子树的节点为[1,…,i-1]，右子树的节点为[i+1,…,n]。</li>
</ul>
</li>
<li><strong>Python生成器</strong>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128</a></li>
<li><a href="https://www.runoob.com/python3/python3-iterator-generator.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-iterator-generator.html</a></li>
</ul>
</li>
<li><strong>Python缓存机制</strong>
<ul>
<li><a href="http://kuanghy.github.io/2016/04/20/python-cache" target="_blank" rel="noopener">http://kuanghy.github.io/2016/04/20/python-cache</a></li>
</ul>
</li>
<li>思路：
<ul>
<li>递归构造左右子树</li>
<li>两行递归 /迭代器递归（思路一样）：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/python-2xing-di-gui-7xing-sheng-cheng-qi-di-gui-by/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/python-2xing-di-gui-7xing-sheng-cheng-qi-di-gui-by/</a></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#根节点为0，表示不存在，返回[]</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#定义生成树函数，表示生成[left,...,right]的所有可能的二叉搜索树</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_Trees</span><span class="params">(left, right)</span>:</span> </span><br><span class="line">            <span class="comment">#初始化所有可能的二叉搜索树列表</span></span><br><span class="line">            all_trees = []</span><br><span class="line">            <span class="comment">#left&gt;right,说明无法构成二叉搜索树，返回[None]</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; right):</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            <span class="comment">#遍历每一种可能的节点i，遍历区间[left,right + 1)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">              	<span class="comment">#所有可能的左子树列表</span></span><br><span class="line">                left_trees = build_Trees(left, i - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">#所有可能的右子树列表</span></span><br><span class="line">                right_trees = build_Trees(i + <span class="number">1</span>, right)</span><br><span class="line">                <span class="comment">#组合所有方式，遍历左子树列表，遍历右子树列表</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left_trees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right_trees:</span><br><span class="line">                        <span class="comment">#建立当前树节点</span></span><br><span class="line">                        cur_tree = TreeNode(i)</span><br><span class="line">                        <span class="comment">#将左子树置为l</span></span><br><span class="line">                        cur_tree.left = l</span><br><span class="line">                        <span class="comment">#将右子树置为r</span></span><br><span class="line">                        cur_tree.right = r</span><br><span class="line">                        <span class="comment">#将构造好的树加入树列表</span></span><br><span class="line">                        all_trees.append(cur_tree)</span><br><span class="line">            <span class="keyword">return</span> all_trees</span><br><span class="line">        res = build_Trees(<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">1</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(l,r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> [TreeNode(root, left, right) <span class="keyword">for</span> root <span class="keyword">in</span> range(l,r+<span class="number">1</span>) <span class="keyword">for</span> left <span class="keyword">in</span> gen(l,root<span class="number">-1</span>) <span class="keyword">for</span> right <span class="keyword">in</span> gen(root+<span class="number">1</span>, r)] <span class="keyword">or</span> [<span class="literal">None</span>]</span><br><span class="line">        <span class="keyword">return</span> gen(<span class="number">1</span>,n)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(Catalan(N)) ，卡特兰数以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mn>4</mn><mi>n</mi></msup><msup><mi>n</mi><mfrac><mn>3</mn><mn>2</mn></mfrac></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{4^n}{n^{\frac{3}{2}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.578125em;vertical-align:-0.6671449999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91098em;"><span style="top:-2.3328550000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.224492857142857em;"><span style="top:-3.48775em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03144em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6671449999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>增长，因此，总的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><msup><mn>4</mn><mi>n</mi></msup><msup><mi>n</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\frac{4^n}{n^{\frac{1}{2}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.578125em;vertical-align:-0.6671449999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91098em;"><span style="top:-2.3328550000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.224492857142857em;"><span style="top:-3.48775em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03144em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6671449999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><msup><mn>4</mn><mi>n</mi></msup><msup><mi>n</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\frac{4^n}{n^{\frac{1}{2}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.578125em;vertical-align:-0.6671449999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91098em;"><span style="top:-2.3328550000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.224492857142857em;"><span style="top:-3.48775em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03144em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.532em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6671449999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-二分查找</title>
    <url>/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 回顾一下二分查找算法，并完成leetcode二分查找的经典题。</p>
<ul>
<li>69-x的平方根</li>
<li>744-寻找比目标字母大的最小字母</li>
<li>540-有序数组中的单一元素</li>
<li>278-第一个错误的版本</li>
<li>153-寻找旋转排序数组中的最小值</li>
<li>34-在排序数组中查找元素的第一个和最后一个位置</li>
</ul>
<h1 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h1>
<blockquote>
<p>参考：</p>
<p><a href="https://juejin.im/post/5d510f76f265da039a287a30%EF%BC%88%E4%B8%8B%E8%BF%B0%E4%BA%8C%E5%88%86%E5%86%85%E5%AE%B9%E5%87%BA%E5%A4%84%EF%BC%89" target="_blank" rel="noopener">https://juejin.im/post/5d510f76f265da039a287a30（下述二分内容出处）</a></p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/%EF%BC%88leetcode%E5%A4%A7%E4%BD%AC%E5%AF%B9%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/（leetcode大佬对二分查找的详细分析）</a></p>
</blockquote>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p> 二分查找（Binary Search）算法，也叫折半查找算法。二分查找的思想非常简单，有点类似分治的思想。二分查找针对的是一个<strong>有序的数据集合</strong>，每次都通过跟<strong>区间的中间元素</strong>对比，将待查找的<strong>区间缩小</strong>为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p>
<ul>
<li>时间复杂度：O(logn)</li>
<li>比很多O(1)的速度都要快，因为O(1)可能标示一个非常大的数值，如O(1000)。
<ul>
<li>有序数据：[1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59]，查找37</li>
<li>二分查找需要3步</li>
<li>顺序遍历需要11步。</li>
</ul>
</li>
</ul>
<h2 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h2>
<h3 id="二分查找依赖数组结构"><a class="markdownIt-Anchor" href="#二分查找依赖数组结构"></a> 二分查找依赖数组结构</h3>
<p> 二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。</p>
<h3 id="二分查找针对的是有序数据"><a class="markdownIt-Anchor" href="#二分查找针对的是有序数据"></a> 二分查找针对的是有序数据</h3>
<p> 二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
<p> 但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p>
<p> 所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p>
<h3 id="数据量太小不适合二分查找"><a class="markdownIt-Anchor" href="#数据量太小不适合二分查找"></a> 数据量太小不适合二分查找</h3>
<p> 如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。</p>
<h3 id="数据量太大不适合二分查找"><a class="markdownIt-Anchor" href="#数据量太大不适合二分查找"></a> 数据量太大不适合二分查找</h3>
<p> 二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。</p>
<h2 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h2>
<h3 id="中间值计算"><a class="markdownIt-Anchor" href="#中间值计算"></a> 中间值计算</h3>
<p> 二分查找的代码实现起来比较简单，需要说明的地方是中间值的计算，中间值得计算有两种方式，</p>
<ul>
<li>
<p>方式一：<code>int mid = (low +high) &gt;&gt; 1</code></p>
</li>
<li>
<p><strong>方式二</strong>：<code>int mid = low + ((high - low) &gt;&gt; 1)</code>。</p>
</li>
</ul>
<p> 方式一存在溢出的风险，当<code>low</code>和<code>high</code>比较大时，有可能会导致<code>mid</code>的值错误，从而使程序出错。方式二则可以保证生成的<code>mid</code>一定大于<code>low</code>，小于<code>high</code>。</p>
<h3 id="未成功查找的返回值"><a class="markdownIt-Anchor" href="#未成功查找的返回值"></a> 未成功查找的返回值</h3>
<p> 循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 arr 中的正确位置</li>
</ul>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:  <span class="comment">#循环条件</span></span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)  <span class="comment">#获取中间位置，数字的索引（序列前提是有序的）</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:  <span class="comment">#如果查询数字刚好为中间值，返回该值得索引</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target: <span class="comment">#如果查询数字比中间数字大，那就去二分后的右边找</span></span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment">#如果查询数字比中间数字小，那就去二分后的左边找</span></span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>                   <span class="comment">#如果循环结束，左边大于了右边，代表没有找到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">11</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">11</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="变形"><a class="markdownIt-Anchor" href="#变形"></a> 变形</h3>
<h4 id="查找第一个等于给定值的元素"><a class="markdownIt-Anchor" href="#查找第一个等于给定值的元素"></a> 查找第一个等于给定值的元素</h4>
<p> 比如我们给定数组<code>1,2,3,4,4,4,5,6,7,7,8,9</code>，我们需要查找第一个等于<code>4</code>的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt; target:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#判断当前是第一个元素或者前一个元素不等于要查找的值，则返回下标，如果前一个元素也等于要查找的值，则继续往前查找。</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的第一个数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>其他的都差不多，主要的区别是在<code>nums[mid]==value</code>时候，因为我们要查找的是第一个等于给定值的元素，所以我们需要判断<code>mid</code>的前一个元素等不等于给定值，如果前一个元素也等于给定值，则需要继续往左边查找。</li>
<li><strong>查找最后一个等于给定值的元素</strong>，判断<code>mid == len(arr) - 1 or arr[mid + 1] != target</code>是否满足，满足返回<code>mid</code>，否则 <code>l = mid + 1</code></li>
</ul>
<h4 id="查到第一个大于给定值的元素"><a class="markdownIt-Anchor" href="#查到第一个大于给定值的元素"></a> 查到第一个大于给定值的元素</h4>
<p> 比如我们给定数组<code>1,2,3,4,4,4,5,6,7,7,8,9,15,26,34,45</code>，我们随便输入一个值，这个值可以是数组里面的值，也不可不在数组里面，查找出第一个比给定值大的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            <span class="comment">#判断当前是第一个元素或者前一个元素不等于要查找的值，则返回下标，如果前一个元素也等于要查找的值，则继续往前查找。</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] &lt;= target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>        </span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">26</span>,<span class="number">34</span>,<span class="number">45</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'查找第一个大于输入的数：'</span>))</span><br><span class="line">    res = binarySearch(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>我们需要判断当<code>nums[mid] &gt; value</code>时，<code>nums[mid-1]</code>是否小于或者等于给定值，如果是则<code>mid</code>就是第一个大于给定值的元素，如果不是这继续往左边查找。</li>
<li>查找最后一个大于给定值的元素，直接返回数组最后一个元素就好了。</li>
</ul>
<h1 id="69-x的平方根"><a class="markdownIt-Anchor" href="#69-x的平方根"></a> 69-x的平方根</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p>思路：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>平方根的整数部分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k^2 ≤ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>值。因此我们可以对 k 进行二分查找，从而得到答案。</p>
<ul>
<li>下界：l == 0</li>
<li>上界：r == x</li>
</ul>
</li>
<li>
<p>本题三种解法的时间复杂度：袖珍计算器算法 &lt; 牛顿法 &lt; 二分查找法</p>
</li>
<li>
<blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/%EF%BC%88%E7%89%9B%E9%A1%BF%E6%B3%95%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/（牛顿法）</a></li>
<li><a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/%EF%BC%88%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E8%A2%96%E7%8F%8D%E8%AE%A1%E7%AE%97%E5%99%A8%E7%AE%97%E6%B3%95%E3%80%81%E7%89%9B%E9%A1%BF%E6%B3%95%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/（官方题解：二分查找、袖珍计算器算法、牛顿法）</a></li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span>  <span class="comment">#下界</span></span><br><span class="line">        r = x  <span class="comment">#上界</span></span><br><span class="line">        ans = <span class="number">-1</span>  <span class="comment">#返回结果初始化为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:   <span class="comment">#x的平方根的整数部分ans满足mid * mid &lt;= x的最大mid值</span></span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span>      <span class="comment">#满足mid * mid &lt;= x的最大mid值，右移寻找最大mid值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span>       </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(logn)，即为二分查找需要的次数。</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p><strong>思路</strong>：</p>
<ul>
<li>首先随便猜一个近似值 x，然后不断令 x 等于 x和 a/x 的平均数，迭代个六七次后 x 的值就已经相当精确了。</li>
<li>每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定，此时的结果已经足够我们得到答案了。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 ϵ，其中ϵ 一般可以取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>
<p><strong>原理</strong>：不断用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的切线来逼近方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2-a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的根。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>a</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">a</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>实际上就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2-a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的一个正实根，这个函数的导数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>。也就是说，函数上任意一点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>处的切线斜率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>。那么，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">x-f(x)/2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>就是一个比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更接近的近似值。代入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f(x)=x^2-a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-(x^2-a)/(2x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(x-a/x)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。同样的方法可以用在其它的近似值计算中。</p>
</li>
<li>
<p><strong>Q</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-f(x)/(2x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>怎么得到的？</p>
<ul>
<li>在评论区看到一个解答：设切线与x轴的交点横座标是a, 那么 斜率*(x-a) = f(x) - 0，代入斜率=2x，就得到a的表达式了。</li>
<li><strong>官方题解比较详细，建议查看</strong>：<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/</a></li>
</ul>
</li>
</ul>
<p><img alt="牛顿法" data-src="/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%89%9B%E9%A1%BF%E6%B3%95.jpg" class="lazyload"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#牛顿法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        a, x0 = float(x), float(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            xi = <span class="number">0.5</span> * (x0 + a / x0)</span><br><span class="line">            <span class="keyword">if</span> abs(x0 - xi) &lt; <span class="number">1e-7</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x0 = xi</span><br><span class="line">        <span class="keyword">return</span> int(x0)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)，此方法是二次收敛的，相较于二分查找更快。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="744-寻找比目标字母大的最小字母"><a class="markdownIt-Anchor" href="#744-寻找比目标字母大的最小字母"></a> 744-寻找比目标字母大的最小字母</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给你一个<strong>排序后</strong>的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<ul>
<li>如果目标字母 <code>target = 'z'</code> 并且字符列表为 <code>letters = ['a', 'b']</code>，则答案返回 <code>'a'</code></li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;a&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;c&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;d&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;g&quot;</span><br><span class="line">输出: &quot;j&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;j&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;k&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>letters</code>长度范围在<code>[2, 10000]</code>区间内。</li>
<li><code>letters</code> 仅由小写字母组成，最少包含两个不同的字母。</li>
<li>目标字母<code>target</code> 是一个小写字母。</li>
</ul>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>思路：类似查找第一个大于给定值的元素，不同之处是：
<ol>
<li>返回的不是下标，是元素</li>
<li>不需要判断所求元素的位置，换句话说，假设数组中重复字母为所求，我们不需要关注重复数组的第几个元素是我们需要的，因为都满足题意，直接返回就行了，所以不需要判断是否满足<code>mid == 0 or letters[mid - 1] != target</code>。</li>
<li>若查找不到，返回的不是-1，而是数组第一个值，即letters[0]</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span><span class="params">(self, letters, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type letters: List[str]</span></span><br><span class="line"><span class="string">        :type target: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(letters) - <span class="number">1</span></span><br><span class="line">        ans = letters[<span class="number">0</span>]  <span class="comment">#初始化返回结果ans = letters[0]</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> letters[mid] &gt; target:  <span class="comment">#若letters[mid] &gt; target，符合题目要求</span></span><br><span class="line">                ans = letters[mid]     <span class="comment">#将letters[mid]复制给ans</span></span><br><span class="line">                r = mid - <span class="number">1</span>            <span class="comment">#查找满足letters[mid] &gt; target的最小值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="540-有序数组中的单一元素"><a class="markdownIt-Anchor" href="#540-有序数组中的单一元素"></a> 540-有序数组中的单一元素</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个只包含整数的<strong>有序数组</strong>，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：您的方案应该在 <strong>O(log n)时间复杂度和 O(1)空间复杂度</strong>中运行。</p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>有序数组 + 时间复杂度O(logn) +空间复杂度O(1)，就要联想到二分查找~</li>
<li>分析：
<ul>
<li>每个元素都会出现两次，唯有一个数只会出现一次。因此，数组的<strong>长度是奇数</strong>，单个的数字只会出现在<strong>下标为偶数</strong>的位置。</li>
<li>因此可以延伸出以下两种思路：
<ol>
<li><strong>满足题意下，数组长度是奇数即存在单个数字</strong>。根据数组的长度去判断每次查找的区间：计算mid，判断nums[mid]前面或者后面是否有重复的数字，假设nums[mid]前面的数字与nums[mid]相等，看nums[0:mid-2]和nums[mid+1:]两个区间的长度，下一次移动的方向就往区间长度是奇数的方向移动。如果nums[mid]前面和后面的数字都与nums[mid]不等，说明nums[mid]即为所求。直到l和r指向同一个数，那么这个数即为所求。</li>
<li><strong>满足题意下，单个出现数字的下标是偶数</strong>。对偶数索引做二分查找，计算mid，保证mid每次都是偶数，判断nums[mid]和后一个数是否相等，如果相等，nums[mid]就不是单一元素，且单个元素在nums[mid]之后；如果不相等，单个元素则可能就说nums[mid]或在nums[mid]之前。当l==r，搜索空间剩一个元素，那即为所求。</li>
</ol>
</li>
</ul>
</li>
<li>个人认为<strong>思路1</strong>在面试时候会<strong>更好解释</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid - <span class="number">1</span>]:  <span class="comment">#判断nums[mid]与前一个数是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (mid - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#判断mid左侧区间长度</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == nums[mid + <span class="number">1</span>]:  <span class="comment">#判断nums[mid]与后一个数是否相等</span></span><br><span class="line">                <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#判断mid左侧区间长度</span></span><br><span class="line">                    l = mid + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span>:  <span class="comment">#保证mid始终是偶数</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid + <span class="number">1</span>]:  <span class="comment">#如果nums[mid]==nums[mid+1]，单个数在nums[mid]右侧</span></span><br><span class="line">                l = mid + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid   <span class="comment">#否则，单个数是nums[mid]或nums[mid]左侧</span></span><br><span class="line">        <span class="keyword">return</span> nums[l]    <span class="comment">#l == r时找到</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log(n/2)) = O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="278-第一个错误的版本"><a class="markdownIt-Anchor" href="#278-第一个错误的版本"></a> 278-第一个错误的版本</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p>分析：版本号<code>n</code>取值范围<code>[1,2,...,n]</code>，找到第一个出错的版本。第一个出错版本的特点是，其前一个版本为<code>false</code>，自身显示为<code>true</code>。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>计算<code>mid</code></li>
<li>判断<code>mid</code>是否为<code>true</code>，如果是<code>true</code>，判断<code>mid-1</code>是否为<code>false</code>，如果是<code>false</code>，返回<code>mid</code>，如果<code>mid-1</code>是<code>true</code>，说明第一个错误版本在<code>mid</code>左侧。</li>
<li>如果<code>mid</code>是<code>false</code>，判断<code>mid+1</code>是否为<code>true</code>，如果是<code>true</code>，返回<code>mid+1</code>，如果<code>mid + 1</code>是<code>false</code>，说明第一个错误版本在<code>mid</code>右侧。</li>
</ul>
</li>
<li>
<blockquote>
<p>语法知识点：Python中<code>is</code>和<code>==</code>的区别</p>
<ul>
<li><a href="https://juejin.im/entry/5a3b62446fb9a0451f311b5c" target="_blank" rel="noopener">https://juejin.im/entry/5a3b62446fb9a0451f311b5c</a></li>
<li>在ython中一切都是对象</li>
<li>Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。对象之间比较是否相等可以用==，也可以用is。</li>
<li>is和==都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。(is是内存地址，==是值)
<ul>
<li><strong>is比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</strong></li>
<li><strong>==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。</strong></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">1</span></span><br><span class="line">        r = n</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> isBadVersion(mid - <span class="number">1</span>) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> isBadVersion(mid + <span class="number">1</span>) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153. 寻找旋转排序数组中的最小值</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：假设按照<strong>升序排序</strong>的数组在<strong>预先未知的某个点</strong>上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。你可以假设数组中不存在重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>分析：升序排序数组，旋转，从旋转点可以将数组切分为左右两部分，左右部分依旧是升序。因此，可以转化为寻找旋转点，旋转点下一个数就是最小值。
<ul>
<li><strong>旋转点特点</strong>：
<ul>
<li>旋转点左侧元素 &gt; 数组第一个元素</li>
<li>旋转点右侧元素 &lt;数组第一个元素</li>
</ul>
</li>
<li><strong>两种情况</strong>：
<ul>
<li>最小值在数组中：数组的第一个元素会大于数组的最后一个元素</li>
<li>最小值在数组头：数组的第一个元素会小于数组的最后一个元素</li>
</ul>
</li>
<li><strong>区间判断</strong>：
<ul>
<li>计算mid</li>
<li>如果nums[mid] &gt; 数组第一个元素，说明最小值在mid右侧</li>
<li>如果nums[mid] &lt; 数组第一个元素，说明最小值在mid左侧</li>
</ul>
</li>
<li><strong>确定最小值</strong>：找到旋转点后下一个数就是最小值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[r] &gt; nums[l] <span class="keyword">or</span> len(nums) == <span class="number">1</span>:  <span class="comment">#未旋转或数组长度等于1时，返回数组第一个数字</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:  <span class="comment">#nums[mid]是旋转点，返回下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nums[mid - <span class="number">1</span>] &gt; nums[mid]:  <span class="comment">#nums[mid - 1]是旋转点，返回下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[<span class="number">0</span>]:        <span class="comment">#nums[mid]大于数组第一个元素，最小值在mid右侧</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                          <span class="comment">#否则在mid左侧</span></span><br><span class="line">                r = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a> 34-在排序数组中查找元素的第一个和最后一个位置</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>分析：本题和查找第一个等于给定值的元素思路一样。</li>
<li>思路：
<ul>
<li>初始化list保存返回结果</li>
<li>先查找第一个等于给定值的元素，将下标加入list</li>
<li>再查找最后一个等于给定值的元素，将下标加入list</li>
</ul>
</li>
<li>算法：
<ul>
<li>计算mid</li>
<li>如果nums[mid] &gt; target，说明在mid左侧</li>
<li>如果nums[mid] &lt; target，说明在mid右侧</li>
<li>如果nums[mid] == target，判断当前是第一个元素或者前一个元素不等于要查找的值，则将下标加入list，如果前一个元素也等于要查找的值，则r = mid - 1</li>
<li>如果nums[mid] == target，判断当前是最后一个元素或后一个元素不等于要查找的值，则将下标加入list，否则l = mid + 1</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        res.append(self.firstNum(nums,target))</span><br><span class="line">        res.append(self.lastNum(nums,target))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstNum</span><span class="params">(self, nums, target)</span>:</span>  <span class="comment">#查找第一个元素</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid] != nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastNum</span><span class="params">(self, nums, target)</span>:</span>   <span class="comment">#查找最后一个元素</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">if</span> mid == len(nums) - <span class="number">1</span> <span class="keyword">or</span> nums[mid] != nums[mid + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-贪心</title>
    <url>/2020/06/27/leetcode-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>title: leetcode-贪心<br>
date: 2020-06-27 02:05:59<br>
categories: 刷题</p>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>简单回顾贪心算法思想，并完成leetcode中几道经典的贪心算法题。</p>
<ul>
<li>455-分发饼干</li>
<li>435-无重叠区间</li>
<li>452-用最少数量的箭引爆气球</li>
<li>406-根据身高重建队列</li>
<li>121-买卖股票的最佳时机</li>
<li>122-买卖股票的最佳时机II</li>
<li>605-种花问题</li>
<li>392-判断子序列</li>
<li>665-非递减数列</li>
<li>53-最大子序和</li>
<li>763-划分字母区间</li>
</ul>
<h1 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h1>
<blockquote>
<p>引用labuladong公众号-《运用贪心算法来做时间管理》</p>
<ul>
<li>什么是贪心算法呢？
<ul>
<li>贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</li>
<li>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</li>
</ul>
</li>
<li>什么是贪心选择性质？
<ul>
<li>简单的说就是，每一步都做出一个局部最优选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一小部分问题拥有这个性质。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干"></a> 455-分发饼干</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>你可以假设胃口值为正。</li>
<li>一个小朋友最多只能拥有一块饼干。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line"></span><br><span class="line">输入: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>分析：
<ul>
<li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li>
<li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li>
</ul>
</li>
<li>证明：上述贪心策略，可以从局部最优达到全局最优
<ul>
<li>反证法：假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</li>
<li>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type g: List[int]</span></span><br><span class="line"><span class="string">        :type s: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> g:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> j &lt; len(g):  </span><br><span class="line">            <span class="keyword">if</span> s[i] &gt;= g[j]:  <span class="comment">#如果最小的饼干能满足胃口最小的孩子</span></span><br><span class="line">                count += <span class="number">1</span>    <span class="comment">#满足人数+1</span></span><br><span class="line">                i += <span class="number">1</span>        <span class="comment">#找剩下饼干中最小的饼干</span></span><br><span class="line">                j += <span class="number">1</span>        <span class="comment">#找剩下孩子中胃口最小的孩子</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span>        <span class="comment">#最小饼干不满足胃口最小的孩子，从剩下饼干中找最小的饼干</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，最多需要遍历s和g</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="435-无重叠区间"><a class="markdownIt-Anchor" href="#435-无重叠区间"></a> 435-无重叠区间</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>分析：
<ul>
<li>把问题转换成：最多能选取几个区间不重叠的区域</li>
<li>那答案显然变成：总区间个数-不重叠区间个数</li>
</ul>
</li>
<li>步骤：
<ol>
<li>按照结束时间从小到大排序，然后对新列表遍历</li>
<li>判断当前区间是否满足：开始时间大于或等于上一次的结束时间</li>
<li>每次都选结束时间最早的</li>
<li>每选一次更新一下结束时间</li>
<li>返回总区间个数-不重叠区间个数</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        intervals = sorted(intervals, key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>   <span class="comment">#不重叠区域个数</span></span><br><span class="line">        end = -float(<span class="string">'inf'</span>)  <span class="comment">#初始化结束时间无穷小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">0</span>] &gt;= end: <span class="comment">#开始时间大于或等于上一次结束时间</span></span><br><span class="line">                ans += <span class="number">1</span>    <span class="comment">#不重叠区域个数+1</span></span><br><span class="line">                end = i[<span class="number">1</span>]  <span class="comment">#每选择一次更新一下结束时间</span></span><br><span class="line">        <span class="keyword">return</span> len(intervals) - ans</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlogn)，sorted()排序时间复杂度：O(nlogn)，遍历一遍数组O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="452-用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#452-用最少数量的箭引爆气球"></a> 452-用最少数量的箭引爆气球</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>， 且满足  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>≤</mo><mi>x</mi><mo>≤</mo><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{start}≤ x ≤ x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>分析：
<ul>
<li>本题和435题类似，不同之处在于，本题[1,2]和[2,3]算重叠区间</li>
<li>举例分析：
<ul>
<li>假设只有1个气球，那么最少需要一支箭引爆</li>
<li>假设有两个气球，坐标为[1,2]和[2,3]，此时第二个气球的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>小于或等于第一个气球的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>坐标，因此重叠，至少需要一支箭引爆气球</li>
<li>假设有三个气球，坐标为[1,2]和[2,3]和[3,4]，此时第三个气球的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>坐标大于前两个气球的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>坐标的最小值，因此第三个区间不与前两个区间重叠，至少需要两支箭</li>
</ul>
</li>
</ul>
</li>
<li>步骤：
<ul>
<li>按照分析，如果有一个气球（区间），就至少需要一支箭，可以进行特例判断</li>
<li>按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>从小到大排序，然后对新列表遍历</li>
<li>判断当前区间是否满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大于上一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>每次判断重叠区域都更新历史气球的最小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>每增加一支箭就更新当前气球的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{end}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(points)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        points = sorted(points, key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">1</span>  <span class="comment">#只要有区间，就至少需要一支箭</span></span><br><span class="line">        end = points[<span class="number">0</span>][<span class="number">1</span>]  <span class="comment">#初始化end为第一个区间的x_end坐标值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; end:</span><br><span class="line">                ans += <span class="number">1</span> <span class="comment">#箭数+1</span></span><br><span class="line">                end = points[i][<span class="number">1</span>] <span class="comment">#记录当前气球的x_end</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = min(end, points[i][<span class="number">1</span>])  <span class="comment">#每次判断重叠区域都更新历史气球的最小x_end</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlogn)，sorted()排序时间复杂度：O(nlogn)，遍历一遍数组O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列"></a> 406-根据身高重建队列</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
</li>
<li>
<p>注意：总人数少于1100人。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>思路：
<ul>
<li>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</li>
<li>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</li>
</ul>
</li>
<li>举例分析：
<ul>
<li>最简单的情况，当队列所有人的（h,k）都是相同的高度h，只有k不同时，解决方案很简单：每个人在队列的索引index=k。</li>
<li>即使不是所有人都是同一高度，这个策略也是可行的。因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。</li>
<li>如[7,1]，[6,1]，[7,0]，我们先安排身高为7的人，把他放在与k值相等索引上，再安排身高为6的人，同样把他放在与k值相等索引上。</li>
<li>该策略可以递归进行：
<ul>
<li>将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。</li>
<li>按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。</li>
<li>直到完成为止。</li>
</ul>
</li>
</ul>
</li>
<li>步骤：
<ul>
<li>排序：
<ul>
<li>按高度h降序排序</li>
<li>在同一高度的人中，按k值的升序排序</li>
</ul>
</li>
<li>逐个地把它们放在输出队列中，索引等于它们的 <code>k</code> 值。</li>
<li>返回输出队列</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type people: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> people:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#升高按降序，k值按升序排序</span></span><br><span class="line">        people = sorted(people, key = <span class="keyword">lambda</span> x : (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            output.insert(p[<span class="number">1</span>],p)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。排序使用了O(nlogn)，每个人插入输出队列需要O(k)，其中k是当前输出队列的元素个数。总共的时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>K</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{k=0}^{N-1}K=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> 121-买卖股票的最佳时机</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
</li>
<li>
<p>注意：你不能在买入股票前卖出股票</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>第一次面试时候二面考的题~</li>
<li>思路：
<ul>
<li>记录历史购买股票的最低价，以这个价格作为买入价格。</li>
<li>以当前的价格作为卖出价格，更新最大收益。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line">        min_value = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_value = min(min_value, price)</span><br><span class="line">            max_value = max(max_value, price - min_value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，需要遍历一遍数组</li>
<li>空间复杂度：O(1)，常量空间</li>
</ul>
<h1 id="122-股票买卖的最佳时间ii"><a class="markdownIt-Anchor" href="#122-股票买卖的最佳时间ii"></a> 122-股票买卖的最佳时间II</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（<strong>多次买卖一支股票</strong>）。</p>
</li>
<li>
<p>注意：你不能同时参与多笔交易（<strong>你必须在再次购买前出售掉之前的股票</strong>）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>思路：<strong>只要股票有涨，我们就买卖</strong>。
<ul>
<li>即相邻的两个数，后者减去前者如果是正数，我们就将其差值加入利润，这样遍历一遍数组，即可获得最大利润。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        max_value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i + <span class="number">1</span>] - prices[i] &gt; <span class="number">0</span>:</span><br><span class="line">                max_value += prices[i + <span class="number">1</span>] - prices[i]</span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，需要遍历一遍数组</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="605-种花问题"><a class="markdownIt-Anchor" href="#605-种花问题"></a> 605-种花问题</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：</p>
<ul>
<li>数组内已种好的花不会违反种植规则。</li>
<li>输入的数组长度范围为 [1, 20000]。</li>
<li><strong>n</strong> 是非负整数，且不会超过输入数组的大小。</li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li>思路：<strong>三个连续的0可以种一朵花</strong>。
<ul>
<li>从左到右扫描数组，如果数组有一个0，且这个0的左右两边也都是0，那么我们就可以再这个0种花，即将这个位置的值设为1，计数器count增加1。</li>
</ul>
</li>
<li>**需要考虑边界情况：**数组首尾是否为0。</li>
<li>如果可以修改原数组，我们可以在数组首尾添加0，避免边界的判断。</li>
<li>如果不可以修改原数组，我们可以只判断一侧是否是0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不修改数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type flowerbed: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#初始化种花数位0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        length = len(flowerbed)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#边界：花坛的位置少于一个</span></span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> flowerbed.count(<span class="number">0</span>) &gt;= n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 花盆，判断当前花盆的前一个花盆和后一个花盆以及当前花盆是否为空花盆，是就计数，并种上花</span></span><br><span class="line">        <span class="comment"># 第一个和最后一个需要特殊处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flowerbed[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> flowerbed[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> flowerbed[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> flowerbed[i] == flowerbed[i - <span class="number">1</span>] == flowerbed[i + <span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                flowerbed[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> flowerbed[<span class="number">-1</span>] == flowerbed[<span class="number">-2</span>] == <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count &gt;= n</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type flowerbed: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flowerbed = [<span class="number">0</span>] + flowerbed + [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        length = len(flowerbed)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> flowerbed[i - <span class="number">1</span>] == flowerbed[i] == flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                n = n - <span class="number">1</span></span><br><span class="line">                flowerbed[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，需要遍历一遍数组</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="392-判断子序列"><a class="markdownIt-Anchor" href="#392-判断子序列"></a> 392-判断子序列</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 true.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 false.</span><br><span class="line"></span><br><span class="line">后续挑战 :</span><br><span class="line"></span><br><span class="line">如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>思路：双指针。设置两个指针，遍历两个字符串，判断字符串s的每个字符是否存在于t且对应顺序一致。</li>
<li><strong>没感觉到贪心，反而就是简单的双指针。</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span>  <span class="comment">#已遍历s中的字符数</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> j &lt; len(t):</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count == len(s)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(n)，n为字符串t的长度，最多需要遍历整个字符串t</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p><strong>后续挑战：哈希表+二分法</strong></p>
</li>
<li>
<p>用哈希集合hase_set记录下t中每个字符出现过的位置，即最多有26个key</p>
</li>
<li>
<p>对s中每个字母进行匹配，s[i]一定出现在s[i-1]之后，所以匹配s[i]的时候，应该找hash_set[s[i]]中大于s[i-1]的索引的索引值</p>
</li>
<li>
<p>我们用匹配左边界的二分法（即匹配第一个大于等于目标值的数），找当前字母索引列表中第一个大于上一个字母索引的值</p>
</li>
<li>
<p>如果某个匹配到的边界值等于当前字幕索引列表的长度，则表明无法匹配当前字母，返回False</p>
</li>
<li>
<p>全部成功匹配返回True</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        hash_set = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(t):</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> hash_set:</span><br><span class="line">                hash_set[word] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_set[word].append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 匹配</span></span><br><span class="line">        index = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> hash_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 字母s出现的索引 用二分法找到其中大于index的第一个</span></span><br><span class="line">            indexes = hash_set[word]</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = len(indexes)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> indexes[mid] &gt; index:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == len(indexes):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            index = indexes[left]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(nlogn)，n是s的长度，二分查找O(logn)</li>
<li>空间复杂度：O(1)，最多有26个key</li>
</ul>
<h1 id="665-非递减数列"><a class="markdownIt-Anchor" href="#665-非递减数列"></a> 665-非递减数列</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,2,3]</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,2,1]</span><br><span class="line">输出: false</span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10 ^ 4</code></li>
<li><code>- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</code></li>
</ul>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>思路：遍历一遍数组，相邻的两个数，用后者减去前者得到差值，判断差值是否大于或等于0，如果不是，计数器count增加1，遍历数组时，如果count大于1，直接break，返回False。</li>
<li>**特殊情况（比较难考虑到）：如[2,4,0,1]
<ul>
<li>当下标 i == 2 时，nums[i] &lt; nums[i-1]，也就是 0 &lt; 4，这时我们<strong>要保证数组非递减有两种选择</strong>：
<ul>
<li>选择 1：把 0 放大，并且保证 0 后面的数不能比 4 小，0 前面的数均是非递减的；<code>nums[i + 1] &gt; nums[i - 1]</code></li>
<li>选择 2：把 4 缩小，并且保证 4 前面的数不能比 0 大，4 后面的数均是非递减的。<code>nums[i-2]&lt;nums[i]</code></li>
</ul>
</li>
<li>换言之，当 0 &lt; 4时，如果以上两个选择中的保证同时不满足，说明该数组肯定无法通过只修改一个元素而变为非递减数组，该情况即为上述提到的 “特殊情况”。对于本例，有：当 0 &lt; 4时，0 后面的数为 1，1 小于 4，不满足选择 1 的保证；且 4 前面的数为 2，4 后面的数为 0，0 小于 2，不满足选择 2 的保证。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; n <span class="keyword">and</span> i - <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>] <span class="keyword">and</span> nums[i - <span class="number">2</span>] &gt; nums[i]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，遍历一遍数组，长度为n</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="53-最大子序和"><a class="markdownIt-Anchor" href="#53-最大子序和"></a> 53-最大子序和</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进阶：</p>
<ul>
<li>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</li>
</ul>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li>思路：
<ul>
<li>对数组进行遍历，初始化当前最大连续子序列和cur_sum = 0，结果max_sum = nums[0]</li>
<li>如果cur_sum &gt; 0，则说明cur_sum对结果有增益效果，则 cur_sum 保留并加上当前遍历数字</li>
<li>如果cur_sum &lt; 0，则说明cur_sum对结果无增益效果，则 cur_sum 更新为当前遍历数数字</li>
<li>每次比较cur_sum和max_sum的值，将大的赋值给max_sum</li>
<li>返回max_sum</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            return nums[0]</span><br><span class="line">        </span><br><span class="line">        cur_sum &#x3D; 0</span><br><span class="line">        max_sum &#x3D; nums[0]</span><br><span class="line"></span><br><span class="line">        for num in nums:</span><br><span class="line">            if cur_sum &gt; 0:</span><br><span class="line">                cur_sum +&#x3D; num</span><br><span class="line">            else:</span><br><span class="line">                cur_sum &#x3D; num</span><br><span class="line">            max_sum &#x3D; max(cur_sum, max_sum)</span><br><span class="line">            </span><br><span class="line">        return max_sum</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(n)，遍历一遍数组</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>分治解法时间复杂度是O(n)，空间复杂度O(log)，效果不如上述方法，因此参考下述链接了解即可：</p>
</li>
<li>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</a></p>
</blockquote>
</li>
</ul>
<h1 id="763-划分字母区间"><a class="markdownIt-Anchor" href="#763-划分字母区间"></a> 763-划分字母区间※</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
<li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li>
</ul>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<ul>
<li>思路：
<ul>
<li>策略就是不断地选择从最左边起最小的区间。可以从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，这些字母会让区间变大。举个例子，在 “abccaddbeffe” 字符串中，第一个最小的区间是 “abccaddb”。</li>
<li>通过以上的分析，我们可以得出一个算法：对于遇到的每一个字母，去找这个字母最后一次出现的位置，用来更新当前的最小区间。</li>
</ul>
</li>
<li>步骤：
<ul>
<li>定义数组 last[char] 来表示字符 char 最后一次出现的下标。定义 anchor 和 j 来表示当前区间的首尾。</li>
<li>如果遇到的字符最后一出现的位置下标大于 j， 就让 j=last[c] 来拓展当前的区间。</li>
<li>当遍历到了当前区间的末尾时(即 i==j )，把当前区间加入答案，同时将 start 设为 i+1 去找下一个区间。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找到每个元素出现的最后位置,字典的形式，通过元素找到下标</span></span><br><span class="line">        last = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S)&#125;</span><br><span class="line">        <span class="comment">#设置当前字符串区间</span></span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        <span class="comment">#保存字符串的长度</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#开始遍历元素"ababcbacadefegdehijhklij"</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="comment">#设置尾部</span></span><br><span class="line">            end = max(end, last[c])</span><br><span class="line">            <span class="comment">#当区间里所有元素都遍历过</span></span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                res.append(end - start + <span class="number">1</span>)</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode-排序1</title>
    <url>/2020/06/26/leetcode-%E6%8E%92%E5%BA%8F1/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾完八大排序，刷一下leetcode中排序的经典题目。</p>
<ul>
<li>215-数组中的第k个最大元素</li>
<li>347-前k个高频元素</li>
<li>451-根据字符出现频率排序</li>
<li>75-颜色分类</li>
</ul>
<h2 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215-数组中的第k个最大元素</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
</li>
</ul>
<h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3>
<ul>
<li>思路：Topk问题 和 kth 问题，可以使用快排和堆排序。</li>
<li>快排步骤
<ul>
<li>挑选基准值：从数列中挑出一个元素，称为&quot;基准&quot;（pivot）;</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快排递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            i = low - <span class="number">1</span>  <span class="comment">#最小元素索引</span></span><br><span class="line">            pivot = arr[high]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">              	<span class="comment"># 当前元素小于或等于pivot</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &lt; high:</span><br><span class="line">                pi = partition(arr, low, high)</span><br><span class="line">                quickSort(arr, low, pi - <span class="number">1</span>)</span><br><span class="line">                quickSort(arr, pi + <span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快排非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            i = low - <span class="number">1</span></span><br><span class="line">            pivot = arr[high]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            stack = [len(arr) - <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                low = stack.pop()</span><br><span class="line">                high = stack.pop()</span><br><span class="line">                index = partition(arr, low, high)</span><br><span class="line">                <span class="keyword">if</span> low &lt; index - <span class="number">1</span>:</span><br><span class="line">                    stack.append(index - <span class="number">1</span>)</span><br><span class="line">                    stack.append(low)</span><br><span class="line">                <span class="keyword">if</span> high &gt; index + <span class="number">1</span>:</span><br><span class="line">                    stack.append(high)</span><br><span class="line">                    stack.append(index + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最坏情况，存在倒序数组，此时递归树画出来是链表。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>堆排序步骤：（大顶堆升序）</p>
<ul>
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)；</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素；</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素；</li>
<li>如此反复进行交换、重建、交换，直到整个序列有序。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆排序-大顶堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span></span><br><span class="line">            largest = i</span><br><span class="line">            l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]:</span><br><span class="line">                largest = l</span><br><span class="line">            <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:</span><br><span class="line">                largest = r</span><br><span class="line">            <span class="keyword">if</span> largest != i:</span><br><span class="line">                arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">                heapify(arr, n, largest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">            n = len(arr)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                heapify(arr, n, i)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">                heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        heapSort(nums)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(Nlogk)，大小为 k 的堆中添加元素的时间复杂度为 O(logk)，我们将重复该操作 N 次，故总时间复杂度为O(Nlogk)。</li>
<li>空间复杂度：O(k)，存储堆元素</li>
<li>在 Python 的 <code>heapq</code> 库中有一个 <code>nlargest</code> 方法，具有同样的时间复杂度，能将代码简化到只有一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>另一种一行的代码sorted()，时间复杂度：O(NlogN)，空间复杂度：O(1)。</p>
</li>
<li>
<blockquote>
<p>python中，sorted和sort区别：<a href="https://www.runoob.com/python/python-func-sorted.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-sorted.html</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)[-k]</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a class="markdownIt-Anchor" href="#347-前k个高频元素"></a> 347-前k个高频元素</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个非空的整数数组，返回其中出现频率前 k高的元素。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的<strong>时间复杂度必须优于 O(n log n)</strong> , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</li>
</ul>
<h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3>
<ul>
<li>
<p>思路：哈希表/桶排序</p>
</li>
<li>
<p>哈希表</p>
<ul>
<li>现将数组中的数写到dict={}中</li>
<li>对哈希表中的value排序</li>
<li>取前k个值对应的key</li>
</ul>
</li>
<li>
<blockquote>
<p>涉及知识点：</p>
<ul>
<li>python字典排序：
<ul>
<li><a href="https://blog.csdn.net/tangtanghao511/article/details/47810729" target="_blank" rel="noopener">https://blog.csdn.net/tangtanghao511/article/details/47810729</a></li>
<li><a href="https://blog.csdn.net/liuweiyuxiang/article/details/98944416" target="_blank" rel="noopener">https://blog.csdn.net/liuweiyuxiang/article/details/98944416</a></li>
<li>格式：
<ul>
<li>lambda 参数列表：return [表达式] 变量</li>
<li>由于lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收</li>
</ul>
</li>
</ul>
</li>
<li>lambda函数的用法：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528</a></li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[num] += <span class="number">1</span></span><br><span class="line">        dict = sorted(dict.items(), key = <span class="keyword">lambda</span> items:items[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict:</span><br><span class="line">            res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(Nlogk)，遍历一遍数组O(N)，N为数组长度，字典排序时间复杂度：O(Nlogk)，k是k个键值对数</p>
</li>
<li>
<p>空间复杂度：O(K)，dict存储键值对K，res存储key值K个，O(2K)。</p>
</li>
<li>
<p>思路：桶排序</p>
<ul>
<li>当桶个数很大的时候，就是计数排序。基于桶排序的计数排序的过程，第一步就是需要统计原数组中各个数字的出现的频率，使用的方法是，先遍历出原始数组，找到最大值maxValue和最小值minValue，开辟maxValue-minValue大小的计数器数组counter。如nums =[2, 1, 3, 1, 5]， counter = [2, 1, 1, 0, 1] ， counter[0] 表示值 0 + minValue = 1 出现了2次。（1出现2次）。</li>
<li>这和上述哈希表统计各个数字出现的次数效果一样，时间复杂度和空间复杂度都是一样的，哈希表效果相对较好，原因是：当maxValue-minValue过大时，会产生内存浪费。</li>
<li>统计完各个数字出现的频率后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。时间复杂度上优化了对字典的排序。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>根据value获取key的三种方法：
<ul>
<li><a href="https://blog.csdn.net/weixin_41712499/article/details/89284930" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41712499/article/details/89284930</a></li>
</ul>
</li>
<li>python常用的字典操作：
<ul>
<li>dict.values()：Python 字典(Dictionary) values() 函数以列表返回字典中的所有值。</li>
<li>dict.items()：Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。</li>
</ul>
</li>
<li>append和extend的区别：
<ul>
<li><a href="https://www.jianshu.com/p/d83053742cb9" target="_blank" rel="noopener">https://www.jianshu.com/p/d83053742cb9</a></li>
<li><a href="https://blog.csdn.net/dpengwang/article/details/79102305" target="_blank" rel="noopener">https://blog.csdn.net/dpengwang/article/details/79102305</a></li>
<li>append：简单的说，append是直接在list后面添加元素，该元素是什么样就添加什么样。如a = [1,2,3]，b=[4]，a.append(b)–&gt;[1,2,3[4]]</li>
<li>extend：extend是扩展，在原有List上进行修改，没有返回值，可以扩展不同类型的变量，并将其内容以List变量的形式加入到原List中。如果extend的是字符串，则字符串会被拆分成字符数组，如果extend的是字典，则字典的key会被加入到List中。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        max_time = max(dict.values()) <span class="comment">#获取出现的最大次数</span></span><br><span class="line">        TongList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(max_time + <span class="number">1</span>)] <span class="comment">#根据最大次数生成桶</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict.items():</span><br><span class="line">            TongList[value].append(key)  <span class="comment">#将索引value放入key对应的字典索引 eg1:[[],[3],[2],[1]]</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_time, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment">#按桶索引排序</span></span><br><span class="line">            <span class="keyword">if</span> TongList[i]:</span><br><span class="line">                res.extend(TongList[i])  <span class="comment">#如果是append，eg1:[[1],[2]]</span></span><br><span class="line">            <span class="keyword">if</span> len(res) &gt;= k:</span><br><span class="line">                <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<blockquote>
<p>思路：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/yi-xing-python3dai-ni-zou-jin-counterlei-by-jimmy0/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/solution/yi-xing-python3dai-ni-zou-jin-counterlei-by-jimmy0/</a></p>
<ul>
<li>统计每个数的频率，输出最大的几个，这完全迎合了Python中的Counter类，调用其的几个方法即可。</li>
<li>什么是Counter？
<ul>
<li>Counter 是一个在collections包里的类，正如其名，是一个用于计数的工具。</li>
<li>我们可以用Counter(nums)这样的构造函数构造一个Counter类，其中nums是一个列表。</li>
<li>构造好的Counter实例可以看作一个字典，键是nums的每一项，值是它的出现次数。</li>
<li>如果上面的叙述让你感到很混乱的话，我不妨举个例子。
<ul>
<li>如果一个列表a = [1,1,3,4,3]，你想要统计每项的出现次数，那么你使用b = Counter(a)，那么这时候b就像一个这样的字典{1:2,3:2,4:1}，表示数字1出现了2次，数字3出现了2次，数字4出现了1次。</li>
<li>还是很好理解的吧？</li>
<li>可是题目里要我们输出的是最多的K项</li>
<li>这时候可以应用Counter的一个函数，most_common(k)</li>
<li>这个函数就是返回最多出现的K项</li>
<li>但是返回的形式是一个元祖列表，类似[(1,2),(3,2),(4,1)]的形式</li>
<li>我们只需要键也就是第一项，所以要使用列表生成式处理一下即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>
<h2 id="451-根据字符出现频率排序"><a class="markdownIt-Anchor" href="#451-根据字符出现频率排序"></a> 451-根据字符出现频率排序</h2>
<h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。</span><br><span class="line">因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3>
<ul>
<li>思路：本题和347题思路一致，只是在处理返回结果时操作不同：
<ul>
<li>哈希表+字典排序：
<ul>
<li>将字符串转为list，遍历一遍list，获取每个字符出现的频率</li>
<li>sorted函数倒序排序字典</li>
<li>初始化list保存字符出现频率按降序排序后的结果</li>
<li>遍历降序排序好的字典的键值对，当value（频率）≥1时，说明该字符（key）出现≥1次，那就append value次对应的key。</li>
<li>将list转为字符串返回即可。</li>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>桶排序：
<ul>
<li>将字符串转为list，遍历一遍list，获取每个字符出现的频率</li>
<li>获取最大出现次数</li>
<li>根据最大出现次数生成桶</li>
<li>将索引value放入key对应的字典索引</li>
<li>初始化res保存字符出现频率按降序排序后的结果</li>
<li>按桶索引i倒排序，如果对应桶索引有值，就遍历桶中的元素j，把每个元素逐一添加i次。</li>
<li>将list转为字符串</li>
<li>时间复杂度：O(n)，O(max_time^2 * len(TongList) )</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#哈希表 + 字典排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i] += <span class="number">1</span></span><br><span class="line">        dict = sorted(dict.items(), key = <span class="keyword">lambda</span> items: items[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">while</span> value &gt;= <span class="number">1</span>:</span><br><span class="line">                res.append(key)</span><br><span class="line">                value -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        max_times = max(dict.values())</span><br><span class="line">        TongList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(max_times + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict.items():</span><br><span class="line">            TongList[value].append(key)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_times, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> TongList[i]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> TongList[i]:</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                        res.append(j)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类"></a> 75-颜色分类</h2>
<h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
</li>
<li>
<p>注意：不能使用代码库中的排序函数来解决这道题。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进阶：</p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li>
<li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个<strong>仅使用常数空间的一趟扫描算法</strong>吗？</li>
</ul>
</li>
</ul>
<h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3>
<ul>
<li>
<p>思路：一次遍历和两次遍历</p>
<ul>
<li>
<p>两次遍历（非原地）：（如果没有要求原地处理数组，那是可以的，注意审题，题目要求的是原地处理！因为没注意审题，纠结了很久）</p>
<ul>
<li>用哈希表统计每个元素出现的个数</li>
<li>按照key值排序</li>
<li>初始化数组res保存返回结果</li>
<li>按照排好序的键值对填充数组res</li>
</ul>
</li>
<li>
<p>两次遍历（原地）：</p>
<ul>
<li>初始化数组res，由于最多只有3种颜色，res长度为3。</li>
<li>统计每个数字出现的次数，下标对应数字，数组值对应次数</li>
<li>初始化指针j指向nums第一个位置</li>
<li>依次读取每个数字出现的次数，对nums进行重写</li>
</ul>
</li>
<li>
<p>一次遍历：</p>
<ul>
<li>
<p>类似”冒泡“思想，遇到小的值就上浮到顶部，遇到大的值就下沉到底部。</p>
</li>
<li>
<p>需要使用三个指针，p0用来确定0的右边界、p2用来确定2的左边界、curr用来当前元素</p>
</li>
<li>
<p>沿着数组移动 <code>curr</code> 指针，若<code>nums[curr] = 0</code>，则将其与 <code>nums[p0]</code>互换；若 <code>nums[curr] = 2</code> ，则与 <code>nums[p2]</code>互换。</p>
</li>
<li>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</p>
<ul>
<li>初始化当前考虑的元素序号 ：curr = 0.</li>
</ul>
</li>
<li>
<p>While curr &lt;= p2 :</p>
<ul>
<li>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。
<ul>
<li>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</li>
</ul>
</li>
<li>若 nums[curr] = 1 ：将指针curr右移。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#两次遍历（原地）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        color = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#统计每个数字出现的次数，下标对应数字，数组值对应次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:  </span><br><span class="line">            color[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        j = <span class="number">0</span>  <span class="comment">#初始化指针j指向nums第一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#依次读取每个数字出现的次数，对nums进行重写</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(color[m]):</span><br><span class="line">                nums[j] = m</span><br><span class="line">                j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m为元素种类数，n为每种元素的出现的次数</li>
<li>空间复杂度：O(m)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0</span></span><br><span class="line">        <span class="comment"># curr是当前考虑元素的下标</span></span><br><span class="line">        p0 = curr = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2</span></span><br><span class="line">        p2 = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr &lt;= p2:</span><br><span class="line">            <span class="keyword">if</span> nums[curr] == <span class="number">0</span>:</span><br><span class="line">                nums[p0], nums[curr] = nums[curr], nums[p0]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                curr +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[curr] == <span class="number">2</span>:</span><br><span class="line">                nums[curr], nums[p2] = nums[p2], nums[curr]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，遍历一遍数组，n为数组长度</li>
<li>空间复杂度：O(1)，额外使用三个指针</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-排序</title>
    <url>/2020/06/24/leetcode-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾一下八大排序还有在leetcode中排序的经典题目。</p>
<ul>
<li>215-数组中的第k个最大元素</li>
<li>347-前k个高频元素</li>
<li>451-根据字符出现频率排序</li>
<li>75-颜色分类</li>
</ul>
<p>根据在排序过程中待排序记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。（八大排序）</p>
<p>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>
<h1 id="八大排序"><a class="markdownIt-Anchor" href="#八大排序"></a> 八大排序</h1>
<ul>
<li>插入排序
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>选择排序：
<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>交换排序：
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<h2 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h2>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<p> 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p>
<h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">insertionSort(arr1)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li><strong>稳定性</strong>：稳定</li>
</ul>
<h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2>
<h3 id="基本思想-2"><a class="markdownIt-Anchor" href="#基本思想-2"></a> 基本思想</h3>
<p> 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。</p>
<h3 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤</h3>
<ol>
<li>选择一个增量序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_1,t_2,...,t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>t</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t_i &gt; t_j, t_k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p> 我们简单处理增量序列：增量序列$d = {n/2 ,n/4, n/8 …1} <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span></span></span></span>n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">为</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">排</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">即</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">先</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">排</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">按</mi><mi mathvariant="normal">某</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">增</mi><mi mathvariant="normal">量</mi></mrow><annotation encoding="application/x-tex">为要排序数的个数。即：先将要排序的一组记录按某个增量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">排</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">排</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">按</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">量</span></span></span></span>d$（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d。</p>
<p> 对每组中全部元素进行直接插入排序，然后再用一个较小的增量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（d/2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span>对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，最后使用直接插入排序完成排序。</p>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#希尔排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    </span><br><span class="line">    n = len(arr)</span><br><span class="line">    gap = int(n/<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap , n):</span><br><span class="line">            </span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> arr[j - gap] &gt; temp:</span><br><span class="line">                arr[j] = arr[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            arr[j] = temp</span><br><span class="line">        gap = int(gap/<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">shellSort(arr1)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<p> 希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。</p>
<ul>
<li>
<p><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><strong>稳定性</strong>：不稳定</p>
</li>
</ul>
<h2 id="简单选择排序"><a class="markdownIt-Anchor" href="#简单选择排序"></a> 简单选择排序</h2>
<h3 id="基本思想-3"><a class="markdownIt-Anchor" href="#基本思想-3"></a> 基本思想</h3>
<p> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="步骤-3"><a class="markdownIt-Anchor" href="#步骤-3"></a> 步骤</h3>
<ol>
<li>从第一个元素开始，该元素可以被认为已经排序</li>
<li>从未排序的元素中，取出一个元素，与已排序的最后一个元素比较</li>
<li>如果已排序的最后一个元素大于该元素，则交换位置</li>
<li>直到排序完成</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#简单选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[min_idx] &gt; arr[j]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        arr[i], arr[min_idx] = arr[min_idx], arr[i]</span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">selectionSort(arr1)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li><strong>稳定性</strong>：稳定</li>
</ul>
<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<h3 id="基本思想-4"><a class="markdownIt-Anchor" href="#基本思想-4"></a> 基本思想</h3>
<ul>
<li><strong>概念</strong>：堆排序(Heap Sort)是利用堆这种数据结构而设计的一种排序算法，是对直接选择排序的有效改进。</li>
<li><strong>堆是具有以下性质的完全二叉树</strong>：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</li>
<li><strong>堆排序思想</strong>：将一个无序序列调整为一个堆，就能找出序列中的最大值（或最小值），然后将找出的这个元素与末尾元素交换，这样有序序列元素就增加一个，无序序列元素就减少一个，对新的无序序列重复操作，从而实现排序。</li>
<li><strong>堆的应用</strong>：是实现优先队列首选的数据结构，解决 TopK 问题、堆排序等。</li>
</ul>
<h3 id="步骤-4"><a class="markdownIt-Anchor" href="#步骤-4"></a> 步骤</h3>
<ol>
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)；</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素；</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素；</li>
<li>如此反复进行交换、重建、交换，直到整个序列有序。</li>
</ol>
<p> 从算法描述来看，**堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。**所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆排序-升序-大顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span>  </span><br><span class="line">    </span><br><span class="line">    largest = i</span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>     <span class="comment">#left = 2 * i + 1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>     <span class="comment">#right = 2 * i + 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]:   <span class="comment">#小顶堆：if l &lt; n and arr[i] &gt; arr[l]</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:  <span class="comment">#小顶堆：if l &lt; n and arr[i] &gt; arr[l]</span></span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]  <span class="comment">#change</span></span><br><span class="line">        </span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#bulid a maxheap</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#一个个交换元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment">#change</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">heapSort(arr1)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">output:1,2,3,4,5</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#完善版</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        self.heap = self.bulid_max_heap(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(self, heap, heap_size, root)</span>:</span></span><br><span class="line">        left = <span class="number">2</span> * root + <span class="number">1</span></span><br><span class="line">        right = <span class="number">2</span> * root + <span class="number">2</span></span><br><span class="line">        larger = root</span><br><span class="line">        <span class="comment">#如果小于 list 的长度则进行判断。</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= heap_size <span class="keyword">and</span> heap[larger] &lt; heap[left]:</span><br><span class="line">            larger = left</span><br><span class="line">        <span class="keyword">if</span> right &lt;= heap_size <span class="keyword">and</span> heap[larger] &lt; heap[right]:</span><br><span class="line">            larger = right</span><br><span class="line">        <span class="keyword">if</span> larger != root:</span><br><span class="line">            <span class="comment">#相当于如果交换就与最小的那个交换</span></span><br><span class="line">            heap[larger], heap[root] = heap[root], heap[larger]</span><br><span class="line">            self.max_heapify(heap, heap_size, larger)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulid_max_heap</span> <span class="params">(self, heap)</span>:</span></span><br><span class="line">        heap_size = len(heap) - <span class="number">1</span></span><br><span class="line">        <span class="comment">#即从最后一个非叶子结点进行对排序，一直到根结点，</span></span><br><span class="line">        <span class="comment">#确保每一个子堆都是大根堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range((heap_size - <span class="number">1</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.max_heapify(heap, heap_size,i)</span><br><span class="line">        <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        heap = copy.copy(self.heap)</span><br><span class="line">        <span class="comment">#对大根堆进行排序，即把最大值放到最后,</span></span><br><span class="line">        <span class="comment">#再把最后一个值放到最前，然后进行堆排序，</span></span><br><span class="line">        <span class="comment">#循环，直到 list 从小到大排好序。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            heap[<span class="number">0</span>],heap[i] = heap[i],heap[<span class="number">0</span>]</span><br><span class="line">            self.max_heapify(heap, i - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_insert</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        heap = self.heap</span><br><span class="line">        heap.append(data)</span><br><span class="line"></span><br><span class="line">        heap_size = len(heap) - <span class="number">1</span></span><br><span class="line">        father = (heap_size - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        son = heap_size</span><br><span class="line">        <span class="keyword">while</span> father&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> heap[father] &lt; heap[son]:</span><br><span class="line">                heap[father],heap[son] = heap[son], heap[father]</span><br><span class="line">                son = father</span><br><span class="line">                father = (father <span class="number">-1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> heap</span><br><span class="line">    </span><br><span class="line">a = [<span class="number">30</span>, <span class="number">50</span>, <span class="number">57</span>, <span class="number">77</span>, <span class="number">62</span>, <span class="number">78</span>, <span class="number">94</span>, <span class="number">80</span>, <span class="number">84</span>]</span><br><span class="line">heap = Heap(a)</span><br><span class="line">print(heap.heap)</span><br><span class="line"></span><br><span class="line">heap.heap_insert(<span class="number">100</span>)</span><br><span class="line">heap.heap_insert(<span class="number">1</span>)</span><br><span class="line">print(heap.heap)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(nlogn)
<ul>
<li>初始化建堆过程时间：O(n)</li>
<li>更改堆元素后重建堆时间：O(nlogn)，循环 n -1 次，每次都是从根节点往下循环查找，所以每一次时间是 logn，总时间：logn(n-1) = nlogn - logn ，所以复杂度是 O(nlogn)</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：不稳定</li>
</ul>
<h3 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h3>
<p>Q1：如何把一棵完全二叉树构造成一个大顶堆？</p>
<p>A1：一个很好的方法是遍历二叉树的非叶子节点<strong>自下往上</strong>的构造大顶堆，针对每个非叶子节点，都跟它的左右子节点比较，把最大的值换到这个子树的父节点。</p>
<hr>
<p>Q2：为什么要从非叶子节点开始，而不是从最后一个节点开始？</p>
<p>A2：因为叶子节点下面没有子节点了，就没必要操作了。</p>
<hr>
<p>Q3：为什么要从下往上而不是从上往下遍历非叶子节点？</p>
<p>A3：我们从下面开始遍历调整每个节点成为它左右节点的最大值，那么一直往上的话，最后根节点一定是最大的值；但是如果我们从上往下，上面满足了大顶堆，下面不满足，调整后，上面可能又不满足了，所以从下往上是最好的方案。</p>
<hr>
<p>Q4：海量数据中找出最大的100个数字？</p>
<p>A4：使用高效的排序算法，如快排、堆排。</p>
<hr>
<p>Q5：如果数据量很大，一个机器的内存不足以一次读取那么多数据，就不能使用A4方法。该如何解决？</p>
<p>A5：不使用分布式机器计算，使用一个机器也能找出TopK的经典算法就是使用堆排序了，具体方法是：</p>
<ul>
<li>维护一个大小为 K 的<strong>小顶堆</strong>，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较
<ul>
<li>如果小于堆顶元素，则直接忽略，比较下一个元素；</li>
<li>如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</li>
</ul>
</li>
</ul>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<h3 id="基本思想-5"><a class="markdownIt-Anchor" href="#基本思想-5"></a> 基本思想</h3>
<p> 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<h3 id="步骤-5"><a class="markdownIt-Anchor" href="#步骤-5"></a> 步骤</h3>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#冒泡排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#遍历所有数组元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Last i elements are already in place</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">bubbleSort(arr1)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(n^2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：稳定</li>
</ul>
<h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
<h3 id="基本思想-6"><a class="markdownIt-Anchor" href="#基本思想-6"></a> 基本思想</h3>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<h3 id="步骤-6"><a class="markdownIt-Anchor" href="#步骤-6"></a> 步骤</h3>
<ol>
<li>挑选基准值：从数列中挑出一个元素，称为&quot;基准&quot;（pivot）;</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ol>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快速排序-递归</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">    i = low - <span class="number">1</span>     <span class="comment">#最小元素索引</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#当前元素小于或等于pivot</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            </span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arr[] --&gt; 排序数组</span></span><br><span class="line"><span class="comment"># low --&gt; 起始索引</span></span><br><span class="line"><span class="comment"># high --&gt; 结束索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        </span><br><span class="line">        pi = partition(arr, low, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>)</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">quickSort(arr1, <span class="number">0</span>, len(arr1) - <span class="number">1</span>)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<ul>
<li>任何递归的本质，实际上就是入栈出栈的过程。也就是说只要是递归的，都可以改成非递归，因此快排也可以通过栈来实现。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快速排序-非递归</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">    i = low - <span class="number">1</span>     <span class="comment">#最小元素索引</span></span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#当前元素小于或等于pivot</span></span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            </span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arr[] --&gt; 排序数组</span></span><br><span class="line"><span class="comment"># low --&gt; 起始索引</span></span><br><span class="line"><span class="comment"># high --&gt; 结束索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    stack = [len(arr) - <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        low = stack.pop()</span><br><span class="line">        high = stack.pop()</span><br><span class="line">        index = partition(arr, low, high)</span><br><span class="line">        <span class="keyword">if</span> low &lt; index - <span class="number">1</span>:</span><br><span class="line">            stack.append(index - <span class="number">1</span>)</span><br><span class="line">            stack.append(low)</span><br><span class="line">        <span class="keyword">if</span> high &gt; index + <span class="number">1</span>:</span><br><span class="line">            stack.append(high)</span><br><span class="line">            stack.append(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">quickSort(arr1, <span class="number">0</span>, len(arr1) - <span class="number">1</span>)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(nlogn)~O(n^2)</li>
<li><strong>空间复杂度</strong>：O(logn)~O(n)</li>
<li><strong>稳定性</strong>：不稳定</li>
</ul>
<p> 快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但<strong>若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序</strong>。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<h3 id="基本思想-7"><a class="markdownIt-Anchor" href="#基本思想-7"></a> 基本思想</h3>
<p> 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<h3 id="步骤-7"><a class="markdownIt-Anchor" href="#步骤-7"></a> 步骤</h3>
<ul>
<li>递归-有序数组的合并
<ol>
<li>设<code>arr[i…n]</code>由两个有序子表<code>arr[i…m]</code>和<code>arr[m+1…n]</code>组成，两个子表长度分别为<code>n-i +1</code>、<code>n-m</code>。</li>
<li><code>j=m+1；k=i；i=i;</code> //置两个子表的起始下标及辅助数组的起始下标</li>
<li>若<code>i&gt;m</code> 或<code>j&gt;n</code>，转4 //其中一个子表已合并完，比较选取结束</li>
<li>//选取<code>arr[i]</code>和<code>arr[j]</code>较小的存入辅助数组<code>arrf</code><br>
如果<code>arr[i]&lt;arr[j]，arrf[k]=arr[i]； i++； k++；</code> 转2<br>
否则，<code>arrf[k]=arr[j]； j++； k++</code>； 转2</li>
<li>//将尚未处理完的子表中元素存入arrf<br>
如果<code>i&lt;=m</code>，将<code>arr[i…m]</code>存入<code>arrf[k…n]</code> //前一子表非空<br>
如果<code>j&lt;=n</code> ,  将<code>arr[j…n]</code> 存入<code>arrf[k…n]</code> //后一子表非空</li>
<li>合并结束。</li>
</ol>
</li>
<li>非递归-不需要额外的空间。直接在原数组上进行切割合并</li>
</ul>
<h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归并排序-递归（按步骤描述的代码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, l, m, r)</span>:</span></span><br><span class="line">    n1 = m - l + <span class="number">1</span></span><br><span class="line">    n2 = r - m</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * n1</span><br><span class="line">    R = [<span class="number">0</span>] * n2</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#拷贝数据到临时数组 arrays L[] 和 R[]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</span><br><span class="line">        L[i] = arr[l + i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n2):</span><br><span class="line">        R[j] = arr[m + <span class="number">1</span> + j]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#归并临时数组到arr[l..r]</span></span><br><span class="line">    i = <span class="number">0</span>   <span class="comment">#初始化第一个子数组的索引</span></span><br><span class="line">    j = <span class="number">0</span>   <span class="comment">#初始化第二个子数组的索引</span></span><br><span class="line">    k = l   <span class="comment">#初始归并子数组的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">            arr[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = R[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 L[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1: </span><br><span class="line">        arr[k] = L[i] </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 R[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; n2: </span><br><span class="line">        arr[k] = R[j] </span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr,l,r)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> l &lt; r: </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        m = int((l+(r<span class="number">-1</span>))/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">mergeSort(arr1, <span class="number">0</span>, len(arr1) - <span class="number">1</span>)</span><br><span class="line">print(arr1)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#归并排序-简化版递归！！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    l = r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = len(arr)//<span class="number">2</span></span><br><span class="line">    left = mergeSort(arr[:mid])</span><br><span class="line">    right = mergeSort(arr[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">print(mergeSort(arr))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#非递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, l, m, r)</span>:</span></span><br><span class="line">    left = arr[l: m]    <span class="comment">#切割数组</span></span><br><span class="line">    right = arr[m: r]</span><br><span class="line">    l = <span class="number">0</span> <span class="comment">#指向左边数组的索引 </span></span><br><span class="line">    r = <span class="number">0</span> <span class="comment">#指向右边数组的索引</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    arr[l: r] = result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    i = <span class="number">1</span> <span class="comment"># 初始时子数组元素个数是1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(arr):</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; len(arr):</span><br><span class="line">            mid = low + i <span class="comment">#mid前后均为有序</span></span><br><span class="line">            right = min(low + <span class="number">2</span> * i, len(arr))</span><br><span class="line">            <span class="keyword">if</span> mid &lt; right: </span><br><span class="line">                merge(arr, low, mid, right)</span><br><span class="line">            low += <span class="number">2</span> * i</span><br><span class="line">        i *= <span class="number">2</span>  <span class="comment">#每次合并两个，子数组元素个数是以2的倍数增长</span></span><br><span class="line">        </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">mergeSort(arr)</span><br><span class="line">print(mergeSort(arr))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：O(nlogn)</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>稳定性</strong>：稳定</li>
</ul>
<h2 id="计数排序桶排序基数排序了解"><a class="markdownIt-Anchor" href="#计数排序桶排序基数排序了解"></a> 计数排序&amp;桶排序&amp;基数排序（了解）</h2>
<p> 计数排序，基数排序，桶排序等<strong>非比较排序算法</strong>，<strong>平均时间复杂度都是O(n)</strong>。这些排序因为其待排序元素本身就<strong>含有了定位特征</strong>，因而不需要比较就可以确定其前后位置，从而可以突破比较排序算法时间复杂度O(nlgn)的理论下限。</p>
<h3 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h3>
<h4 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h4>
<p>计数排序是一种非基于元素比较的排序算法，而是将待排序数组元素转化为计数数组的索引值，从而间接使待排序数组具有顺序性。</p>
<p>计数排序的实现一般有两种形式：基于辅助数组和基于桶排序。</p>
<ul>
<li>基于辅助数组
<ul>
<li>整个过程包含三个数组：待排序数组A、计数数组B和输出数组C。</li>
<li>简单来说，就是通过统计待排序数组A中元素不同值的分布直方图，生成计数数组B，然后计算计数数组B的前缀和(此步操作可以看成计算待排序数组A中每个元素的位置信息)，最后通过逆序循环将元素对应赋值到输出数组C中，输出数组C即是最终排序结果。</li>
</ul>
</li>
<li>基于桶排序
<ul>
<li>其实就是用桶排序来维护稳定性，因为在每个桶中的元素是以队列结构排序的，可以维护元素的顺序。</li>
<li>主要步骤：
<ol>
<li>按元素的最大健值与最小健值之差来创建指定数量的桶，并在每个桶中创建一个队列。</li>
<li>按顺序遍历待排序数组，将它们放到对应桶的队列中。</li>
<li>按桶编号顺序进行遍历，将每个桶中队列按顺序输出回原数组中。</li>
</ol>
</li>
<li>举例：
<ul>
<li>nums=[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值。 maxValue = 5 , minValue = 1 ，于是开一个长度maxValue - minValue + 1长度的计数器数组 counter 。
<ol>
<li>分配：扫描一遍原始数组，以当前值 - minValue 作为下标，将该下标的计数器增1。即统计每个元素出现的频率，得到 counter = [2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0 + minValue = 1 出现了2次。</li>
<li>收集：扫描一遍计数器数组，按顺序把值收集起来。即counter[0] = 2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1] = 1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。</li>
<li><strong>缺点</strong>：可以看到辅助数组的长度和桶的数量由最大值和最小值决定，假如两者之差很大，而待排序数组又很小，那么就会导致辅助数组或桶大量浪费。</li>
<li><strong>应用</strong>：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，<strong>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</strong>。当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n+k)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定输入是个数组A【1...n】， length【A】&#x3D;n。 另外还需要一个存放排序结果的数组B【1...n】，以及提供临时存储区的C【0...k】(k是所有元素中最大的一个)。算法伪代码：</span><br><span class="line"></span><br><span class="line">COUNTING-SORT(A, B, n, k)</span><br><span class="line">for i &lt;- 0 to k</span><br><span class="line">	do C[i] &lt;- 0</span><br><span class="line">for j &lt;- 1 to n</span><br><span class="line">	do C[A[j]] &lt;- C[A[j]] + 1</span><br><span class="line">for i &lt;- 1 to k</span><br><span class="line">	do C[i] &lt;- C[i] + C[i - 1]</span><br><span class="line">for j &lt;- n downto 1</span><br><span class="line">	do B[C[A[j]]] &lt;- A[j]</span><br><span class="line">		 C[A[j]] &lt;- C[A[j]] - 1</span><br><span class="line">		 </span><br><span class="line">1、找出待排序的数组中最大和最小的元素</span><br><span class="line">2、统计数组中每个值为t的元素出现的次数，存入数组C的第t项</span><br><span class="line">3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</span><br><span class="line">4、反向填充目标数组：将每个元素t放在新数组的第C(t)项，每放一个元素就将C(t)减去1</span><br></pre></td></tr></table></figure>
<h4 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSort</span><span class="params">(arr)</span>:</span> </span><br><span class="line">  </span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)] </span><br><span class="line">  </span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)] </span><br><span class="line">  </span><br><span class="line">    ans = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> arr] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr: </span><br><span class="line">        count[ord(i)] += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>): </span><br><span class="line">        count[i] += count[i<span class="number">-1</span>] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)): </span><br><span class="line">        output[count[ord(arr[i])]<span class="number">-1</span>] = arr[i] </span><br><span class="line">        count[ord(arr[i])] -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)): </span><br><span class="line">        ans[i] = output[i] </span><br><span class="line">    <span class="keyword">return</span> ans  </span><br><span class="line">  </span><br><span class="line">arr = <span class="string">"wwwrunoobcom"</span></span><br><span class="line">ans = countSort(arr) </span><br><span class="line"><span class="keyword">print</span> ( <span class="string">"字符数组排序 %s"</span>  %(<span class="string">""</span>.join(ans)) )</span><br></pre></td></tr></table></figure>
<ul>
<li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
</ul>
<h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h3>
<h4 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h4>
<ul>
<li>基数排序改善了计数排序，简单来说，<strong>基数排序算法就是将整数或字符串切分成不同的数字或字符，然后按对应位置的数或字符分别进行比较，这样就能将辅助数组或桶的数量降低到一个较小的值，经过多轮排序后得到最终的排序结果</strong>。</li>
<li>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</li>
</ul>
<h4 id="两种多关键码排序方法"><a class="markdownIt-Anchor" href="#两种多关键码排序方法"></a> 两种多关键码排序方法</h4>
<ul>
<li>实例：扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：
<ul>
<li>花色：梅花&lt;方块&lt;红心&lt;黑心</li>
<li>面值：2&lt;3&lt;4&lt;5&lt;6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</li>
</ul>
</li>
</ul>
<p> 若对扑克牌按花色、面值进行升序排序，得到如下序列：梅花2&lt;梅花3&lt;…&lt;梅花A&lt;方块2&lt;方块3&lt;…&lt;方块A&lt;红心2&lt;红心3&lt;…&lt;红心A&lt;黑心2&lt;黑心3&lt;…&lt;黑心A。</p>
<p> 即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>
<ul>
<li>
<p>为得到排序结果，我们讨论两种排序方法:</p>
<ul>
<li>
<p>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。</p>
</li>
<li>
<p>方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。</p>
</li>
<li>
<p>设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r<a href="1%E2%89%A4i%E2%89%A4j%E2%89%A4n">j</a>都满足下列有序关系：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msubsup><mi>k</mi><mi>i</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>i</mi><mn>2</mn></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi>k</mi><mi>i</mi><mi>d</mi></msubsup><mo stretchy="false">)</mo><mo>&lt;</mo><mo stretchy="false">(</mo><msubsup><mi>k</mi><mi>j</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>2</mn></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mi>d</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k^1_i,k^2_i,...,k^d_i) &lt; (k^1_j,k^2_j,...,k^d_j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.282216em;vertical-align:-0.383108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<p>其中，其中k1 称为最主位关键码，kd 称为最次位关键码 。</p>
<ul>
<li>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：
<ul>
<li>最高位优先(Most Significant Digit first)法，简称MSD 法：
<ol>
<li>先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。</li>
<li>再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。</li>
<li>再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</li>
</ol>
</li>
<li>最低位优先(Least Significant Digit first)法，简称LSD 法：
<ol>
<li>先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</li>
<li>最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</li>
</ol>
</li>
</ul>
</li>
<li>由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。</li>
</ul>
<h4 id="基于lsd方法的链式基数排序的基本思想"><a class="markdownIt-Anchor" href="#基于lsd方法的链式基数排序的基本思想"></a> 基于LSD方法的链式基数排序的基本思想</h4>
<p> “多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。</p>
<p> 基数排序的简单描述就是将数字拆分为个位十位百位，每个位依次排序。因为这对算法稳定要求高，所以我们对数位排序用到上一个排序方法计数排序。因为基数排序要经过d (数据长度)次排序， 每次使用计数排序， 计数排序的复杂度为 On), d 相当于常量和N无关，所以<strong>基数排序也是 O(n)。<strong>基数排序虽然是线性复杂度， 即对n个数字处理了n次，但是每一次代价都比较高， 而且</strong>使用计数排序的基数排序不能进行原地排序，需要更多的内存</strong>， 并且快速排序可能更好地利用硬件的缓存， 所以比较起来，像快速排序这些原地排序算法更可取**。对于一个位数有限的十进制数，我们可以把它看作一个多元组，从高位到低位关键字重要程度依次递减。可以使用基数排序对一些位数有限的十进制数排序。**</p>
<h4 id="步骤-8"><a class="markdownIt-Anchor" href="#步骤-8"></a> 步骤</h4>
<ol>
<li>将所有待排序整数（注意，必须是非负整数）统一为位数相同的整数，位数较少的前面补零。一般用10进制，也可以用16进制甚至2进制。所以前提是能够找到最大值，得到最长的位数，设 k 进制下最长为位数为 d 。</li>
<li>从最低位开始，依次进行一次稳定排序。这样从最低位一直到最高位排序完成以后，整个序列就变成了一个有序序列。<br>
举个例子，有一个整数序列，0, 123, 45, 386, 106，下面是排序过程：</li>
</ol>
<ul>
<li>第一次排序，个位，000 123 045 386 106，无任何变化</li>
<li>第二次排序，十位，000 106 123 045 386</li>
<li>第三次排序，百位，000 045 106 123 386</li>
<li>最终结果，0, 45, 106, 123, 386, 排序完成。</li>
</ul>
<h4 id="qa-2"><a class="markdownIt-Anchor" href="#qa-2"></a> Q&amp;A</h4>
<p> 为什么同一数位的排序子程序要用稳定排序？因为稳定排序能将上一次排序的成果保留下来。例如十位数的排序过程能保留个位数的排序成果，百位数的排序过程能保留十位数的排序成果。能不能用2进制？能，可以把待排序序列中的每个整数都看成是01组成的二进制数值。那这样的话，岂不是任意一个非负整数序列都可以用基数排序算法？理论上是的，假设待排序序列中最大整数为2 4 . 1，则最大位数 d=64 ，时间复杂度为 O(64n) 。可见任意一个非负整数序列都可以在线性时间内完成排序。</p>
<p> 既然任意一个非负整数序列都可以在线性时间内完成排序，那么基于比较排序的算法有什么意义呢？基于比较的排序算法，时间复杂度是 O(nlogn) ，看起来比 O(64n) 慢，仔细一想，其实不是， O(nlogn) 只有当序列非常长，达到2 个元素的时候，才会与 O(64n) 相等，因此，64这个常数系数太大了，大部分时候， n 远远小于2 ，基于比较的排序算法还是比 O(64n) 快的。<br>
当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd) 会变大，空间复杂度 O(n+k) 会变小。当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，但是空间复杂度 O(n+k) 会急剧增大，此时基数排序退化成了计数排序。</p>
<h4 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j/(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h3>
<h4 id="介绍-3"><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h4>
<p> 桶排序是改善计数排序的方法之一，其基本思想<strong>是将待排序数组分配到若干个桶内，然后每个桶内再各自进行排序，桶内的排序可以使用不同的算法，比如插入排序或快速排序，属于分治法。每个桶执行完排序后，最后依次将每个桶内的有序序列拿出来，即得到完整的排序结果。</strong></p>
<h4 id="步骤-9"><a class="markdownIt-Anchor" href="#步骤-9"></a> 步骤</h4>
<ol>
<li>将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] <strong>均匀</strong>划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li>
<li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li>
<li>将各个桶中的元素合并成一个大的有序序列。</li>
<li>假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(m)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk) 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li>
</ol>
<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p>
<h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4>
<ol>
<li>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</li>
<li>其次待排序的元素都要在一定的范围内等等。桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。（<strong>分配排序的基本思想：说白了就是进行多次的桶式排序，基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)</strong>）</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h3 id="前7种算法的各种指标对比"><a class="markdownIt-Anchor" href="#前7种算法的各种指标对比"></a> 前7种算法的各种指标对比</h3>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td>稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h3 id="后3种算法的各种指标对比"><a class="markdownIt-Anchor" href="#后3种算法的各种指标对比"></a> 后3种算法的各种指标对比</h3>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适用场景</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>计数排序</td>
<td>O(n + maxV- minV)</td>
<td>O(maxV-minV)</td>
<td>maxV和minV差距尽可能小</td>
<td>稳定排序</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(nd)</td>
<td>O(n + k)</td>
<td>1.非负整数；2.maxV和minV差距尽可能小</td>
<td>稳定排序</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>元素尽可能均匀分布</td>
<td>稳定排序</td>
</tr>
</tbody>
</table>
<p>其中，d表示位数，k在基数排序中表示k进制，在桶排序中表示桶的个数，maxV和minV表示元素的最大值和最小值。</p>
<h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3>
<ul>
<li><strong>当原表有序或基本有序时</strong>，<strong>直接插入排序和冒泡排序</strong>将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li>
<li><strong>当原表基本有序时，快速排序将蜕化为冒泡排序</strong>，时间复杂度提高为O（n^2）；</li>
<li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li>
<li><strong>稳定排序的好处</strong>：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</li>
<li>首先，基数排序和计数排序都可以看作是桶排序。</li>
<li>计数排序本质上是一种特殊的桶排序，当桶的个数取最大( maxV-minV+1 )的时候，就变成了计数排序。</li>
<li>基数排序也是一种桶排序。桶排序是按值区间划分桶，基数排序是按数位来划分；基数排序可以看做是多轮桶排序，每个数位上都进行一轮桶排序。</li>
<li>当用最大值作为基数时，基数排序就退化成了计数排序。</li>
<li>当使用2进制时， k=2 最小，位数 d 最大，时间复杂度 O(nd) 会变大，空间复杂度 O(n+k) 会变小。当用最大值作为基数时， k=maxV 最大， d=1 最小，此时时间复杂度 O(nd) 变小，但是空间复杂度 O(n+k) 会急剧增大，此时基数排序退化成了计数排序。</li>
</ul>
<h3 id="如何选择排序算法"><a class="markdownIt-Anchor" href="#如何选择排序算法"></a> 如何选择排序算法？</h3>
<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>
<p>1．待排序的记录数目n的大小；</p>
<p>2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
<p>3．关键字的结构及其分布情况；</p>
<p>4．对排序稳定性的要求。</p>
<ul>
<li><strong>设待排序元素的个数为n</strong>
<ul>
<li><strong>当n较大</strong>，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。
<ul>
<li>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</li>
<li>堆排序 ： 如果内存空间允许且要求稳定性</li>
<li>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</li>
</ul>
</li>
<li><strong>当n较大</strong>，内存空间允许，且要求稳定性 =》归并排序</li>
<li><strong>当n较小</strong>，可采用直接插入或直接选择排序。
<ul>
<li>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</li>
<li>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</li>
</ul>
</li>
<li>一般不使用或不直接使用传统的冒泡排序。</li>
<li>基数排序
<ul>
<li>它是一种稳定的排序算法，但有一定的局限性：
<ul>
<li>关键字可分解。</li>
<li>记录的关键字位数较少，如果密集更好</li>
<li>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-双指针</title>
    <url>/2020/06/24/leetcode-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> leetcode中可以用“双指针”法解决的经典题目。</p>
<ul>
<li>167-两数之和II-输入有序数组</li>
<li>633-平方数之和</li>
<li>345-反转字符串中的元音字母</li>
<li>680-验证回文字符串II</li>
<li>88-合并两个有序数组</li>
<li>141-环形链表</li>
<li>524-通过删除字母匹配到字典里最长单词</li>
</ul>
<h1 id="167-两数之和ii-输入有序数组"><a class="markdownIt-Anchor" href="#167-两数之和ii-输入有序数组"></a> 167-两数之和II-输入有序数组</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个已按照<strong>升序排列</strong>的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li><strong>注意</strong>：题目是升序排列数组。</li>
<li><strong>思路</strong>：使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(N)，数组最多遍历一遍。</li>
<li><strong>空间复杂度</strong>：O(1)，使用额外两个指针。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> numbers[i] + numbers[j] == target:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[i] + numbers[j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h1 id="633-平方数之和"><a class="markdownIt-Anchor" href="#633-平方数之和"></a> 633-平方数之和</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a^2+b^2=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 &#x3D; 5</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li><strong>思路</strong>：可以看成是在元素为 <strong>0~target</strong> 的<strong>有序数组</strong>中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</li>
<li><strong>注意</strong>：本题和 167题类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用<strong>双指针</strong>得到两个数，使其平方和为 target。</li>
<li><strong>关键</strong>：右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">0^2 + x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的值尽可能接近target，我们可以将 x 取为 sqrt(target)。</li>
<li><strong>时间复杂度</strong>：O(sqrt(target))，最多遍历一遍0~sqrt(target)。</li>
<li><strong>空间复杂度</strong>：O(1)，额外使用两个指针。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = int(c ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> i ** <span class="number">2</span> + j ** <span class="number">2</span> == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> i ** <span class="number">2</span> + j ** <span class="number">2</span> &lt; c:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="345-反转字符串中的元音字母"><a class="markdownIt-Anchor" href="#345-反转字符串中的元音字母"></a> 345-反转字符串中的元音字母</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br><span class="line"></span><br><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：元音字母不包含字母&quot;y&quot;。</p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>
<p><strong>思路</strong>：使用双指针，<strong>一个指针从头向尾遍历，一个指针从尾到头遍历</strong>，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>
<p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p>
</li>
<li>
<p><strong>时间复杂度</strong>：O(N)，最多遍历一遍字符串</p>
</li>
<li>
<p><strong>空间复杂度</strong>：O(1)，额外使用两个指针</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s :</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        vowels = [<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(s) - <span class="number">1</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>
<h1 id="680-验证回文字符串ii"><a class="markdownIt-Anchor" href="#680-验证回文字符串ii"></a> 680-验证回文字符串II※</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：字符串只包含从 a-z 的<strong>小写字母</strong>。字符串的最大长度是50000。</p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li><strong>回文串概念</strong>：指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</li>
<li><strong>思路</strong>：使用双指针，令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</li>
<li><strong>关键</strong>：
<ul>
<li>处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</li>
<li>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</li>
<li>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(N)，其中 n是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是 O(n)，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是 O(n)。</li>
<li>空间复杂度：O(1)，额外使用常量空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment">#题目要求非空，因此定义空串是非回文串</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> s[low] == s[high]:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.checkPalindrome(low + <span class="number">1</span> , high, s) <span class="keyword">or</span> self.checkPalindrome(low, high - <span class="number">1</span>, s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPalindrome</span><span class="params">(self, low, high, s)</span>:</span></span><br><span class="line">        i = low    <span class="comment">#指向字符串第一个字符</span></span><br><span class="line">        j = high   <span class="comment">#指向字符串最后一个字符</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="88-合并两个有序数组"><a class="markdownIt-Anchor" href="#88-合并两个有序数组"></a> 88-合并两个有序数组</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给你两个<strong>有序整数数组</strong> <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中*，*使 <em>nums1</em> 成为一个有序数组。</p>
</li>
<li>
<p>说明：</p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li><strong>思路</strong>：使用双指针，一个指向nums1的最后一个数字，另一个指向nums2的最后一个数字，<strong>需要从尾开始遍历</strong>，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</li>
<li><strong>时间复杂度</strong>：O(n + m)，最多需要遍历一遍nums1和nums2。</li>
<li><strong>空间复杂度</strong>：O(1)，额外使用两个指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n1 = m - <span class="number">1</span>      <span class="comment">#nums1最后一个数字</span></span><br><span class="line">        n2 = n - <span class="number">1</span>      <span class="comment">#nums2最后一个数字</span></span><br><span class="line">        n0 = n + m - <span class="number">1</span>  <span class="comment">#nums1最后一个位置的下标</span></span><br><span class="line">        <span class="keyword">while</span> n1 &gt;= <span class="number">0</span> <span class="keyword">and</span> n2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums2[n2] &gt; nums1[n1]:</span><br><span class="line">                nums1[n0] = nums2[n2]</span><br><span class="line">                n2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[n0] = nums1[n1]</span><br><span class="line">                n1 -= <span class="number">1</span></span><br><span class="line">            n0 -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#将nums2剩余的数字合并到nums1中</span></span><br><span class="line">        nums1[ : n2 + <span class="number">1</span>] = nums2[ : n2 + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> 141-环形链表</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进阶：你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li><strong>思路</strong>：使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</li>
<li><strong>时间复杂度</strong>：O(N)，让我们将 n 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。
<ul>
<li>链表中没有环：快指针将会首先到达尾部，其时间取决于列表的长度，也就是 O(n)。</li>
<li>链表中有环：
<ul>
<li>我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分：
<ul>
<li>慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">迭</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mo>=</mo><mi mathvariant="normal">非</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">迭代次数=非环部分长度=N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">迭</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li>
<li>两个指针都在环形区域中：考虑两个在环形赛道上的运动员，快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为 1，因此需要经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi></mrow><mrow><mi mathvariant="normal">速</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">差</mi><mi mathvariant="normal">值</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{二者之间距离}{速度差值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.739em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.394em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">速</span><span class="mord cjk_fallback mtight">度</span><span class="mord cjk_fallback mtight">差</span><span class="mord cjk_fallback mtight">值</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">二</span><span class="mord cjk_fallback mtight">者</span><span class="mord cjk_fallback mtight">之</span><span class="mord cjk_fallback mtight">间</span><span class="mord cjk_fallback mtight">距</span><span class="mord cjk_fallback mtight">离</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 次循环后，快跑者可以追上慢跑者。这个距离几乎就是&quot;环形部分长度 K&quot; 且速度差值为 1，我们得出这样的结论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">迭</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mo>=</mo><mi mathvariant="normal">近</mi><mi mathvariant="normal">似</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">环</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">部</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">迭代次数=近似于环形部分长度K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">迭</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">近</span><span class="mord cjk_fallback">似</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span></li>
</ul>
</li>
<li>因此，在最糟糕的情况下，时间复杂度是：O(N+K)，也就是O(N)</li>
</ul>
</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(1)，额外使用两个指针</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="524-通过删除字母匹配到字典里最长单词"><a class="markdownIt-Anchor" href="#524-通过删除字母匹配到字典里最长单词"></a> 524-通过删除字母匹配到字典里最长单词※</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回<strong>长度最长且字典顺序最小的字符串</strong>。如果答案不存在，则返回空字符串。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line">输出: </span><br><span class="line">&quot;apple&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出: </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有输入的字符串只包含小写字母。</li>
<li>字典的大小不会超过 1000。</li>
<li>所有输入的字符串长度不会超过 1000。</li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li><strong>字典序</strong>：字母序，表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意字符串的大小关系。</li>
<li><strong>思路</strong>：通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</li>
<li><strong>时间复杂度</strong>：O(n * x)，这里n是列表d中字符串的数目，x是字符串平均长度。</li>
<li><strong>空间复杂度</strong>：O(x)，使用了变量ans。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span><span class="params">(self, s, d)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type d: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        n = len(d)</span><br><span class="line">        m = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            j = k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> k &lt; len(d[i]):</span><br><span class="line">                <span class="keyword">if</span> s[j]==d[i][k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k==len(d[i]):</span><br><span class="line">                <span class="keyword">if</span> (len(d[i]) &gt; len(ans)) <span class="keyword">or</span> (len(d[i])==len(ans) <span class="keyword">and</span> d[i] &lt; ans):</span><br><span class="line">                    ans = d[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>百面机器学习-特征工程</title>
    <url>/2020/06/21/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="特征工程"><a class="markdownIt-Anchor" href="#特征工程"></a> 特征工程</h1>
<h2 id="特征归一化"><a class="markdownIt-Anchor" href="#特征归一化"></a> 特征归一化</h2>
<h3 id="为什么需要对数值类型的特征做归一化"><a class="markdownIt-Anchor" href="#为什么需要对数值类型的特征做归一化"></a> 为什么需要对数值类型的特征做归一化？</h3>
<ul>
<li>对数值类型的特征做归一化可以将所有的特征都统一到一个大致相同的数值区间内，使得不同的指标之间具有可比性。</li>
<li>假设有两种数值型特征x1和x2。将x1和x2归一化后，两者的更新速度变得更为一致，<strong>容易更快地通过梯度下降找到最优解</strong>。</li>
</ul>
<h3 id="特征归一化最常用的两种方法"><a class="markdownIt-Anchor" href="#特征归一化最常用的两种方法"></a> 特征归一化最常用的两种方法？</h3>
<ul>
<li><strong>线性函数归一化</strong>（Min-Max Scaling）。它对原始数据进行线性变换，使结果映射到[0,1]的范围，实现对原始数据的等比缩放。归一化公式如下：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><msub><mi>X</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>X</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">X_{norm} = \frac{X-X_{min}}{X_{max} - X_{min}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
<p>其中X为原始数据，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">X_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为数据的最大值和最小值。</p>
<ul>
<li><strong>零均值归一化</strong>（Z-Score Normalization)：它会将原始数据映射到均值为0、标准差为1的分布上。具体来说，假设原始特征的均值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">μ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>、标准差为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>，那么归一化公式定义为：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">z = \frac{x - μ}{σ}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9463300000000001em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">μ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
<h3 id="归一化应用场景"><a class="markdownIt-Anchor" href="#归一化应用场景"></a> 归一化应用场景？</h3>
<ul>
<li>在实际应用中，<strong>通过梯度下降法求解的模型通常是需要归一化的</strong>。
<ul>
<li>如，线性回归、逻辑回归、支持向量机、神经网络等模型</li>
</ul>
</li>
</ul>
<h3 id="归一化不适合的应用场景"><a class="markdownIt-Anchor" href="#归一化不适合的应用场景"></a> 归一化不适合的应用场景</h3>
<ul>
<li><strong>决策树模型</strong></li>
<li>原因：以C4.5为例，决策树在进行节点分裂时主要依据数据集D关于特征x的信息增益比，而信息增益比跟特征是否经过归一化是无关的，归一化并不会改变样本在特征x上的信息增益。</li>
</ul>
<h2 id="类别型特征"><a class="markdownIt-Anchor" href="#类别型特征"></a> 类别型特征</h2>
<h3 id="什么是类别型特征"><a class="markdownIt-Anchor" href="#什么是类别型特征"></a> 什么是类别型特征？</h3>
<ul>
<li>类别型特征（Categorical Feature）主要是指性别（男、女）、血型（A、B、AB、O）等只在有限选项内取值的特征。</li>
</ul>
<h3 id="为什么需要对类别型特征做编码"><a class="markdownIt-Anchor" href="#为什么需要对类别型特征做编码"></a> 为什么需要对类别型特征做编码？</h3>
<ul>
<li><strong>类别型特征原始输入通常是字符串形式</strong>，除了决策树等少数模型能直接处理字符串形式的输入，对于逻辑回归、支持向量机等模型来说，类别型特征必须经过处理转换成数值型特征才能正确工作。</li>
</ul>
<h3 id="在对数据进行预处理时应该怎样处理类别型特征"><a class="markdownIt-Anchor" href="#在对数据进行预处理时应该怎样处理类别型特征"></a> 在对数据进行预处理时，应该怎样处理类别型特征？</h3>
<ul>
<li><strong>序号编码</strong>：通常用于处理类别间<strong>具有大小关系</strong>的数据。</li>
<li><strong>独热编码</strong>：通常用于处理类别间<strong>不具有大小关系</strong>的特征。对于类别取值较多的情况下使用独热编码需要注意以下问题：
<ul>
<li>使用稀疏向量来节省空间。</li>
<li>配合特征选择来降低维度。</li>
</ul>
</li>
<li><strong>二进制编码</strong>：主要分为两步，先用序号编码给每个类别赋予一个类别ID，然后将类别ID对应的二进制编码作为结果。
<ul>
<li>二进制编码本质上是利用二进制对ID进行哈希映射，最终得到0/1特征向量，且维数少于独热编码，节省了存储空间。</li>
</ul>
</li>
</ul>
<h3 id="高纬度特征会带来几方面的问题"><a class="markdownIt-Anchor" href="#高纬度特征会带来几方面的问题"></a> 高纬度特征会带来几方面的问题？</h3>
<ul>
<li>一是K近邻算法中，高维空间下<strong>两点之间的距离很难得到有效地衡量</strong>。</li>
<li>二是在逻辑回归模型中，参数的数量会随着维度的增高而增加，<strong>容易引起过拟合问题</strong>。</li>
<li>三是通常只有部分降维是对分类、预测有帮助。</li>
</ul>
<h2 id="高维组合特征的处理"><a class="markdownIt-Anchor" href="#高维组合特征的处理"></a> 高维组合特征的处理</h2>
<h3 id="什么是组合特征如何处理高维组合特征"><a class="markdownIt-Anchor" href="#什么是组合特征如何处理高维组合特征"></a> 什么是组合特征？如何处理高维组合特征？</h3>
<p>答：<strong>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征</strong>。以广告点击预估问题为例，原始数据有语言和类型两种离散特征，表1.2是语言和类型对点击的影响。为了提高拟合能力，语言和类型可以组成二阶特征，表1.3是语言和类型的组合特征对点击的影响。</p>
<center>表1.2 语言和类型对点击的影响</center>
<table>
<thead>
<tr>
<th>是否点击</th>
<th>语言</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>中文</td>
<td>电影</td>
</tr>
<tr>
<td>1</td>
<td>英文</td>
<td>电影</td>
</tr>
<tr>
<td>1</td>
<td>中文</td>
<td>电视剧</td>
</tr>
<tr>
<td>0</td>
<td>英文</td>
<td>电视剧</td>
</tr>
</tbody>
</table>
<center>表1.3 语言和类型的组合特征对点击的影响</center>
<table>
<thead>
<tr>
<th>是否点击</th>
<th>语言=中文，类型=电影</th>
<th>语言=英文，类型=电影</th>
<th>语言=中文，类型=电视剧</th>
<th>语言=英文，类型=电视剧</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>以逻辑回归为例，假设数据的特征向量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X = (x_1,x_2,...,x_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则有，</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><munder><mo>∑</mo><mi>i</mi></munder><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&lt;</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y=sigmoid(\sum_{i}\sum_{j}w_{ij} &lt; x_i,x_j&gt;)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;x_i,x_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的组合特征，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的维度等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>⋅</mo><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_i| \cdot |x_j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x_j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>分别代表第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个特征和第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>特征不同取值的个数。</p>
<p>在表1.3的广告点击预测问题中，w的维度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2*2=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>（语言取值为中文或英文两种、类型取值为电影或电视剧两种）</p>
<p><strong>这种特征组合看起来是没有任何问题的，但当引入ID类型特征时，问题就出现了。</strong></p>
<p>若用户的数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，物品的数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，那么需要学习的参数的规模是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。在互联环境下，用户数量和物品数量都可以达到千万量级，几乎无法学习<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>规模的参数。在这种情况下，<strong>一种行之有效的方法是将用户和物品分别用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>维的低维向量表示</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mo>&lt;</mo><mi>m</mi><mi mathvariant="normal">，</mi><mi>k</mi><mo>&lt;</mo><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k&lt;&lt;m，k&lt;&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>），</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><munder><mo>∑</mo><mi>i</mi></munder><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&lt;</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y=sigmoid(\sum_{i}\sum_{j}w_{ij}&lt;x_i,x_j&gt;)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mi>x</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup><mo>⋅</mo><msubsup><mi>x</mi><mi>j</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">w_{ij}=x&#x27;_i \cdot x&#x27;_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.146664em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">x&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>j</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">x&#x27;_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.146664em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>分别表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>对应的低维向量。</p>
<p>需要学习的参数的规模变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m*k + n*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，这其实等价于<strong>矩阵分解</strong>。（降维方法来减少两个高维特征组合后需要学习的参数）</p>
<h2 id="组合特征"><a class="markdownIt-Anchor" href="#组合特征"></a> 组合特征</h2>
<h3 id="怎样有效地找到组合特征"><a class="markdownIt-Anchor" href="#怎样有效地找到组合特征"></a> 怎样有效地找到组合特征？</h3>
<ul>
<li>一种基于决策树的特征组合寻找方法。根据原始输入特征并且根据原始输入和标签构造决策树。</li>
</ul>
<h3 id="给定原始输入该如何有效地构造决策树呢"><a class="markdownIt-Anchor" href="#给定原始输入该如何有效地构造决策树呢"></a> 给定原始输入该如何有效地构造决策树呢？</h3>
<ul>
<li>可以采用<strong>梯度提升决策树</strong>，该方法的思想是<strong>每次都在之前构建的决策树的残差上构建下一棵决策树</strong>。</li>
</ul>
<h2 id="文本表示模型"><a class="markdownIt-Anchor" href="#文本表示模型"></a> 文本表示模型</h2>
<h3 id="有哪些文本表示模型它们各有什么优缺点"><a class="markdownIt-Anchor" href="#有哪些文本表示模型它们各有什么优缺点"></a> 有哪些文本表示模型？它们各有什么优缺点？</h3>
<h4 id="词袋模型"><a class="markdownIt-Anchor" href="#词袋模型"></a> 词袋模型</h4>
<ul>
<li><strong>词袋模型</strong>：最基础的文本表示模型，它将整段文本以词为单位且分开，然后每篇文章可以表示成一个长向量，向量中的每一维代表一个单词，而该维对应的<strong>权重</strong>则反映了这个词在原文章的重要程度。</li>
</ul>
<h5 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h5>
<ul>
<li><strong>优点</strong>：
<ol>
<li>简单、方便、快捷。</li>
<li>在语料充足的情况下，对于简单的自然语言处理任务效果不错。如文本分类。</li>
</ol>
</li>
<li><strong>缺点</strong>：
<ol>
<li>其准确率往往比较低。凡是出现文本中的词一视同仁，不能体现不同词在一句话中重要性的不同。</li>
<li>无法关注词语之间的顺序关系，这是词袋模型最大的缺点。如”武松打老虎“跟”老虎打武松“在词袋模型中被认为是一样的。</li>
<li>向量维度高，维度高造成了后续相似度或者文本分类的计算量非常大，同时数据稀疏也导致了相似度区分不明显。</li>
</ol>
</li>
</ul>
<p><strong>常用TF-IDF计算权重</strong>，表示为，</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>F</mi><mo>−</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TF-IDF(t,d) = TF(t,d)*IDF(t)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TF(t,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>为单词<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>在文档<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>中出现的频率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IDF(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>是逆文档频率，用来衡量单词<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>对表达语义所起的重要性，表示为，</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mrow><mi mathvariant="normal">文</mi><mi mathvariant="normal">章</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">单</mi><mi mathvariant="normal">词</mi><mi>t</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">章</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">IDF(t) = log\frac{文章总数}{包含单词t的文章总数+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.46377em;vertical-align:-0.7693300000000001em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">词</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">章</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">章</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>直观的解释是，如果一个单词在非常多的文章里面都出现，那么它可能是一个比较通用的词汇，对于区分某篇文章特殊语义的贡献较小，因此对权重做一定的惩罚。</p>
<h4 id="n-gram模型"><a class="markdownIt-Anchor" href="#n-gram模型"></a> N-gram模型</h4>
<ul>
<li><strong>N-gram模型：<strong>通常可以</strong>将连续出现的n个词（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n≤N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>）组成的词组（N-gram）也作为一个单独的特征放到向量表示中去，构成N-gram模型</strong>。另外，同一个词可能有多种词性变化，却具有相似的含义。在实际应用中，一般会对单词进行<strong>词干抽取</strong>（Word Stemming）处理，即<strong>将不同词性的单词统一成为同一词干的形式</strong>。</li>
</ul>
<h5 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h5>
<ul>
<li><strong>优点</strong>:
<ol>
<li>采用极大似然估计，参数易训练。</li>
<li>完全包含了前 n-1 个词的全部信息。</li>
<li>可解释性强，直观易理解。</li>
</ol>
</li>
<li><strong>缺点</strong>:
<ol>
<li>缺乏长期依赖，只能建模到前 n-1 个词。</li>
<li>随着 n 的增大，参数空间呈指数增长（常见的n值一般为1，2）。</li>
<li>数据稀疏，难免会出现<strong>OOV</strong>问题（使所有的N-gram概率之和为1和使所有的N-gram概率都不为0）。</li>
<li>单纯的基于统计频次，泛化能力差。</li>
</ol>
</li>
</ul>
<h4 id="主题词模型"><a class="markdownIt-Anchor" href="#主题词模型"></a> 主题词模型</h4>
<ul>
<li>
<p><strong>主题词模型</strong>：是一种<strong>特殊的概率图模型</strong>。假设有k个主题，我们就把任意文章表示成一个k维的主题向量，其中向量的每一维代表一个主题，权重代表这篇文章属于这个特定主题的概率。（它可以<strong>从文本库中发现有代表性的主题（得到每个主题上面词的分布），并计算出每篇文章对应着哪些主题</strong>。）</p>
<ul>
<li>
<p>常见的主题模型：<strong>LSA、pLSA、LDA</strong>。</p>
</li>
<li>
<blockquote>
<p>三个模型的各自的应用、理论分析、优缺点参考：</p>
<p><a href="https://blog.csdn.net/puqutogether/article/details/41696295%EF%BC%88LSA%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/puqutogether/article/details/41696295（LSA）</a></p>
<p><a href="https://blog.csdn.net/puqutogether/article/details/41720073%EF%BC%88PLSA" target="_blank" rel="noopener">https://blog.csdn.net/puqutogether/article/details/41720073（PLSA</a>)</p>
<p><a href="https://zhuanlan.zhihu.com/p/32658341%EF%BC%88LDA%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%89" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32658341（LDA线性判别分析）</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="优缺点-3"><a class="markdownIt-Anchor" href="#优缺点-3"></a> 优缺点</h5>
<ul>
<li>
<p><strong>LSA</strong>:</p>
<ul>
<li><strong>优点</strong>：可以把原文本特征空间降维到一个低维语义空间；减轻一词多义和一义多词问题。</li>
<li><strong>缺点</strong>：在SVD分解的时候，特别耗时，而且一般而言一个文本特征矩阵维数都会特别庞大，SVD此时就更加耗时；而且，LSA缺乏严谨的数理统计基础。</li>
</ul>
</li>
<li>
<p><strong>pLSA</strong>：</p>
<ul>
<li><strong>优点</strong>：PLSA可以解决了同义词和多义词的问题，利用了强化的期望最大化算法（EM）来训练隐含类（潜在类）。而且相对了LSA，有了坚实的统计学基础。</li>
<li><strong>缺点</strong>：随着document和term 个数的增加，pLSA模型也线性增加，变得越来越庞大，也就是说PLSA中训练参数的值会随着文档的数目线性递增。还有，PLSA可以生成其所在数据集的的文档的模型，但却不能生成新文档的模型。</li>
</ul>
</li>
<li>
<p><strong>LDA</strong>：</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</li>
<li>LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</li>
<li>LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</li>
<li>LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</li>
<li>LDA可能过度拟合数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="词嵌入模型"><a class="markdownIt-Anchor" href="#词嵌入模型"></a> 词嵌入模型</h4>
<ul>
<li><strong>词嵌入模型</strong>：词嵌入是一类词向量化的模型的统称，核心思想是将每个词都映射成低维空间（通常K=50~300维）上的一个稠密向量（Dense Vector）。</li>
</ul>
<h5 id="优缺点-4"><a class="markdownIt-Anchor" href="#优缺点-4"></a> 优缺点</h5>
<h2 id="word2vec"><a class="markdownIt-Anchor" href="#word2vec"></a> Word2Vec✨</h2>
]]></content>
      <categories>
        <category>百面机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer1</title>
    <url>/2020/06/13/%E5%89%91%E6%8C%87offer1/</url>
    <content><![CDATA[<h1 id="数据流中的中位数"><a class="markdownIt-Anchor" href="#数据流中的中位数"></a> 数据流中的中位数</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题41）：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line"></span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line"></span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line"></span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：最多会对 <code>addNum、findMedia</code>进行 <code>50000</code> 次调用。</p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：优先队列/堆</p>
<ul>
<li><strong>什么是优先队列</strong>？
<ul>
<li>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
</li>
<li>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
</li>
<li>由于删除堆顶元素时的时间复杂度为 O(logN)，因此在优先队列中入队和出队操作的时间复杂度也是 O(logN)。</li>
</ul>
</li>
<li><strong>注意：Python 中没有大顶堆，只能将值取负保存在小顶堆来模拟</strong>。为了方便理解，将堆用优先队列表示。即<strong>Python 中 heapq 模块是小顶堆</strong>。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。</li>
</ul>
</li>
<li>
<p>思路：</p>
<ul>
<li>首先，建立一个小顶堆A和大顶堆B，各保存列表的一半元素，且规定：
<ul>
<li>A保存较大的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
<li>B保存较小的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
</ul>
</li>
<li>然后，中位数可仅根据A，B的堆顶元素计算得到。
<ul>
<li>小顶堆A（存储较大的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>m</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_m,a_{m-1},...,a_3,a_2,a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
<li>大顶堆B（存储较小的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b1,b2,b3,...,b_{n-1},b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">b</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
</ul>
</li>
<li>设共有N = m + n个元素，规定添加元素时保证：
<ul>
<li>m = n + 1 = （N + 1）/ 2 （N为奇数）</li>
<li>m = n = N / 2（N为偶数）</li>
<li>当m≠n，中位数是a1</li>
<li>当m=n，中位数是（a1 + b1）/ 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>设元素总数为 N = m + n ，其中 m和 n分别为 A和 B中的元素个数。</li>
<li><strong><code>addNum(num)</code> 函数</strong>
<ol>
<li>当 m = n（即 N为 偶数）：需向 A添加一个元素。实现方法：将新元素 num插入至 B ，再将 B堆顶元素插入至 A。</li>
<li>当m≠n（即N为奇数）：需向B添加一个元素。实现方法将新元素插入至A，再将A堆顶元素插入至B。
<ul>
<li>假设插入数字 num遇到情况 1. 。由于 num可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B保存较小一半。</li>
</ul>
</li>
</ol>
</li>
<li><strong><code>findMedian()</code> 函数：</strong>
<ul>
<li>当m≠n，（N为奇数）：则中位数是A堆顶的元素</li>
<li>当m=n，（N为偶数）：则中位数是（A堆顶元素 + B堆顶元素） / 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：</p>
<ul>
<li>查找中位数O(1)：获取堆顶元素使用O(1)时间</li>
<li>添加数字O(logN)：堆的插入和弹出操作需要O(logN)时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = [] <span class="comment">#小顶堆，保存较大的一半</span></span><br><span class="line">        self.B = [] <span class="comment">#大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网python写法，GetMedian需要加个参数，否则python版会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.min_heap = [] <span class="comment">#小顶堆，保存较大的一半</span></span><br><span class="line">        self.max_heap = [] <span class="comment">#大顶堆，保存较小的一半</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(self.min_heap) != len(self.max_heap):</span><br><span class="line">            heappush(self.max_heap, -heappushpop(self.min_heap, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.min_heap, -heappushpop(self.max_heap, -num))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, n = None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.min_heap[<span class="number">0</span>] <span class="keyword">if</span> len(self.min_heap) != len(self.max_heap) <span class="keyword">else</span> (self.min_heap[<span class="number">0</span>] - self.max_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="连续子数组的最大和"><a class="markdownIt-Anchor" href="#连续子数组的最大和"></a> 连续子数组的最大和</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题42）：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li><strong>状态定义</strong>：设动态规划列表dp，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
<ul>
<li>为何定义最大和 dp[i]中必须包含元素 nums[i]：保证 dp[i]递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。</li>
</ul>
</li>
<li><strong>转移方程</strong>：若dp[i-1]≤0，说明dp[i -1]对dp[i]产生负贡献，即dp[i-1] + nums[i]还不如nums[i]本身大。
<ul>
<li>当dp[i-1]≤ 0时：执行dp[i] = nums[i]</li>
<li>当dp[i-1]&gt;0时：执行dp[i] = dp[i-1] + nums[i]</li>
</ul>
</li>
<li><strong>初始状态</strong>：dp[0] = nums[0]，即以nums[0]结尾的连续子数组最大和为 nums[0]。</li>
<li><strong>返回值：</strong> 返回 dp 列表中的最大值，代表全局最大值。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_sum = nums[<span class="number">0</span>] <span class="comment">#保存连续子数组最大和</span></span><br><span class="line">        cur_sum = nums[<span class="number">0</span>] <span class="comment">#保存当前连续子数组最大和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; cur_sum + nums[i]:</span><br><span class="line">                cur_sum = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_sum = cur_sum + nums[i]</span><br><span class="line">            max_sum = max(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态规划分析写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="1~n整数中1出现的次数"><a class="markdownIt-Anchor" href="#1~n整数中1出现的次数"></a> 1~n整数中1出现的次数</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题43）：输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">1 ≤ n &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：数字规律  + 递归</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>用一个稍微大一点的数字：21345为例。我们把从1到21345的所有数字分为两段，一段是从1到1345，另一段是从1346到21345。
<ul>
<li>原因：因为把21345的最高位去掉就变成1345，便于采用递归思路。</li>
</ul>
</li>
<li>先看从1346到21345中1出现的次数。1的出现分为两种情况。
<ul>
<li>首先分析1出现在最高位（例子是万位）的情况。从1346到21345的数字中，1出现在10000~19999这10000个数字的万位，一共出现了10000（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)个。
<ul>
<li>值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000个。对于万位是1的数字比如输入12345，1只出现在10000~12345的万位，出现的次数不是10000次，而是2346次，也就是除去最高数字之后剩下的数字再加上1（即2345+1=2346次）</li>
</ul>
</li>
<li>接着分析1出现在除最高位之外的其他四位数中的情况。例子中1346<sub>21345这20000个数字中后4位中1出现的次数是2000次。由于最高位是2，我们可以再把13456</sub>21345分为两段，1346<sub>11345和11346</sub>21345。每一段剩下4位数字中，选择其中其中一位是1，其余三位可以在0~9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2000次。</li>
<li>从1~1345中1的出现次数，可以用递归求得。</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)，循环内的计算操作使用 O(1)时间；循环次数为数字 n的位数，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{10}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_s = str(n) </span><br><span class="line">        high = int(num_s[<span class="number">0</span>])  </span><br><span class="line">        Pow = <span class="number">10</span> ** (len(num_s) - <span class="number">1</span>) </span><br><span class="line">        last = n - high * Pow</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> high == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last) + last + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Pow + high * self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>第一个return</strong>：举例：1234，<code>countDigitOne(pow-1)</code>表示 0-999 出现过多少次 1，<code>countDigitOne(last)</code>指 1000-1234 后三位出现过多少次 1（与 0-234 出现的次数相同），<code>last</code> 表示 1001-1234 最高位的 1 出现了多少次 1，最后一个 1 表示 1000 这个数最高位的 1。</p>
</li>
<li>
<p><strong>第二个return</strong>： 举例：2234 ，<code>high*self.countDigitOne(pow-1)</code>就是指，从 1~999 以及 1001~1999 这两个阶段后三位出现了多少次 1，<code>self.countDigitOne(last)</code>是指从 2000 到 2234 出现了多少次 1（和 0~234 相同，因为首位不为 1），<code>Pow</code> 指是指从 1000~1999 最高位一共出现了 1000 次 1</p>
</li>
</ul>
<h1 id="数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#数字序列中某一位的数字"></a> 数字序列中某一位的数字</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题44）：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= n &lt; 2^31</p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：数字规律 + 迭代+求整/求余</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/zhe-shi-yi-dao-shu-xue-ti-ge-zhao-gui-lu-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/zhe-shi-yi-dao-shu-xue-ti-ge-zhao-gui-lu-by-z1m/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>
<p>规律：</p>
<table>
<thead>
<tr>
<th>123456789</th>
<th>1011…9899</th>
<th>100101…998999</th>
</tr>
</thead>
<tbody>
<tr>
<td>9个数</td>
<td>90个数</td>
<td>900个数</td>
</tr>
<tr>
<td>9*1位</td>
<td>90*2位</td>
<td>900*3位</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对于第 n 位对应的数字，我们令这个数字对应的数为 <code>target</code>，然后分三步进行。</p>
<ol>
<li>首先找到这个数字对应的数是几位数，用 <code>digits</code> 表示；</li>
<li>然后确定这个对应的数的数值 <code>target</code>；</li>
<li>最后确定返回值是 <code>target</code> 中的哪个数字。</li>
</ol>
</li>
<li>
<p>举例：输入365</p>
<ul>
<li>经过第一步计算我们可以得到第365个数字表示的是三位数，<code>digits = 3</code>， <code>n = 365 - 9 - 90*2 = 176</code>。这时n = 176表示目标数字是三位数中的第176个数字。</li>
<li>我们设目标数字所在的数为 number，计算得到 number=100+176/3=158，idx 是目标数字在 number 中的索引，如果 idx = 0，表示目标数字是 number 中的最后一个数字。</li>
<li>根据步骤2，我们可以计算得到 idx = n % digits = 176 % 3 = 2，说明目标数字应该是 number = 158 中的第二个数字，即输出为 5。</li>
</ul>
</li>
<li>
<p>掌握了方法之后可以对代码进行简化，思路与之前一样，这里注意的是 <code>first_num</code> 表示每组数的第一个数。即1位数的组的1，二位数的组的10，三位数的组的100…</p>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(logn)，将数字转为字符串需要O(logn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        digit, start, count = <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span> <span class="comment">#digit是位数+=1、start是起始数字 = start*10、count是数位数量=9*digit*start</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; count: <span class="comment"># 1. 确定n所在数字的位数，循环执行n减去一位数、两位数的数位数量，因此n是从start开始计数的</span></span><br><span class="line">            n -= count</span><br><span class="line">            start *= <span class="number">10</span></span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span> * start * digit  <span class="comment"># 结论：所求数位①在某个digit位数中；②为从数字start开始的第n个数位。</span></span><br><span class="line">        num = start + (n - <span class="number">1</span>) // digit <span class="comment"># 2.确定所求数位所在的数字，结论：所求数位在数字 num中，start为第0个数</span></span><br><span class="line">        <span class="keyword">return</span> int(str(num)[(n - <span class="number">1</span>) % digit]) <span class="comment"># 3.确定所求数位在num的哪一数位，数字的首个数位为第0位，所求数位是 res</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把数组排成最小的数"><a class="markdownIt-Anchor" href="#把数组排成最小的数"></a> 把数组排成最小的数</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题45）：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<code>0 &lt; nums.length &lt;= 100</code></p>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：排序规则</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>根据题目要求，两个数字m和n能拼接成数字mn和nm。如果mn&lt;nm，那么我们应该打印出mn，也就是m应该排在n的前面，我们定义此时m小于n；反之，如果nm&lt;mn，我们定义n小于m。如果mn=nm，m等于n。在下文中符号&quot;&lt;&quot;，&quot;&gt;“和”=&quot;表示常规意义的数值的大小关系，而文字“大于”、“小于”和等于表示我们新定义的大小关系。</li>
<li>接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字mn和nm并比较它们的大小。直接用数值计算不难办到，但需要考虑到一个潜在的问题就是m和n都在int能表达的范围内，但把它们拼起来的数字mn和nm用int表示就有可能溢出了，所以还隐藏大数问题。</li>
<li>一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外，由于把数字m和n拼接起来得到mn和nm，它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>特例判断：当数组为空，返回空字符串</li>
<li>将数组每个元素依次转换为字符串</li>
<li>两两组合，小的放前面，再拼接起来，如5+3&gt;3+5，把3放5前面</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; nums[j] + nums[i]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把数字翻译成字符串"><a class="markdownIt-Anchor" href="#把数字翻译成字符串"></a> 把数字翻译成字符串</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题46）：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：0 &lt;= num &lt; 2^31</p>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li>记数字num第i位数字为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，数字num的位数为n
<ul>
<li>例如，num=12258，n=5，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i]代表以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为结尾的数字的翻译方案数量。</li>
<li><strong>转移方程</strong>：若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>组成的两位数字可以被翻译，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>，否则，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>
<ul>
<li>可被翻译的两位数区间：当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{i-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，组成的两位数是无法被翻译的，（例如：00，01…)，因此区间为[10,25]。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i -1] + dp[i -2]， 10x_{i-1} + x_i∈[10,25]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>99</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]， 10x_{i-1} + x_i ∈[0,10)∪(25,99]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
<li><strong>初始状态</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0] = dp[1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即无数字和第1位数字的翻译方法数均为1</li>
<li><strong>返回值</strong>：dp[n]</li>
</ul>
</li>
<li>
<p>无数字情况 dp[0] = 1 从何而来？</p>
<ul>
<li>当 num第 1, 2 位的组成的数字∈[10,25] 时，显然应有 2种翻译方法，即 dp[2] = dp[1] + dp[0] = 2 ，而显然 dp[1] = 1，因此推出 dp[0] = 1 。</li>
</ul>
</li>
<li>
<p>为方便获取数字的各位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，考虑先将数字 num转化为字符串 s ，通过遍历 s 实现动态规划。</p>
</li>
<li>
<p>通过字符串切片s[i-2:i]获取组合数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">10x_{i-1} + x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.852771em;vertical-align:-0.208331em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，通过对比字符串ASCII码判断字符串对应数字区间</p>
</li>
<li>
<p>空间优化：由于dp[i]只和dp[i-1]有关，因此可使用两个变量 a, b分别记录 dp[i], dp[i - 1]，两变量交替前进即可。此方法可省去 dp列表使用的 O(N)的额外空间。</p>
</li>
<li>
<p>时间复杂度：O(N)， N为字符串 s的长度（即数字 num的位数log(num) ），其决定了循环次数。</p>
</li>
<li>
<p>空间复杂度：O(N)，字符串使用O(N)额外空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            a, b = (a + b <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i - <span class="number">2</span>:i] &lt;= <span class="string">"25"</span> <span class="keyword">else</span> a), a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="礼物的最大价值"><a class="markdownIt-Anchor" href="#礼物的最大价值"></a> 礼物的最大价值</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题47）：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>0 &lt; grid.length &lt;= 200</code></li>
<li><code>0 &lt; grid[0].length &lt;= 200</code></li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<blockquote>
<ul>
<li>参考<strong>动态规划</strong>解析：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<p>时间复杂度：O(MN)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>: grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以上代码逻辑清晰，和转移方程直接对应，但仍可提升效率：当 grid矩阵很大时， i = 0 或 j = 0的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n): <span class="comment"># 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m): <span class="comment"># 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#最长不含重复字符的子字符串"></a> 最长不含重复字符的子字符串</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题48）：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：s.length &lt;= 40000</p>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：滑动窗口 + 双指针</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>题目中要求答案必须是 子串 的长度，意味着子串内的字符在原字符串中一定是连续的。因此我们可以将答案看作原字符串的一个滑动窗口，并维护窗口内不能有重复字符，同时更新窗口的最大值。</li>
<li>我们可以使用哈希表记录每个字符的下一个索引，然后尽量向右移动尾指针来拓展窗口，并更新窗口的最大长度。如果尾指针指向的元素重复，则将头指针直接移动到窗口中重复元素的右侧。</li>
<li>算法步骤：
<ul>
<li><code>tail</code> 指针向末尾方向移动；</li>
<li>如果尾指针指向的元素存在于哈希表中：<code>head</code> 指针跳跃到重复字符的下一位；</li>
<li>更新哈希表和窗口长度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)， 字符的 ASCII 码范围为 0 ~ 127，哈希表 dic 最多使用 O(128) = O(1) 大小的额外空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        head, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> tail <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[tail] <span class="keyword">in</span> dic:</span><br><span class="line">                head = max(dic[s[tail]], head)</span><br><span class="line">            dic[s[tail]] = tail + <span class="number">1</span></span><br><span class="line">            res = max(res, tail - head + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="丑数"><a class="markdownIt-Anchor" href="#丑数"></a> 丑数</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题49）：我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong>1690</li>
</ul>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<p>思路：创建数组保存已经找到的丑数，用空间换时间。丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “丑数 == 某较小丑数 × 某因子” （例如：10=5×2）。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></li>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/%EF%BC%88%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0%E5%8F%82%E8%80%83%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/（思路描述参考）</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>,n):</span><br><span class="line">            n2 = dp[a] * <span class="number">2</span></span><br><span class="line">            n3 = dp[b] * <span class="number">3</span></span><br><span class="line">            n5 = dp[c] * <span class="number">5</span></span><br><span class="line">            dp[i] = min(n2, n3, n5)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#第一个只出现一次的字符"></a> 第一个只出现一次的字符</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题50）：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= s 的长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>哈希表</strong></p>
</li>
<li>
<blockquote>
<p>剑指offer：如果需要判断多个字符是不是在某个字符串里出现过或统计多个字符在某个字符串出现的次数，我们可以考虑基于数组创建一个简单的哈希表。</p>
</blockquote>
</li>
<li>
<p>思路：遍历一遍字符串，统计每个字符出现的次数；再遍历一次字符串，确定每个字符串出现的次数，即可找到第一个只出现一次的字符。</p>
</li>
<li>
<p>时间复杂度：O(2N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题51）：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把数组分隔成子数组，先统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个排序的过程实际上就是<strong>归并排序</strong>。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, start, mid, end)</span>:</span></span><br><span class="line">            i, j, temp = start, mid + <span class="number">1</span>, []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                    temp.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.cnt += mid - i + <span class="number">1</span></span><br><span class="line">                    temp.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                temp.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                nums[start + i] = temp[i]</span><br><span class="line">                    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            mergeSort(nums, start, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">            merge(nums, start, mid,  end)</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br></pre></td></tr></table></figure>
<h1 id="两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#两个链表的第一个公共节点"></a> 两个链表的第一个公共节点</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>难度：简单</li>
<li>题目（leetcode-面试题52）：输入两个链表，找出它们的第一个公共节点。</li>
<li>注意：
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针</p>
</li>
<li>
<p>思路：有四种方法</p>
<ol>
<li>可以暴力求解，分别遍历两个链表，看是否有重合的结点，时间复杂度：O(mn)</li>
<li>利用辅助栈：可以将两个链表放入栈中，比较栈顶元素（链表长度相同）</li>
<li>分别得到两个链表的长度，计算链表差n，然后设置双指针，让长链表先走n步，然后两个链表一起走，看是否有相同的点。</li>
<li>设置双指针指向两个链表头，然后一起走，指针A遍历完一个链A后，指向另一个链B的头，指针B同理，直到两个指针指向的结点相同，即若存在公共节点则返回公共节点，若不存在，两个指针都会指向null节点。
<ul>
<li>假设链表A长度是m，链表B是n，公共部分是b，那么走过m+n+b步之后一定会相遇，返回结果。 如果没有公共部分，b=0， 那么走过m+n都指向None，返回None</li>
</ul>
</li>
</ol>
</li>
<li>
<p>时间复杂度：O(m+n)，m，n分别为两个链表的长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路4</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1 = headA</span><br><span class="line">        l2 = headB</span><br><span class="line">        <span class="keyword">while</span> l1 != l2:</span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> headB</span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="在排序数组中查找数字i"><a class="markdownIt-Anchor" href="#在排序数组中查找数字i"></a> 在排序数组中查找数字I</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题53I）：统计一个数字在排序数组中出现的次数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：二分查找</p>
</li>
<li>
<p>思路：有两种</p>
<ul>
<li>遍历一遍数组，用哈希表记录每个数出现的次数，返回target出现的次数。时间复杂度和空间复杂度都是O(n)</li>
<li>用二分查找确定数组第一个target和最后一个target的位置，计算两个位置的下标之差。时间复杂度：O(logn)，空间复杂度：O(1)</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 搜索右边界 right</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt;= target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        right = i</span><br><span class="line">        <span class="comment"># 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] != target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 搜索左边界 left</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        left = j</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>简化代码：<code>helper()</code> 函数旨在查找数字 tar在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。即<strong>找target的右边界和target-1的右边界。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tar)</span>:</span></span><br><span class="line">            i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= tar: i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> helper(target) - helper(target - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#0~n-1中缺失的数字"></a> 0~n-1中缺失的数字</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题53II）：<strong>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内</strong>。在范围0～n-1内的n个数字中<strong>有且只有一个数字不在该数组中</strong>，请找出这个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：二分法，<strong>排序数组中的搜索问题，首先想到 二分法 解决。</strong></p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>根据题意，数组可以按照以下规则划分为两部分。
<ul>
<li>左子数组：nums[i] = i</li>
<li>右子数组：nums[i] ≠ i</li>
</ul>
</li>
<li>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>初始化左边界，i = 0， 右边界， j = len(nums) - 1，代表闭区间[i,j]。</li>
</ul>
</li>
<li>
<p>循环二分：当i &lt;= j时循环（当闭区间i，j为空时，跳出）</p>
<ul>
<li>计算中点 m = (i + j) // 2，其中 “//” 为向下取整除法；</li>
<li>若 nums[m] = m ，则 “右子数组的首位元素” 一定在闭区间 [m + 1, j]中，因此执行 i = m + 1；</li>
<li>若 nums[m] ≠ m ，则 “左子数组的末位元素” 一定在闭区间 [i, m - 1]中，因此执行 j = m - 1；</li>
<li><strong>返回值：</strong> 跳出时，变量 i和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉搜索树第k大节点"><a class="markdownIt-Anchor" href="#二叉搜索树第k大节点"></a> 二叉搜索树第k大节点</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题54）：给定一棵二叉搜索树，请找出其中第k大的节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 ≤ k ≤ 二叉搜索树元素个数</p>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>二叉搜索树的中序遍历为递增序列</strong>（中序遍历+提前返回）</p>
<ul>
<li><strong>python-self参数含义小结</strong>：<a href="https://blog.csdn.net/houhuipeng/article/details/91948827" target="_blank" rel="noopener">https://blog.csdn.net/houhuipeng/article/details/91948827</a></li>
<li><strong>self后面的不是模块级的变量，是类/实例级的变量，就是在你定义的类里，是可以访问到的。</strong></li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/</a></p>
</blockquote>
</li>
<li>
<p>思路：求 “二叉搜索树第 k大的节点” 可转化为求 “此树的中序遍历倒序的第 k个节点”。</p>
<ul>
<li>为求第 k 个节点，需要实现以下 三项工作 ：
<ol>
<li>递归遍历时计数，统计当前节点的序号；</li>
<li>递归到第 k个节点时，应记录结果 res；</li>
<li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>递归解析</strong>：</p>
<ul>
<li><strong>终止条件：</strong> 当节点 root为空（越过叶节点），则直接返回；</li>
<li><strong>递归右子树：</strong> 即 dfs(root.right)；</li>
<li><strong>三项工作</strong>：
<ol>
<li>提前返回： 若 k = 0 ，代表已找到目标节点，无需继续遍历，因此直接返回；</li>
<li>统计序号： 执行 k = k - 1 （即从 k减至 0 ）；</li>
<li>记录结果： 若 k = 0 ，代表当前节点为第 k大的节点，因此记录 res = root.val ；</li>
</ol>
</li>
<li><strong>递归左子树：</strong> 即 dfs(root.left)；</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.k, self.res = k, <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right)</span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">            inorder(root.left)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树的深度"><a class="markdownIt-Anchor" href="#二叉树的深度"></a> 二叉树的深度</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55I）：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：后序遍历/层序遍历</p>
<ul>
<li>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；
<ul>
<li><strong>常见的 DFS ：</strong> 先序遍历、中序遍历、后序遍历；</li>
<li><strong>常见的 BFS ：</strong> 层序遍历（即按层遍历）。</li>
</ul>
</li>
<li>树的后序遍历/深度优先搜索往往利用<strong>递归或栈</strong>。
<ul>
<li><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</li>
</ul>
</li>
<li>树的层序遍历 / 广度优先搜索往往利用 <strong>队列</strong> 实现。
<ul>
<li><strong>关键点：</strong> 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>思路：<strong>递归-后序遍历</strong></p>
<ul>
<li><strong>终止条件</strong>：当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li><strong>递推工作</strong>：本质上是对树做后序遍历
<ul>
<li>计算结点<code>root</code>的左子树深度，即调用<code>maxDepth(root.left)</code></li>
<li>计算节点 <code>root</code> 的 <strong>右子树的深度</strong> ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回 <strong>此树的深度</strong> ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：<strong>队列-层序遍历</strong></p>
<ul>
<li><strong>特例处理</strong>：当<code>root</code>为空，直接返回深度0</li>
<li><strong>初始化：</strong> 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li><strong>循环遍历：</strong> 当 <code>queue</code> 为空时跳出。
<ul>
<li>初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li>
<li>遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入 <code>tmp</code>；</li>
<li>更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>；</li>
<li>统计层数： 执行 <code>res += 1</code> ，代表层数加 11；</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55II）：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line"> </span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>1 &lt;= 树的结点个数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<ul>
<li>
<p><strong>思路</strong>：</p>
<ul>
<li>先序遍历+判断深度（自顶向下），比较容易想到。
<ul>
<li>构造一个depth函数递归计算二叉树的左右子树高度</li>
<li>比较左右子树高度差是否≤1，判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(NlogN)，最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。</p>
<ul>
<li>满二叉树高度的复杂度 O(log N) ，将满二叉树按层分为 log (N+1) 层；</li>
<li>总体时间复杂度 == 每层执行复杂度× 层数复杂度 = O(N×logN) 。</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>思路</strong>：后序遍历+剪枝（从底至顶）：</p>
<ul>
<li>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</li>
<li>算法流程：
<ul>
<li><strong><code>recur(root)</code> 函数：</strong>
<ul>
<li><strong>返回值</strong>
<ul>
<li>当节点root左/右子树的深度差&lt;=1：则返回当前子树的深度，即节点root的左/右子树的深度最大值 + 1</li>
<li>当节点root左/右子树的深度差＞2：则返回-1，代表此子树不是平衡树</li>
</ul>
</li>
<li><strong>终止条件</strong>
<ul>
<li>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 0</li>
<li>当左（右）子树深度为-1，代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 -1；</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>isBalanced(root)</code> 函数：</strong>
<ul>
<li><strong>返回值：</strong> 若 <code>recur(root) != -1</code> ，则说明此树平衡，返回 true ； 否则返回 false 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = recur(root.left)</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            right = recur(root.right)</span><br><span class="line">            <span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> max(left, right) + <span class="number">1</span> <span class="keyword">if</span> abs(left - right) &lt;= <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> recur(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中数字出现的次数"><a class="markdownIt-Anchor" href="#数组中数字出现的次数"></a> 数组中数字出现的次数</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题56I）：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：2 &lt;= nums.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<blockquote>
<ul>
<li>异或类型题目的总结：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>异或有这样的性质：
<ul>
<li>0<sup>a=a，a</sup>a=0，a<sup>a</sup>a=a</li>
</ul>
</li>
<li>设所求的两个数为x,y，先将所有元素都异或，得到结果r，r其实就是x与y的异或。由于x!=y，r肯定不为0，即在其二进制形式中存在1，我们从右向左找第一个为1的位置（其实只要能找到任意一位为1的位置即可），记录其位置为i。这样通过i便可将数组分为两部分，一部分元素的二进制在i处为0，另一部分为1。x与y必定分散在这两部分中，而且相同的数都会在同一部分。将这两部分分别异或，结果便为x，y。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span>  <span class="comment"># 所有数字异或的结果</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ret ^= n</span><br><span class="line">        <span class="comment"># 找到第一位不是0的</span></span><br><span class="line">        h = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(ret &amp; h == <span class="number">0</span>):</span><br><span class="line">            h &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 根据该位是否为0将其分为两组</span></span><br><span class="line">            <span class="keyword">if</span> (h &amp; n == <span class="number">0</span>):</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中数字出现的次数ii"><a class="markdownIt-Anchor" href="#数组中数字出现的次数ii"></a> 数组中数字出现的次数II</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题56II）：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：位运算 / 字典 / 排序 /数学方法</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/pythonti-jie-san-chong-fang-shi-man-zu-mian-shi-gu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/pythonti-jie-san-chong-fang-shi-man-zu-mian-shi-gu/</a></p>
</blockquote>
</li>
<li>
<p>思路：位运算</p>
<ul>
<li>我们想一下如果一个数字出现三次,那么他的二进制位表示的每一位(0或1)也出现了三次.如果把所有出现三次的数字的二进制表示的每一位都分别加起来,那么每一位的和都能被3整除</li>
<li>我们把所有数字的二进制位的每一位加起来.若果某一位的和能被3整除,那么那个只出现一次的数字二进制表示中对应的那一位为0,否则为1</li>
<li>步骤：
<ul>
<li>统计所有数字二进制位的和</li>
<li>判断每一位的和能否被3整除,求解最后结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        bitSum = [<span class="number">0</span>] *<span class="number">32</span> <span class="comment">#定义存储各个位的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums: <span class="comment">#统计各位之和</span></span><br><span class="line">            mask = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(<span class="number">32</span>)):</span><br><span class="line">                <span class="keyword">if</span> mask &amp; i:</span><br><span class="line">                    bitSum[j] += <span class="number">1</span></span><br><span class="line">                mask = mask &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#得到最终结果</span></span><br><span class="line">            result = result &lt;&lt; <span class="number">1</span></span><br><span class="line">            result += bitSum[i] % <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="和为s的两个数字"><a class="markdownIt-Anchor" href="#和为s的两个数字"></a> 和为s的两个数字</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57I）：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针 / 字典</p>
</li>
<li>
<p>思路：双指针：</p>
<ul>
<li>根据题意，是递增排序数组，可以初始化两个指针，分别指向数组的第一个元素和最后一个元素，即<code>i = 0, j = len(nums) - 1</code></li>
<li>当i &lt; j时，判断nums[i] + nums[j]的和是否等于target，如果等于，则输出这两个数，如果大于，将j前移。如果小于，将i后移。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s = nums[i] + nums[j] </span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> nums[i], nums[j]</span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典，空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = target - num</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> dic[a], num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = num</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="和为s的连续正数序列"><a class="markdownIt-Anchor" href="#和为s的连续正数序列"></a> 和为s的连续正数序列</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57II）：输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= target &lt;= 10^5</p>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<ul>
<li>
<p>思路：双指针滑动窗口法</p>
<ul>
<li>针对目前这个题，我们可以把左指针i指向1，右指针j指向2，然后就能计算出当前窗口范围各数字的和，<code>cur_sum = sum(list(range(i,j+1)))</code>，如果cur_sum小于target，说明当前窗口数字之和过小，这时候咱们可以令j += 1，这样我们的新窗口就向右边扩大了。同样的道理，如果cur_sum大于target，这说明我们当前窗口数字之和过大，这时候就令i += 1，这样窗口的左边界就向右边移动了一个单位，就使得窗口变小了。</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化窗口指针和输出列表</span></span><br><span class="line">        i, j, res = <span class="number">1</span>,<span class="number">2</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滑动窗口的右边界不能超过target的中值</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= target//<span class="number">2</span> + <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 计算当前窗口内数字之和</span></span><br><span class="line">            cur_sum = sum(list(range(i,j+<span class="number">1</span>)))</span><br><span class="line">            <span class="comment"># 若和小于目标，右指针向右移动，扩大窗口</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若和大于目标，左指针向右移动，减小窗口</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 相等就把指针形成的窗口添加进输出列表中</span></span><br><span class="line">            <span class="comment"># 别忘了，这里还要继续扩大寻找下一个可能的窗口哦</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(list(range(i,j+<span class="number">1</span>)))</span><br><span class="line">                <span class="comment"># 这里用j+=1，i+=1，i+=2都可以的</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="翻转单词顺序"><a class="markdownIt-Anchor" href="#翻转单词顺序"></a> 翻转单词顺序</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题58I）：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针滑动窗口确定单词</p>
</li>
<li>
<blockquote>
<p>剑指offer：可以进行两次反转，第一次反转所有字符，第二次依次反转每个单词的字符。</p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>去除字符串首尾空格</li>
<li>初始化两个指针，i，j指向字符串最后一个字符</li>
<li>当i大于等于0时，如果当i&gt;=0且s[i]不是空格，i继续前移，如果遇到空格，说明扫描了一个单词，将这个单词加入res，当遇到空格，i前移，并且让j指向i此刻位置，重新开始扫描下一个单词。</li>
<li>最后将列表转为字符串</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        i = j = len(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span> : j + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            j = i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="左旋转字符串"><a class="markdownIt-Anchor" href="#左旋转字符串"></a> 左旋转字符串</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题58II）：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把字符串分为两部分，由于想把它的前k个字符移到后面，我们就先把前k个字符分隔到第一部分，把后面的所有字符都分到第二部分。然后，分别反转这两个部分，最后反转整个字符串。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：字符串切片、列表遍历拼接、字符串遍历拼接</p>
<ul>
<li>
<p>字符串切片</p>
<ul>
<li>
<p>应用字符串切片函数，可方便实现左旋转字符串。</p>
</li>
<li>
<p>获取字符串 s[n:]切片和 s[:n] 切片，使用 “+” 运算符拼接并返回即可。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>列表遍历拼接</p>
<ul>
<li>
<p>若面试不允许字符串切片，可以使用该方法</p>
</li>
<li>
<p>新建一个 list(Python) ，记为 res ；</p>
</li>
<li>
<p>先向 res 添加 “第 n + 1 位至末位的字符” ；</p>
</li>
<li>
<p>再向 res添加 “首位至第 n 位的字符” ；</p>
</li>
<li>
<p>将 res 转化为字符串并返回。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,len(s)):</span><br><span class="line">            res.append(s[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res.append(s[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字符串遍历拼接</p>
<ul>
<li>
<p>若面试不允许用join，可以使用该方法</p>
</li>
<li>
<p>新建一个str，记为res</p>
</li>
<li>
<p>遍历字符串，用&quot;+&quot;依次拼接字符串</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(s)):</span><br><span class="line">            res += s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res += s[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>剑指offer方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        s = list(s)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        self.reverse(s, n, len(s) - <span class="number">1</span>)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, len(s) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            s[start], s[end] = s[end], s[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="滑动窗口的最大值"><a class="markdownIt-Anchor" href="#滑动窗口的最大值"></a> 滑动窗口的最大值</h1>
<h2 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题59I）：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
</li>
</ul>
<h2 id="题解-24"><a class="markdownIt-Anchor" href="#题解-24"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：单调队列</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li><strong>初始化</strong>：双端队列deque，结果列表res，数组长度n</li>
<li><strong>滑动窗口</strong>：左边界范围i∈[1-k, n+1-k]，右边界范围j∈[0, n-1]
<ul>
<li>若i＞0且队首元素deque[0]=被删除元素nums[i-1]，则队首元素出队</li>
<li>删除deque内所有＜nums[j]的元素，以保持deque递减</li>
<li>将nums[j]添加至deque尾部</li>
<li>若已形成窗口(即i≥0)，将窗口最大值（即队首元素deque[0]）添加至列表res</li>
</ul>
</li>
<li><strong>返回值</strong>：返回结果列表res</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，其中 n为数组 nums长度；线性遍历 nums占用 O(N)；每个元素最多仅入队和出队一次，因此单调队列 deque占用 O(2N) 。</p>
</li>
<li>
<p>空间复杂度：O(k)，双端队列 deque中最多同时存储 k个元素（即窗口大小）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        <span class="comment">#未形成窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res = [deque[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#形成窗口后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]: <span class="comment"># 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="队列的最大值"><a class="markdownIt-Anchor" href="#队列的最大值"></a> 队列的最大值</h1>
<h2 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题59II）：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
</li>
</ul>
<h2 id="题解-25"><a class="markdownIt-Anchor" href="#题解-25"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>我们知道对于一个普通队列，push_back 和 pop_front 的时间复杂度都是 O(1)，因此我们直接使用队列的相关操作就可以实现这两个函数。</li>
<li>使用一个双端队列 deque，在每次入队时，如果 deque 队尾元素小于即将入队的元素 value，则将小于 value的元素全部出队后，再将 value 入队；否则直接入队。这时，辅助队列 deque<em>d<strong>e</strong>q<strong>u</strong>e</em> 队首元素就是队列的最大值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        self.que = deque()</span><br><span class="line">        self.sort_que = deque()   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sort_que[<span class="number">0</span>] <span class="keyword">if</span> self.sort_que <span class="keyword">else</span> <span class="number">-1</span>   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.sort_que <span class="keyword">and</span> self.sort_que[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.sort_que.pop()</span><br><span class="line">        self.sort_que.append(value)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = self.que.popleft()</span><br><span class="line">        <span class="keyword">if</span> res == self.sort_que[<span class="number">0</span>]:</span><br><span class="line">            self.sort_que.popleft()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="n个骰子的点数"><a class="markdownIt-Anchor" href="#n个骰子的点数"></a> n个骰子的点数</h1>
<h2 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题60）：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 11</p>
</li>
</ul>
<h2 id="题解-26"><a class="markdownIt-Anchor" href="#题解-26"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：骰子一共6个面，每个面上都有一个点数，对应的是1~6之间的一个数字。所以n个骰子的点数和的最小值为n，最大值为6n。另外根据排列组合的知识，我们还知道n个骰子的所有点数的排列数位6<sup>n。要解决这个问题，我们需要先统计出每一个点数出现的次数，然后把每一个点数出现的次数除以6</sup>n，就能求出每个点数出现的概率。
<ul>
<li>基于递归求骰子点数，时间效率不够高
<ul>
<li>可以先把n个骰子分为两堆：第一堆只有一个，另一个有n-1个。单独的那一个有可能出现从1到6的点数。我们需要计算1到6的每一种点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子还是分成两堆，第一堆只有一个，第二堆有n-2个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加，再和剩下的n-2骰子来计算点数和。递归的思路，递归结束条件就是最后只剩下一个骰子。我们可以定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组第s-n个元素里。</li>
</ul>
</li>
<li>基于循环求骰子点数，时间性能好
<ul>
<li>我们可以考虑用两个数组来存储骰子点数的每一个总数出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。下一循环中，我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的总和，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：动态规划</p>
<ul>
<li>
<p><strong>表示状态</strong>：dp[i][j]，表示投掷完i个骰子后，点数j的出现次数</p>
</li>
<li>
<p><strong>找出状态转移方程</strong>：找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。最后一个阶段也就是投掷完 n枚骰子后的这个阶段，我们用 dp[n][j]来表示最后一个阶段点数 j 出现的次数。单单看第 n枚骰子，它的点数可能为 1 , 2, 3, … , 6 ，因此投掷完 n 枚骰子后点数 j出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, … , j-6 出现的次数之和转化过来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (第n枚骰子的点数 i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;</span><br><span class="line">    dp[n][j] +&#x3D; dp[n-1][j - i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>写成数学公式：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></munderover><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][j] = \sum^{6}_{i = 1}dp[n-1][j-i]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
</li>
<li>
<p>n表示阶段，j表示投掷完n枚骰子之后的点数和，i表示第n枚骰子会出现的六个点数</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>**边界处理：**这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, … , 6，并且每个点数出现的次数都是 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;</span><br><span class="line">    dp[1][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span> * n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="comment">#表示i个骰子投掷出s点的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>  <span class="comment">#表示一个骰子投掷出i点的次数为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment">#表示骰子的个数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i * <span class="number">6</span> + <span class="number">1</span>): <span class="comment">#表示可能会出现的点数之和</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= k + <span class="number">1</span>:</span><br><span class="line">                        dp[i][j] += dp[i - <span class="number">1</span>][j - k] <span class="comment">#当前n个骰子出现的点数之和等于前一次出现的点数之和加上这一次出现的点数</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,n * <span class="number">6</span> + <span class="number">1</span>):  <span class="comment">#投掷n次点数出现的所有情况</span></span><br><span class="line">            res.append(dp[n][i] * <span class="number">1.0</span> / <span class="number">6</span> ** n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n^2)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="扑克牌中的顺子"><a class="markdownIt-Anchor" href="#扑克牌中的顺子"></a> 扑克牌中的顺子</h1>
<h2 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题61）：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li>数组长度为 5</li>
<li>数组的数取值为 [0, 13] .</li>
</ul>
</li>
</ul>
<h2 id="题解-27"><a class="markdownIt-Anchor" href="#题解-27"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：首先把数组排序，再统计数组中0的个数，最后统计排序之后的数组中相邻数组之间的空缺总数。如果空缺的总数小于或等于0的个数，那么这个数组就是连续的，反之则不连续。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据题意，此5张牌是顺子的充分条件如下：</p>
<ul>
<li>除大小王外，所有牌<strong>无重复</strong></li>
<li>设此5张牌中最大的牌为max，最小的牌为min（大小王除外），则需满足：max-min&lt;5</li>
</ul>
</li>
<li>
<p>思路：集合set+遍历 、 排序+遍历</p>
<ul>
<li>
<p>集合set+遍历</p>
<ul>
<li>
<p>遍历5张牌，遇到大小王（即0）直接跳过</p>
</li>
<li>
<p>判别重复牌，利用 set实现遍历判重，set的查找方法的时间复杂度为O(1)</p>
</li>
<li>
<p>获取最大牌和最小牌，借助辅助遍历ma和mi，遍历统计即可。</p>
</li>
<li>
<p>时间复杂度： O(N) = O(5) = O(1)， 其中 N为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</p>
</li>
<li>
<p>空间复杂度：O(N)=O(5)=O(1) ，用于判重的辅助 Set 使用 O(N)额外空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        repeat = set()</span><br><span class="line">        ma, mi = <span class="number">0</span>, <span class="number">14</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 跳过大小王</span></span><br><span class="line">            ma = max(ma, num) <span class="comment"># 最大牌</span></span><br><span class="line">            mi = min(mi, num) <span class="comment"># 最小牌</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> repeat: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num) <span class="comment"># 添加牌至 Set</span></span><br><span class="line">        <span class="keyword">return</span> ma - mi &lt; <span class="number">5</span> <span class="comment"># 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>排序+遍历（剑指）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        zero = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                zero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[zero] &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 O(N log N) = O(5 log 5) = O(1)， 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用O(NlogN) 时间。</li>
<li>空间复杂度 O(1) ，变量 joker 使用 O(1)大小的额外空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#圆圈中最后剩下的数字"></a> 圆圈中最后剩下的数字</h1>
<h2 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题62）：0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-28"><a class="markdownIt-Anchor" href="#题解-28"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：约瑟夫环问题，有以下两种解法：</p>
<ol>
<li>用环形链表模拟圆圈的经典解法，时间复杂度：O(mn)，空间复杂度：O(n)</li>
<li>分析每次被删除数字的规律并直接计算出圆圈中最后剩下的数字</li>
</ol>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/</a></li>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：根据递推公式就可以使用递归或者迭代</p>
<ul>
<li>
<p>迭代：</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            f = (m + f) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="股票的最大利润"><a class="markdownIt-Anchor" href="#股票的最大利润"></a> 股票的最大利润</h1>
<h2 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题63）:假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
</li>
</ul>
<h2 id="题解-29"><a class="markdownIt-Anchor" href="#题解-29"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：动态规划</p>
<ul>
<li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以 prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。</li>
<li><strong>转移方程</strong>：由于题目限定 “买卖该股票一次” ，因此前 i日最大利润 dp[i] 等于前 i - 1日最大利润 dp[i-1]和第 i 日卖出的最大利润中的最大值。
<ul>
<li>前<em>i</em>日最大利润=max(前(<em>i</em>−1)日最大利润,第<em>i</em>日价格−前<em>i</em>日最低价格)</li>
<li>dp[i] = max(dp[i - 1] , prices[i] - min(prices[0:i]))</li>
</ul>
</li>
<li><strong>初始状态</strong>：dp[i] = 0，首日利润为0</li>
<li><strong>返回值</strong>：dp[n-1]，其中n为dp列表长度</li>
<li><strong>效率优化</strong>：
<ul>
<li>时间复杂度降低： 前 i 日的最低价格 min(prices[0:i]) 时间复杂度为 O(i) 。而在遍历 prices时，可以借助一个变量（记为成本 cost ）每日更新最低价格。优化后的转移方程为：
<ul>
<li>dp[i] = max(dp[i - 1] , prices[i] - min(cost, prices[i]))</li>
</ul>
</li>
<li>空间复杂度降低：由于dp[i]只与dp[i-1]，pirces[i]，cost有关，因此可以用一个变量（记为profit）代表dp列表：
<ul>
<li>profit = max(profit, prices[i] - min(cost, prices[i]))</li>
</ul>
</li>
</ul>
</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">0</span> <span class="keyword">or</span> len(prices) &gt; <span class="number">10</span>**<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cost = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            cost = min(cost, price)</span><br><span class="line">            profit = max(profit, price - cost)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="求12n"><a class="markdownIt-Anchor" href="#求12n"></a> 求1+2+…+n</h1>
<h2 id="题目-30"><a class="markdownIt-Anchor" href="#题目-30"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题64）:求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-30"><a class="markdownIt-Anchor" href="#题解-30"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：通常求1+2+3+…+n，除了用公式n(n+1)/2之外，无外乎循环和递归两种思路。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/</a></li>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归使用if判断的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    n += sumNums(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
<ul>
<li>如何替代if做判断？可以用逻辑运算符</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">        self.res += n</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：快速乘</p>
<ul>
<li>
<p>回到本题，由等差数列求和公式我们可以知道 1+2+3+…+n等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，对于除以 2 我们可以用右移操作符来模拟，那么等式变成了 n(n+1)&gt;&gt;1，剩下不符合题目要求的部分即为 n(n+1)，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 n 为 [1,10000]，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。</p>
</li>
<li>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_a</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.res += a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_by_recursive</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        b &amp; <span class="number">1</span> <span class="keyword">and</span> self.add_a(a)</span><br><span class="line">        b <span class="keyword">and</span> self.sum_by_recursive(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a = n</span><br><span class="line">        b = n + <span class="number">1</span></span><br><span class="line">        self.sum_by_recursive(a, b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="不用加减乘除做加法"><a class="markdownIt-Anchor" href="#不用加减乘除做加法"></a> 不用加减乘除做加法</h1>
<h2 id="题目-31"><a class="markdownIt-Anchor" href="#题目-31"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题65）：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
</li>
</ul>
<h2 id="题解-31"><a class="markdownIt-Anchor" href="#题解-31"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：：位运算</p>
<ul>
<li>python负数存储介绍：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/</a></li>
<li>二进制公式推导：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：</p>
<ol>
<li>第一步不考虑进位对每一位相加。0加0、1加1的结果都0，0加1、1加0的结果都是1。这和异或结果一样。</li>
<li>考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时，我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0.</li>
<li>第三步把前两个步骤的结果相加，相加的过程依然是重复前面两步，直到不产生进位为止。</li>
</ol>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x <span class="comment">#计算两个数的二进制补码</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x  <span class="comment">#计算无进位和赋给a，计算进位赋给b</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x) <span class="comment">#~是按位取反运算符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="构建乘积数组"><a class="markdownIt-Anchor" href="#构建乘积数组"></a> 构建乘积数组</h1>
<h2 id="题目-32"><a class="markdownIt-Anchor" href="#题目-32"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题66）：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li><code>a.length &lt;= 100000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-32"><a class="markdownIt-Anchor" href="#题解-32"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：列表格，根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p>
<ul>
<li>算法流程：
<ol>
<li>初始化：数组 B ，其中 B[0] = 1 ；辅助变量 tmp = 1 ；</li>
<li>计算 B[i]的 下三角 各元素的乘积，直接乘入 B[i] ；</li>
<li>计算 B[i] 的 上三角 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li>
<li>返回 B 。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * len(a), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>): </span><br><span class="line">            tmp *= a[i + <span class="number">1</span>] <span class="comment"># 上三角</span></span><br><span class="line">            b[i] *= tmp <span class="comment"># 下三角 * 上三角</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把字符串转换成整数"><a class="markdownIt-Anchor" href="#把字符串转换成整数"></a> 把字符串转换成整数</h1>
<h2 id="题目-33"><a class="markdownIt-Anchor" href="#题目-33"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题67）:写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 </span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-33"><a class="markdownIt-Anchor" href="#题解-33"></a> 题解</h2>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/die-dai-zheng-ze-biao-da-shi-by-z1m/%EF%BC%88%E8%BF%AD%E4%BB%A3+%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/die-dai-zheng-ze-biao-da-shi-by-z1m/（迭代+正则表达式）</a></li>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-guan-j/%EF%BC%88%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-guan-j/（面试思路描述）</a></li>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/</a></li>
</ul>
</li>
</ul>
<h1 id="二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉搜索树的最近公共祖先"></a> 二叉搜索树的最近公共祖先</h1>
<h2 id="题目-34"><a class="markdownIt-Anchor" href="#题目-34"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题68I）：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
</li>
</ul>
<h2 id="题解-34"><a class="markdownIt-Anchor" href="#题解-34"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
</li>
<li>
<p><strong>最近公共祖先的定义</strong>： 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left和右子节点 root.right都不是 p,q的公共祖先，则称 root是 “最近的公共祖先” 。</p>
</li>
<li>
<p>根据以上定义，若 root 是 p,q的 <strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p>
<ul>
<li>p 和 q在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root的左或右子树中；</li>
<li>q = root，且 p在 root的左或右子树中；</li>
</ul>
</li>
<li>
<p>本题给定了两个重要条件：① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q与 root 的子树关系，即：</p>
<ul>
<li>若 root.val &lt; p.val，则 p在 root右子树 中；</li>
<li>若 root.val &gt; p.val，则 p 在 root 左子树 中；</li>
<li>若 root.val = p.val，则 p 和 root 指向 同一节点 。</li>
</ul>
</li>
<li>
<p>思路：迭代</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val: <span class="comment"># p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right <span class="comment"># 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val: <span class="comment"># p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left <span class="comment"># 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>优化：若可保证 p.val &lt; q.val ，则在循环中可减少判断条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p.val &gt; q.val: p, q = q, p <span class="comment"># 保证 p.val &lt; q.val</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val: <span class="comment"># p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right <span class="comment"># 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; q.val: <span class="comment"># p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left <span class="comment"># 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>思路：递归</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉树的最近公共祖先"></a> 二叉树的最近公共祖先</h1>
<h2 id="题目-35"><a class="markdownIt-Anchor" href="#题目-35"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题68II）：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
</li>
</ul>
<h2 id="题解-35"><a class="markdownIt-Anchor" href="#题解-35"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/（递归）</a></li>
<li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/</a> (多种解法)</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q在节点 root 的异侧时，节点 root即为最近公共祖先，则向上返回 root。</li>
<li>递推解析见参考链接</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/06/02/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 面试必备《剑指offer》，题解整理，方便今后自己查阅，要为接下来的秋招做准备了呀~</p>
<h1 id="数组中重复的数字"><a class="markdownIt-Anchor" href="#数组中重复的数字"></a> 数组中重复的数字</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题03)：找出数组中重复的数字。<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有多种解法，如果面试中遇到这道题，让你找出数组中重复的数字，要向面试官询问，<u><strong>是否可以使用额外空间</strong></u>？<u><strong>是否可以修改原数组</strong></u>？然后，根据要求给出解决方案。（<strong><u>本题对数组长度做了限制，如果没有限制数组长度，需要进行非空判断</u></strong>）</p>
<ol>
<li>
<p><strong>使用额外空间，不修改原数组——哈希表</strong></p>
<ul>
<li>
<p>思路：遍历数组，用哈希表记录数组中每个数字出现的情况，如果该数字没有出现在哈希表，就将其加入哈希表，如果该数字在哈希表中已经存在，就直接返回。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——sort排序</strong></p>
<ul>
<li>
<p>思路：对数组排序，这样重复的两个数字的位置就是相邻的，然后，遍历一遍数组，判断相邻位置的两个数字是否相等，相等就返回，不相等就继续遍历。</p>
</li>
<li>
<blockquote>
<p>list.sort()的原理：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">https://blog.csdn.net/yangzhongblog/article/details/8184707</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(nlogn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——原地排序</strong></p>
<ul>
<li>
<p>思路：<strong>因为数组的数字范围和数组的长度是一样的，即与数组下标一一对应（把数组视为哈希表）</strong>。因此，我们看到数字，就可以知道把这个数字放在数组的哪个位置上。这就像是我们人为编写了哈希函数，这个哈希函数的规则还特别简单，而找到重复数字就是发生了哈希冲突。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<blockquote>
<p>Python 中， a, b = c, d 操作的原理是先暂存元组 (c, d) ，然后 “按顺序” 赋值给 a 和 b 。<br>
若写为 nums[i], nums[nums[i]] = nums[nums[i]], nums[i] ，则 nums[i] 先被赋值，之后 nums[nums[i]] 指向的元素则会出错。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> 二维数组中的查找</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题04）：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn><mi mathvariant="normal">，</mi><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤n≤1000，0≤m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：如果这个n * m的数组是无序的，要查找该数组中是否存在目标整数，需要遍历完二维数组每一行或者每一列，即暴力求解法，时间复杂度是O(n*m)，空间复杂度是O(1)。仔细观察题目的二维数组，可以发现行和列的数字是按一定顺序排列的。</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后从数组中选取一个数字，分3种情况来分析查找过程。当数组中选取的数字刚好要和查找的数字相等时，就结束查找过程。如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取的位置的上边或者右边。（若当前选取位置在正中间，则在右下角或左上角可能会出现查找重叠区域）。</p>
</blockquote>
</li>
<li>
<p>思路：从数组的一个角上选取数字来和要查找的数字做比较。</p>
<ul>
<li>
<p>左上角数字：是所在列和行最小的数字（如果查找的数字大于左上角数字，情况和上述分析一样，可以往右边或者下边查找）</p>
</li>
<li>
<p>左下角数字：是所在列最大的数字，所在行最小的数字（如果查找的数字大于左下角数字，往右边查找，如果小于做左下角数字，往上边查找）</p>
</li>
<li>
<p>右上角数字：是所在列最小的数字，所在行最大的数字（如果查找的数字大于右上角数字，往下边查找，如果小于右上角数字，往左边查找）</p>
</li>
<li>
<p>右下角数字：是所在列和行最大的数字（如果查找的数字小于右下角数字，情况和上述分析一样，可以往左边或者上边查找）</p>
</li>
<li>
<p>因此，本题可以选择左下角数字或右上角数字来和查找的数字做比较。</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>特殊用例：二维数组为空，返回空</li>
<li>假设从矩阵matrix的左下角数字开始遍历（索引设为i，j），与要查找的数字做比较：（右上角同理分析）
<ul>
<li>当<code>matrix[i][j] == target</code>，返回True</li>
<li>当<code>matrix[i][j] &gt; target</code>，行索引<code>i</code>向上查找，即<code>i--</code></li>
<li>当<code>matrix[i][j] &lt; target</code>，列索引<code>j</code>向右查找，即<code>j++</code></li>
</ul>
</li>
<li>若行索引或列索引越界，则代表矩阵中无目标值，返回 False。</li>
</ul>
</li>
<li>
<blockquote>
<p>算法本质： 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n + m)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = len(matrix) - <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="替换空格"><a class="markdownIt-Anchor" href="#替换空格"></a> 替换空格</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题05）：请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>s</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ s的长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成’%’、‘2’、'0’这3个字符，因此字符串会变长。如果是在原来的字符串上做替换，那么就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上做替换，那么我们可以自己分配足够多的内存。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据上述分析，在面试的时候，要明确面试官的需求，然后，从两种方案中选择一种完成。下面是三种最优的解法：</p>
<ol>
<li>
<p>使用replace函数（新）</p>
<ul>
<li>
<blockquote>
<p>python内置的<code>replace</code>函数用来替换字符串中指定的字符。</p>
<p>replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p>
<p>replace()方法语法：<code>str.replace(old, new[, max])</code></p>
<p>参数</p>
<ul>
<li>old – 将被替换的子字符串。</li>
<li>new – 新字符串，用于替换old子字符串。</li>
<li>max – 可选字符串, 替换不超过 max 次</li>
</ul>
<p>返回值：返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环（新）</p>
<blockquote>
<ul>
<li>Python的六个标准数据类型中不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）。</li>
</ul>
</blockquote>
<ul>
<li>
<p>将字符串先转换为list，然后，遍历list，当遍历到空格，就将空格替换成’%20’，最后，将list转成str。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        l = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            <span class="keyword">if</span> l[i] == <span class="string">' '</span>:</span><br><span class="line">                l[i] = <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>双指针移动+计数（原始）</p>
<ul>
<li>
<p>首先遍历一次字符串s，统计空格数</p>
</li>
<li>
<p>假设有m个空格，我们需要填充’%20’占用的三个字符串位置，所以需要额外开辟2 * m个空间</p>
</li>
<li>
<p>将开辟出的空间链接到原字符串的后面,新的字符串命名为s_new</p>
</li>
<li>
<p>设置两个指针p1和p2,初始时p1指向原字符串s的末尾,p2指向s_new的末尾</p>
</li>
<li>
<p>p1指针向前移动,当p1指向的字符不是空格时,将p1指向的字符复制到p2指向的位置,并都向前移动一位</p>
</li>
<li>
<p>当p1指向的字符是空格时,p1向前移动一格,这时应该插入%20,所以p2向前移动三格,并在这三格中插入%,2,0</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(2m)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s_len = len(s)</span><br><span class="line">        space_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</span><br><span class="line">                space_count += <span class="number">1</span></span><br><span class="line">        s_len += <span class="number">2</span> * space_count</span><br><span class="line">        new_array = [<span class="string">' '</span>] * s_len</span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p1 <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == <span class="string">' '</span>:</span><br><span class="line">                new_array[p2] = <span class="string">'%'</span></span><br><span class="line">                new_array[p2 + <span class="number">1</span>] = <span class="string">'2'</span></span><br><span class="line">                new_array[p2 + <span class="number">2</span>] = <span class="string">'0'</span></span><br><span class="line">                p2 += <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_array[p2] = s[p1]</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_array)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题06）：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 链表长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：面试时候，需要明确**<u>是否允许在打印链表的时候修改链表的结构</u>**？如果可以修改，那么就是<u><strong>面试题24-反转链表</strong></u>，先对链表进行反转，然后输出。如果不可以修改，那肯定需要遍历链表，遍历顺序是从头到尾，输出是从尾到头，典型的“后进先出”，我们可以<u><strong>使用栈实现</strong></u>。想到栈，我们还可以想到递归，<u><strong>递归在本质上就是一个栈结构</strong></u>，即每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身。</p>
<ol>
<li>
<p><strong>修改链表结构-反转链表</strong>（具体看面试题24-反转链表）</p>
<ul>
<li>
<p>特殊用例：链表头结点指针为空，返回[]</p>
</li>
<li>
<p>双指针反转链表：</p>
</li>
<li>
<p>初始化两个指针，<code>pre == None</code>，<code>cur == head</code></p>
</li>
<li>
<p>遍历链表，用临时变量tmp记录当前结点，并将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></p>
</li>
<li>
<p>pre和cur都向链表尾部移动，直到cur为空。</p>
</li>
<li>
<p>题目要求用数组返回，因此，初始化数组<code>s = []</code>，遍历反转后的链表，依次将每个结点的值加入数组，然后返回数组s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            s.append(pre.val)</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-栈</strong>（迭代）：</p>
<ul>
<li>
<p>创建一个栈，用于存储链表结点</p>
</li>
<li>
<p>创建一个指针，初始时指向链表的头结点</p>
</li>
<li>
<p>当指针指向元素非空时，重复下列操作：</p>
<ul>
<li>将指针指向的结点压入栈内</li>
<li>将指针移到当前结点的下一个结点</li>
</ul>
</li>
<li>
<p>初始化数组<code>s=[]</code></p>
</li>
<li>
<p>当栈不为空时，重复下列操作：</p>
<ul>
<li>将栈顶结点弹出，将栈顶结点的值加入数组s</li>
</ul>
</li>
<li>
<p>返回数组s</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        i = head</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            stack.append(i)</span><br><span class="line">            i = i.next</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            s.append(stack.pop().val)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>python可以对上面的代码优化，不需要再创建一个数组s，可以直接利用切片，直接输出倒序列表stack</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        i = head</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            stack.append(i.val)</span><br><span class="line">            i = i.next</span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-递归</strong></p>
<ul>
<li>
<p><strong>利用递归：</strong> 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
</li>
<li>
<p><strong>递推阶段：</strong> 每次传入 <code>head.next</code> ，以 <code>head == None</code>（即走过链表尾部节点）为递归终止条件，此时返回空列表 <code>[]</code> 。</p>
</li>
<li>
<p><strong>回溯阶段：</strong> 利用 Python 语言特性，递归回溯时每次返回 <code>当前 list + 当前节点值 [head.val]</code>，即可实现节点的倒序输出</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显示用栈基于循环实现的代码鲁棒性要好一些。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="重建二叉树"><a class="markdownIt-Anchor" href="#重建二叉树"></a> 重建二叉树</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题07）：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给出</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 节点个数 ≤ 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p>思路：根据前序遍历和中序遍历的特点，可以对前序遍历和中序遍历序列进行划分，划分出左子树、根节点、右子树的区间，然后，递归构造二叉树。</p>
<ul>
<li>特殊用例：前序遍历为空或中序遍历为空或节点个数≤0，返回None（前序遍历和中序遍历不匹配）</li>
<li>根据前序遍历特点，前序遍历序列的第一个数字是根节点的值，即<code>root_val = preorder[0]</code></li>
<li>构建根节点，<code>root = TreeNode(root_val)</code></li>
<li>确定根节点在中序遍历的序列的索引：<code>root_in_index = inorder.index(root_val)</code></li>
<li>确定左子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>确定右子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>递归构建左子树和右子树</li>
<li>返回root</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        root_in_index = inorder.index(root_val)</span><br><span class="line">        left_pre = preorder[<span class="number">1</span>: root_in_index + <span class="number">1</span>]</span><br><span class="line">        left_in = inorder[: root_in_index]</span><br><span class="line">        right_pre = preorder[root_in_index + <span class="number">1</span>:]</span><br><span class="line">        right_in = inorder[root_in_index + <span class="number">1</span>:]</span><br><span class="line">        root.left = self.buildTree(left_pre, left_in)</span><br><span class="line">        root.right = self.buildTree(right_pre, right_in)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="用两个栈实现队列"><a class="markdownIt-Anchor" href="#用两个栈实现队列"></a> 用两个栈实现队列</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题09）：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 ≤ values ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li>最多会对 appendTail、deleteHead 进行 10000 次调用</li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：
<ul>
<li>初始化stack1和stack2</li>
<li>插入元素：将元素插入stack1</li>
<li>删除元素：stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack1:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack1:</span><br><span class="line">            self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure>
<h1 id="用两个队列实现栈"><a class="markdownIt-Anchor" href="#用两个队列实现栈"></a> 用两个队列实现栈</h1>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：pop(0)是pop第一个元素，pop()是pop最后一个元素，时间效率上pop最后一个元素效率高。pop用于stack，可带参数，popleft用于collections中，不可带参数。（都是pop出来且在原数据删除）</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>初始化两个队列，q1和q2</li>
<li>进栈：元素队列q1</li>
<li>出栈：当队列q1只有一个元素，直接出队，否则，把q1的元素出队并入队q2，直到q1中只有一个元素，再直接出队。为了下一次继续操作，互换q1和q2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.q1 = []</span><br><span class="line">        self.q2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.q1.append(val)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.q1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> len(self.q1) != <span class="number">1</span>:</span><br><span class="line">            self.q2.append(self.q1.pop(<span class="number">0</span>))</span><br><span class="line">        self.q1, self.q2 = self.q2, self.q1</span><br><span class="line">        <span class="keyword">return</span> self.q2.pop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    l = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">        s.push(l[i])</span><br><span class="line">    print(l)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">        print(s.pop(), <span class="string">','</span>, end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="斐波那契数列"><a class="markdownIt-Anchor" href="#斐波那契数列"></a> 斐波那契数列</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-I）：写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[ <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
<li>可以用3个变量，sum，a，b，优化上述代码，时间复杂度不变，空间复杂度降为O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h1 id="青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#青蛙跳台阶问题"></a> 青蛙跳台阶问题</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-II）：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</li>
<li>此类求 多少种可能性 的题目一般都有 递推性质 ，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n - 1)....f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间是有联系的。</li>
<li>设跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。</li>
<li>当为 1 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>种跳法；</li>
<li>当为 2 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>种跳法。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为以上两种情况之和，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> ，以上递推性质为斐波那契数列。</li>
<li>本题可转化为 求斐波那契数列第 n项的值 ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。
<ul>
<li>青蛙跳台阶问题： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(0)=1 , f(1)=1 , f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ；</li>
<li>斐波那契数列问题：$ f(0)=0 , f(1)=1 , f(2)=1$ ;</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：直接在面试题10-I 斐波那契数列的基础上，将起始数字做一个修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        one = <span class="number">1</span></span><br><span class="line">        two = <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            res = one + two</span><br><span class="line">            one = two</span><br><span class="line">            two = res</span><br><span class="line">        m = max(n, res)</span><br><span class="line">        <span class="keyword">return</span> m % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="旋转数组中最小的数字"><a class="markdownIt-Anchor" href="#旋转数组中最小的数字"></a> 旋转数组中最小的数字</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题11）：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<strong>输入一个递增排序的数组的一个旋转</strong>，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li><strong>Tips</strong>：<strong><u>如果面试题是要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。关于查找和排序见另一篇博客《八大排序》</u></strong></li>
</ul>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></li>
<li>参考2：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>根据题目可以发现，输入的递增排序数组，可以从中点划分成两个递增数组。左排序数组的任一元素都大于右排序数组的任一元素。</li>
<li>双指针法，初始化两个指针i，j，指向数组的头和尾，即<code>i == 0</code>， <code>j == len(numbers)</code></li>
<li><code>mid = (i + j) // 2</code>，每次二分的中点</li>
<li>当<code>numbers[mid] &gt; numbers[j]</code>，m在左边的递增数组，最小元素一定在[m+1, j]</li>
<li>当<code>numbers[mid] &lt; numbers[j]</code>，m在右边的递增数组，最小元素一定在[i,m]</li>
<li>当<code>numbers[mid] = numbers[j]</code>，无法判断m在哪，缩小区间即可[i,j-1]</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            mid = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &gt; numbers[j]:</span><br><span class="line">                i = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; numbers[j]:</span><br><span class="line">                j = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="矩阵中的路径"><a class="markdownIt-Anchor" href="#矩阵中的路径"></a> 矩阵中的路径</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题12）：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,“<strong>b</strong>”,“c”,“e”],<br>
[“s”,“<strong>f</strong>”,“<strong>c</strong>”,“s”],<br>
[“a”,“d”,“<strong>e</strong>”,“e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1 &lt;= board.length &lt;= 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1 &lt;= board[i].length &lt;= 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：DFS+剪枝</p>
<ul>
<li>递归参数：当前元素在矩阵<code>board</code>中行列索引<code>i</code>和<code>j</code>，当前目标字符在<code>word</code>中的索引<code>k</code>。</li>
<li>终止条件：
<ul>
<li>返回false：①行或列索引越界或②当前矩阵元素与目标字符不同或③当前矩阵元素已访问过（③可合并至②）。</li>
<li>返回true：字符串<code>word</code>已全部匹配，即<code>k == len(word) - 1</code>。</li>
</ul>
</li>
<li>递推工作：
<ul>
<li>标记当前矩阵元素：将<code>board[i][j]</code>值暂存于变量<code>tmp</code>，并修改为字符<code>'/'</code>，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格：朝当前元素的上、下、左、右四个方向开启下层递归，使用或连接（代表只需一条可行路径），并记录结果至<code>res</code>。</li>
<li>还原当前矩阵元素：将<code>tmp</code>暂存值还原至<code>board[i][j]</code>元素。</li>
</ul>
</li>
<li>回溯返回值：返回<code>res</code>，代表是否搜索到目标字符串。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)</p>
</li>
<li>
<p>空间复杂度：O(K)</p>
</li>
<li>
<p>M,N 分别为矩阵行列大小， K<em>K</em> 为字符串 <code>word</code> 长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="comment"># 如果路径出界或者矩阵中的值不是word的首字母，返回False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">"/"</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j <span class="number">-1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网对应的这个题的python解法的通过榜单的榜首的代码都会有部分case过不了，正确代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i*cols + j] == path[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(list(matrix), rows, cols, path[<span class="number">1</span>:], i, j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, rows, cols, path, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        matrix[i*cols + j] = <span class="string">'-'</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> matrix[x*cols+y]==path[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> self.dfs(matrix, rows, cols, path[<span class="number">1</span>:], x, y):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="机器人的运动范围"><a class="markdownIt-Anchor" href="#机器人的运动范围"></a> 机器人的运动范围</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题13）：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 &lt;= n,m &lt;= 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">0 &lt;= k &lt;= 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>类似矩阵搜索问题，通常可以采用深度优先搜索（DFS）或广度优先搜索（BFS）。 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。BFS 实现： 通常利用队列实现广度优先遍历。</li>
<li>python的set()：<a href="https://www.runoob.com/python3/python3-set.html%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%88set%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E7%9A%84%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%EF%BC%8C%E5%B0%86%E5%85%83%E7%B4%A0s%E5%8A%A0%E5%85%A5%E9%9B%86%E5%90%88%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E5%B7%B2%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E8%BF%9B%E8%A1%8C%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%9B%86%E5%90%88%E5%BF%85%E9%A1%BB%E7%94%A8" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-set.html，集合（set）是一个无序的不重复元素序列，将元素s加入集合，如果元素已存在，则不进行任何操作。注意：创建一个空集合必须用</a> <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/</a></p>
</blockquote>
</li>
<li>
<p>思路1：</p>
<ul>
<li>DFS
<ul>
<li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li>
<li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li>
<li>递推工作：
<ul>
<li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li>
<li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li>
</ul>
</li>
</ul>
</li>
<li>时间复杂度：O(MN)，[MN为矩阵行列大小]</li>
<li>空间复杂度：O(MN)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, si, sj)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj) + dfs(i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj <span class="number">-8</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：</p>
<ul>
<li>BFS
<ul>
<li>初始化： 将机器人初始点 (0, 0)加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：</li>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li>
<li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue, visited = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j, si, sj = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add((i, j))</span><br><span class="line">            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))</span><br><span class="line">            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="剪绳子i"><a class="markdownIt-Anchor" href="#剪绳子i"></a> 剪绳子I</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14-I）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>58</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/</a>
<ul>
<li>写的很详细</li>
<li>面试时建议从方法三开始描述，再提出下面的优化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>思路</strong>：<strong>状态转移方程</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>j</mi><mo separator="true">,</mo><mi>j</mi><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中dp[i]表示维持原状态不剪、(i-j) * j表示从j处剪，剪下来的部分就是i-j，i-j不再剪了，j * dp[i-j]表示从j处剪，剪下来的部分是i-j，i-j继续剪。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)，仅用了有限长数组</p>
</li>
<li>
<p>下面代码更适合面试时使用，即动态规划思路</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
<li>下面代码适合了解学习，属于找规律，数学方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a)</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="剪绳子ii"><a class="markdownIt-Anchor" href="#剪绳子ii"></a> 剪绳子II</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14II）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：和面试题14I - 剪绳子I的解题思想是一样的，在此基础上，考虑<strong>大数越界情况下的求余</strong>问题。</p>
</li>
<li>
<blockquote>
<p>参考链接里介绍的求余方法：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span> % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span> % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二进制中1的个数"><a class="markdownIt-Anchor" href="#二进制中1的个数"></a> 二进制中1的个数</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题15）：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：（剑指offer)位运算的使用**。位运算总共只有五种运算：<strong>与、或、异或、左移、右移</strong>。与、或和异或运算的规律我们可以用下表总结：</p>
<table>
<thead>
<tr>
<th>与（&amp;）</th>
<th>0&amp;0 = 0</th>
<th>1&amp;0=0</th>
<th>0&amp;1=0</th>
<th>1&amp;1=1</th>
</tr>
</thead>
<tbody>
<tr>
<td>或（！）</td>
<td>0|0 = 0</td>
<td>1|0=1</td>
<td>0|1=0</td>
<td>1|1=1</td>
</tr>
<tr>
<td>异或（^）</td>
<td>0^0 = 0</td>
<td>1^0=1</td>
<td>0^1=1</td>
<td>1^1=0</td>
</tr>
</tbody>
</table>
<ul>
<li>左移运算符m&lt;&lt;n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。比如：
<ul>
<li>00001010&lt;&lt;2 = 00101000</li>
<li>10001010&lt;&lt;3=01010000</li>
</ul>
</li>
<li>右移运算符m&gt;&gt;n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。
<ul>
<li>00001010&gt;&gt;2=00000010</li>
<li>10001010&gt;&gt;3=11110001</li>
</ul>
</li>
<li><strong>除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。</strong></li>
<li>面试时候可以按照基本思路到下面代码思路进行描述：
<ul>
<li>先判断整数二进制表示中最右边一位是不是1，只需要把整数与1做位与运算，是1就右移1位，直到整个整数为0（如果是有符号数，也就是如果输入负数，这样会产生死循环。</li>
<li>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多次这样的操作。
<ul>
<li>例如，二进制数1100，它的第二位是从最右边数起的一个1。减去1后，第二位变成0，而前面的1保持不变，因此得到结果1011，然后再把1100与1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)，n为整数二进制1的个数</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一行写法</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum(n &gt;&gt; i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">32</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数值的整数次方"><a class="markdownIt-Anchor" href="#数值的整数次方"></a> 数值的整数次方</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题16）：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，<strong>同时不需要考虑大数问题。</strong></p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2^-2 &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</li>
</ul>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<blockquote>
<ul>
<li>（剑指offer)：用一条语句判断<strong>一个整数是不是2的整数次方</strong>。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位是都是0。根据二进制中1的个数分析思路，判断一个整数是不是2的整数次方，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。因此，解决这个问题可以分为两步：
<ul>
<li>第一步：求这两个数的异或</li>
<li>第二步：统计异或结果中1的位数</li>
</ul>
</li>
<li>本题思路参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></li>
</ul>
</li>
<li><strong>计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。</strong>
<ul>
<li>python比较两个float类型的数据是否相等：<a href="https://blog.csdn.net/weixin_34227447/article/details/88713033" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34227447/article/details/88713033</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制问题都可以用这个思路解决。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>考虑输入指数是负数和零的情况。</li>
<li>考虑特殊用例：0的0次方，可以输出0或1</li>
<li><strong>细节</strong>：判断两个double或float类型数值是否相等。位运算代替乘除法以及求余运算。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码可以通过leetcode，但是通过上述分析，我们可以知道，x是double类型，不能直接写 x == 0，因此可以定义一个equal函数进行判断（<code>return abs(num1 - num2) &lt;= 0.0000001</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#打印从1到最大的n位数"></a> 打印从1到最大的n位数</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题17）：输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<blockquote>
<ul>
<li>
<p>（剑指offer）分析：<strong>大数问题</strong>。如果题目要求的是任意大的数字，那么这个题目就是一个大数问题，需要特殊的数据结构来表示数字，比如<strong>用字符串或者数组来表示大的数字，以确保不会溢出</strong>。</p>
</li>
<li>
<p>3种错误处理的方法的优缺点：</p>
<ul>
<li>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>和系统API一致</td>
<td>不能方便地使用计算结果</td>
</tr>
<tr>
<td>全局变量</td>
<td>能够方便地使用计算结果</td>
<td>用户可能会忘记检查全局变量</td>
</tr>
<tr>
<td>异常</td>
<td>可以为不同的出错原因定义不同异常类型，逻辑清晰明了</td>
<td>有些语言不支持异常，抛出异常时对性能有负面影</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="https://blog.csdn.net/chocolate_chuqi/article/details/81700551" target="_blank" rel="noopener">https://blog.csdn.net/chocolate_chuqi/article/details/81700551</a></li>
<li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/quan-pai-lie-di-gui-suan-fa-pythonshi-xian-by-flyi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/quan-pai-lie-di-gui-suan-fa-pythonshi-xian-by-flyi/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：全排列递归求解</p>
<ul>
<li>从左边第一个非0位开始输出；</li>
<li>要考虑0这个特殊值，否则答案会包括0 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = [] <span class="comment"># 用来保存结果</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        number = [<span class="string">"0"</span>]*n</span><br><span class="line">        number[<span class="number">-1</span>] = <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[<span class="number">0</span>] = chr(ord(<span class="string">"0"</span>)+i) <span class="comment"># ord 是将一个字符转换成 ASCII 码，chr 是将一个 ASCII 码转换成一个数字</span></span><br><span class="line">            self.Print1ToMaxOfDigitsRecursively(number, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.result[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print1ToMaxOfDigitsRecursively</span><span class="params">(self, number, length, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span>:</span><br><span class="line">            self.PrintNumberNormal(number)</span><br><span class="line">            self.result.append(int(<span class="string">""</span>.join(number)))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            number[index+<span class="number">1</span>] = chr(ord(<span class="string">"0"</span>)+i)</span><br><span class="line">            self.Print1ToMaxOfDigitsRecursively(number, length, index+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintNumberNormal</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        number = int(<span class="string">""</span>.join(number))</span><br><span class="line">        <span class="keyword">if</span> number != <span class="number">0</span>:</span><br><span class="line">            print(number)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="删除链表的节点"><a class="markdownIt-Anchor" href="#删除链表的节点"></a> 删除链表的节点</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题18）：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>**注意：**此题对比原题有改动</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有两种思路.</p>
<ul>
<li>第一个是得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code>（数据输入类型是整型val）</li>
<li>第二个是把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除（剑指offer思路，数据输入类型是链表ListNode）</li>
</ul>
</li>
<li>
<p>思路1：得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code></p>
<ul>
<li>初始化双指针，pre指向head，cur指向head.next</li>
<li>当head为空时，返回head</li>
<li>当head是要删除的结点，返回head.next</li>
<li>遍历链表，当cur指向的结点是要删除的结点时，pre.next = cur.next，直到链表遍历完</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，n是链表长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单指针写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.next.val == val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除。</p>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/</a></li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题19）：请实现一个函数用来匹配包含 <code>'.'</code> 和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</p>
</li>
<li>
<p><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>'*'</code>。</p>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></li>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</a></li>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：回溯法+动态规划</p>
</li>
<li>
<p>思路1：回溯</p>
</li>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中T和P分别表示匹配串和模式串的长度。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字母是否匹配</span></span><br><span class="line">        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">        <span class="comment"># 如果 p 第二个字母是 *</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：动态规划-自顶向下</p>
</li>
<li>
<p>时间复杂度：O(TP)</p>
</li>
<li>
<p>空间复杂度：O(TP)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> j == len(p):</span><br><span class="line">                    ans = i == len(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first_match = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                    <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(p) <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        ans = dp(i, j+<span class="number">2</span>) <span class="keyword">or</span> first_match <span class="keyword">and</span> dp(i+<span class="number">1</span>, j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans = first_match <span class="keyword">and</span> dp(i+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                memo[i, j] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[i, j]</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="表示数值的字符串"><a class="markdownIt-Anchor" href="#表示数值的字符串"></a> 表示数值的字符串</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题20）：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 除去两端空格</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 检查字符合法性</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"0987654321+-e."</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有e的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 检查e的个数</span></span><br><span class="line">            <span class="keyword">if</span> s.count(<span class="string">'e'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 划分，并检查左右子串是否为空</span></span><br><span class="line">            p = s.index(<span class="string">'e'</span>)</span><br><span class="line">            ls = s[:p]</span><br><span class="line">            rs = s[p+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> len(ls)==<span class="number">0</span> <span class="keyword">or</span> len(rs)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串+-</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串小数点个数</span></span><br><span class="line">            <span class="keyword">if</span> ls.count(<span class="string">'.'</span>)&gt;<span class="number">1</span> <span class="keyword">or</span> rs.count(<span class="string">'.'</span>)&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = ls.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查小数点左或右有没有数字</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = ls.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> ls[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(ls) <span class="keyword">and</span> ls[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 没e的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(s)&lt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = s.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = s.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> s[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(s) <span class="keyword">and</span> s[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#调整数组顺序使奇数位于偶数前面"></a> 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题21）：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>位运算比求余效率高</strong>。在《剑指offer》分析中，双指针方法适合初级程序员，高级一点的写法，应该把整个函数解耦成两部分，一是判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作，这样无论是奇数在偶数前面的数组划分，还是能被3整除的数划分就可以直接求解了，提高代码重用性。</p>
</li>
<li>
<p>思路：双指针</p>
<ul>
<li>初始化双指针，<code>i = 0</code>，<code>j = len(nums) - 1</code></li>
<li>遍历数组，指针i从左向右找偶数，指针j从右向左找奇数</li>
<li>将偶数nums[i]和奇数nums[j]交换</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>] + [n <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>高级一点写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pBegin = <span class="number">0</span></span><br><span class="line">        pEnd = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> <span class="keyword">not</span> self.isEven(nums[pBegin]):</span><br><span class="line">                pBegin += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> self.isEven(nums[pEnd]):</span><br><span class="line">                pEnd -= <span class="number">1</span></span><br><span class="line">            nums[pBegin], nums[pEnd] = nums[pEnd], nums[pBegin]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n &amp; <span class="number">1</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="链表中倒数第k个结点"><a class="markdownIt-Anchor" href="#链表中倒数第k个结点"></a> 链表中倒数第k个结点</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题22）：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这类找链表结点的题，通常可以用<strong>双指针</strong>法解决，如链表中点，链表是否有环等。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>定义两个指针，pre和cur</li>
<li>第一个指针cur从链表的头指针开始遍历向前走k-1，第二个指针pre保持不动</li>
<li>从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当cur指针到达链表的为尾结点时，pre正好是倒数第k个结点。</li>
<li>这里要注意三个点：head为空、链表结点数少于k、k为0。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题24）：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有三种解法求解，双指针（最优）、辅助栈、递归。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/</a></p>
</blockquote>
</li>
<li>
<p>思路1：双指针</p>
<ul>
<li>定义3个指针，tmp，pre，cur，分别指向当前遍历结点、它的前一个结点和后一个结点</li>
<li>遍历链表，将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：辅助栈，遍历链表，将链表结点依次入栈，然后依次出栈，即实现反转链表</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        h = stack.pop()</span><br><span class="line">        p = h</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            h.next = stack.pop()</span><br><span class="line">            h = h.next</span><br><span class="line">        h.next = <span class="literal">None</span> <span class="comment">#防止链表循环</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路3：递归</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 这里的cur就是最后一个节点</span></span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">				<span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">				<span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">        head.next.next = head</span><br><span class="line">        <span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="合并两个排序链表"><a class="markdownIt-Anchor" href="#合并两个排序链表"></a> 合并两个排序链表</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题25）：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 链表长度 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-24"><a class="markdownIt-Anchor" href="#题解-24"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>初始化：
<ul>
<li>伪头结点new_head，结点cur指向new_head</li>
<li>双指针，p1和p2，分别指向两个链表的头结点</li>
</ul>
</li>
<li>循环合并：当p1或p2为空跳出
<ul>
<li>当<code>p1.val &lt; p2.val</code>时，cur的后继结点指向l1，且l1向前一步</li>
<li>当<code>p1.val &gt; p2.val</code>时，cur的后继结点指向l2，且l2向前一步</li>
<li>结点cur向前一步，即<code>cur = cur.next</code></li>
</ul>
</li>
<li>合并剩余尾部：跳出时有两种情况，即p1为空或p2为空
<ul>
<li>若p1不等于null，将p1剩余结点添加至cur后</li>
<li>否则，将p2剩余结点添加至cur后</li>
</ul>
</li>
<li>返回new_head.next</li>
</ul>
</li>
<li>
<p>时间复杂度：O(M+N)，M，N分别为两个链表的长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = new_head</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                cur.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = p1 <span class="keyword">if</span> p1 <span class="keyword">else</span> p2</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="树的子结构"><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h1>
<h2 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题26）：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> </span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line"> </span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-25"><a class="markdownIt-Anchor" href="#题解-25"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+包含判断+递归</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>第一步：在树A种找到和B的根节点的值一样的结点R（实质：树的遍历）</li>
<li>第二步：判断树A中以R为根节点的子树是不是包含和树B一样的结构</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)，M和N分别为两棵树的节点数</p>
</li>
<li>
<p>空间复杂度：O(M)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: TreeNode</span></span><br><span class="line"><span class="string">        :type B: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (A <span class="keyword">and</span> B):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> dfs(A.left, B.left) <span class="keyword">and</span> dfs(A.right, B.right)</span><br><span class="line">        <span class="keyword">return</span> dfs(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树的镜像"><a class="markdownIt-Anchor" href="#二叉树的镜像"></a> 二叉树的镜像</h1>
<h2 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题27）：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">镜像输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-26"><a class="markdownIt-Anchor" href="#题解-26"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：求树的镜像的过程其实就是在遍历树的同时交换非叶结点的左右子结点。（递归 or 辅助栈）</p>
</li>
<li>
<p>思路：前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子节点的左右子结点之后，就得到了树的镜像。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/</a></p>
</blockquote>
</li>
<li>
<p>递归法</p>
<ul>
<li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li>
<li>递归解析：
<ul>
<li>递归终止条件：当节点root为空的时候，返回null</li>
<li>递推工作：
<ul>
<li>初始化结点tmp，用于暂存root的左子结点</li>
<li>开启递归右子结点，并将返回值给root的左子结点</li>
<li>开启递归左子结点，并将返回值给root的右子结点</li>
</ul>
</li>
<li>返回当前结点root</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>辅助栈：</p>
<ul>
<li>利用栈（或队列）遍历树的所有节点node ，并交换每个node的左 / 右子节点。</li>
<li>算法流程：
<ul>
<li>特例处理：当root为空，返回root</li>
<li>初始化：栈，并加入根节点</li>
<li>循环交换：当栈stack为空时跳出
<ul>
<li>出栈：记为node</li>
<li>添加子结点：将node的左右子结点入栈</li>
<li>交换，交换node的左右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="对称的二叉树"><a class="markdownIt-Anchor" href="#对称的二叉树"></a> 对称的二叉树</h1>
<h2 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题28）：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-27"><a class="markdownIt-Anchor" href="#题解-27"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：递归 or 队列</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/</a></p>
<ul>
<li>对称二叉树的定义：对于树中 <strong>任意两个对称节点</strong> L和 R ，一定有：
<ul>
<li>L.val = R.val：即此两对称结点值相等</li>
<li>L.left.val = R.right.val：即L的左子结点和R的右子结点对称</li>
<li>L.right.val = R.left.val：即L的右子结点和R的左子结点对称</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归</p>
<ul>
<li>算法流程：
<ul>
<li><strong><code>isSymmetric(root)</code> ：</strong>
<ul>
<li>特例处理：若根节点为空，则直接返回root</li>
<li>返回值：<code>recur(root.left,root.right)</code></li>
</ul>
</li>
<li><strong><code>recur(L, R)</code> ：</strong>
<ul>
<li>终止条件:
<ul>
<li>当L和R同时越过叶结点，此树从顶至底的结点都对称，因此返回True</li>
<li>当L和R中只有一个越过叶结点，此树不对称，因此返回False</li>
<li>当节点L的值≠节点R的值，此树不对称，因此返回False</li>
</ul>
</li>
<li>递推工作：
<ul>
<li>判断两节点 L.left和 R.right是否对称，即 <code>recur(L.left, R.right)</code></li>
<li>判断两节点 L.right和 R.left是否对称，即 <code>recur(L.right, R.left)</code></li>
</ul>
</li>
<li><strong>返回值：</strong> 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(L, R)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (L <span class="keyword">or</span> R):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (L <span class="keyword">and</span> R) <span class="keyword">or</span> L.val != R.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(L.left, R.right) <span class="keyword">and</span> recur(L.right, R.left)</span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：队列</p>
<ul>
<li>特例处理：如果root为空，返回True</li>
<li>初始化：队列，并顺序加入root的左右结点</li>
<li>循环判断：当队列为空时跳出
<ul>
<li>出队列：依次记为left和right</li>
<li>如果left和right都为空，说明穿过叶子节点，继续执行</li>
<li>如果left或right其中一个为空，说明不对称，返回False</li>
<li>如果left和right的值不相等，说明不对称，返回False</li>
<li>入队：（成对加入）
<ul>
<li>加入left的左节点和righ的右节点</li>
<li>加入left的右节点和right的左节</li>
</ul>
</li>
</ul>
</li>
<li>返回True</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root.left, root.right]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            left = queue.pop(<span class="number">0</span>)</span><br><span class="line">            right = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">and</span> right) <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(left.left)</span><br><span class="line">            queue.append(right.right)</span><br><span class="line">            queue.append(left.right)</span><br><span class="line">            queue.append(right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="顺时针打印矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵"></a> 顺时针打印矩阵</h1>
<h2 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题29）：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制</p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-28"><a class="markdownIt-Anchor" href="#题解-28"></a> 题解</h2>
<ul>
<li>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</a></li>
<li>剑指offer：
<ul>
<li>当我们遇到一个复杂问题的时候，可以用图形来帮助我们思考。由于是以外圈到内圈的顺序依次打印，我们可以把矩阵想象成若干个圈，可以用一个循环来打印矩阵，每一次打印矩阵中的一个圈。</li>
<li>分析循环结束的条件。假设这个矩阵的行数是rows，列数是columns。打印第一圈的左上角的坐标是(1,1)，第二圈的左上角的坐标是(2,2)，以此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。</li>
<li>对一个5 * 5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2)。我们发现5 &gt; 2 * 2。对于一个6 * 6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为(2,2)。我们发现6 &gt; 2 * 2依然成立。于是我们可以得出，让循环继续的条件是columns &gt; startX * 2并且 rows &gt; startX * 2。</li>
<li>考虑如何打印一圈的功能。我们可以把打印一圈分为4步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或一列。不过值得注意的是，最后一圈有可能退化成只有一行，只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要4步。</li>
<li>分析打印时每一步的前提条件。第一步总是需要的，因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始起始行号至少大2，同时终止列号大于起始列号。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(MN）,M和N分别为矩阵的行列</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        l, r, t, b, res = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, len(matrix) - <span class="number">1</span>, []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[t][i]) <span class="comment"># left to right</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][r]) <span class="comment"># top to bottom</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[b][i]) <span class="comment"># right to left</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][l]) <span class="comment"># bottom to top</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="包含min函数的栈"><a class="markdownIt-Anchor" href="#包含min函数的栈"></a> 包含min函数的栈</h1>
<h2 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题30）：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：各函数的调用总次数不超过 20000 次</p>
</li>
</ul>
<h2 id="题解-29"><a class="markdownIt-Anchor" href="#题解-29"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，我们可以举例模拟压栈和弹出的几个数字，分析每次操作之后数据栈、辅助栈和最小值各是什么。让面试官更好地理解我们的思路。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</a></p>
</blockquote>
</li>
<li>
<p>思路：数据栈A压入数据，辅助栈B压入每次的最小元素（之前最小的元素和新压入栈的元素两者的较小值）</p>
<ul>
<li>eg：首先往空的数据栈A里压入数字3，显然现在3是最小值，我们也把这个最小值压入辅助栈B。接下来往数据栈A里压入数字4，由于4大于之前的最小值3，因此仍然往辅助栈B里压入3。第三步继续往数据栈A里压入数字2，由于数字2小于之前的最小值3，因此我们把最小值更新为2，并把2压入辅助栈B。同样压入数字1时，也要更新最小值，并把新的最小值1压入辅助栈B。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.B = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        y = self.A.pop()</span><br><span class="line">        <span class="keyword">if</span> y == self.B[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#栈的压入-弹出序列"></a> 栈的压入、弹出序列</h1>
<h2 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题31）：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列</li>
</ul>
</li>
</ul>
<h2 id="题解-30"><a class="markdownIt-Anchor" href="#题解-30"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：辅助栈</p>
<ul>
<li>面试时，需要确定一个序列和弹出序列的长度是否一致，序列中数字是否有重复。</li>
</ul>
</li>
<li>
<p>思路：判断一个序列是不是栈的弹出序列的规律。如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<ul>
<li>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(num) <span class="comment"># num 入栈</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> i &lt; len(popped)<span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[i]: <span class="comment"># 循环判断与出栈</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树"><a class="markdownIt-Anchor" href="#从上到下打印二叉树"></a> 从上到下打印二叉树</h1>
<h2 id="题目-30"><a class="markdownIt-Anchor" href="#题目-30"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题32I）：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-31"><a class="markdownIt-Anchor" href="#题解-31"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>队列</li>
<li>Python 中使用 collections 中的双端队列 deque() ，其 popleft() 方法可达到 O(1)， 时间复杂度；列表 list 的 pop(0) 方法时间复杂度为 O(N) 。</li>
<li>BFS通常借助队列</li>
</ul>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li><strong>扩展</strong>：如何广度优先遍历一个有向图？这同样也可以基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树</li>
<li><strong>举一反三</strong>：不管是广度优先遍历一个有向图还是一棵树，都要用到队列。第一步我们把起始起点（对树而言是根结点）放入队列。接下来每一次从队列的头部取出一个结点，遍历这个结点之后把它能到达的结点（对树而言是子结点）都依次放入队列。我们重复这个遍历过程，直到队列中的结点全部被遍历为止。</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都被打印出来为止。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树ii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树ii"></a> 从上到下打印二叉树II</h1>
<h2 id="题目-31"><a class="markdownIt-Anchor" href="#题目-31"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题32II）：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-32"><a class="markdownIt-Anchor" href="#题解-32"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>算法流程：</p>
<ul>
<li>特例处理：当前结点为空，则返回列表[]</li>
<li>初始化： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；
<ul>
<li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li>
<li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；
<ul>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ul>
</li>
<li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树iii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树iii"></a> 从上到下打印二叉树III</h1>
<h2 id="题目-32"><a class="markdownIt-Anchor" href="#题目-32"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题32III）：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-33"><a class="markdownIt-Anchor" href="#题解-33"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：之型打印二叉树，奇数层从左到右打印，偶数层从右到左打印，因此可以在面试题32II的基础上，判断层数是否是偶数层，如果是的话，把当前结点加在tmp头部，否则，加在尾部。或者，可以将偶数层的tmp结果倒序。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(tmp[::<span class="number">-1</span>] <span class="keyword">if</span> len(res) % <span class="number">2</span> <span class="keyword">else</span> tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h1>
<h2 id="题目-33"><a class="markdownIt-Anchor" href="#题目-33"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题33）：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例1： </span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：数组长度 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-34"><a class="markdownIt-Anchor" href="#题解-34"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>后序遍历定义：<code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li>二叉搜索树定义： 左子树中所有节点的值 &lt;根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
</li>
<li>
<blockquote>
<ul>
<li>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p>
</li>
<li>
<p>剑指offer：</p>
<ul>
<li><strong>相关题目</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和本题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根节点的值</li>
<li><strong>举一反三</strong>：如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归分治：根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p>
<ul>
<li>递归解析：
<ul>
<li><strong>终止条件：</strong> 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i≥j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，说明此子树结点数量≤1，无需判别正确性，因此直接返回true。</li>
<li>递推工作：
<ul>
<li>划分左右子树：遍历后序遍历[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时可划分出左子树区间[i,m-1]，右子树区间[m,j-1]，根节点索引j。</li>
<li><strong>判断是否为二叉搜索树：</strong>
<ul>
<li>左子树区间[i,m-1]内的所有结点都应小于postorder[j]。而上一步划分左右子树的步骤，已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间[m,j-1]内的所有结点都应大于postorder[j]。实现方式为遍历，当遇到小于等于postorder[j]的结点则跳出，否则可通过p=j判断是否为二叉搜索树。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> &amp;&amp;连接
<ul>
<li>p = j：判断此树是否正确</li>
<li>recur(i, m-1)：判断此树的左子树是否正确</li>
<li>recur(m, j - 1)：判断此树的右子树是否正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            m = p</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：单调辅助栈</p>
<ul>
<li>借助一个单调栈 stack存储值递增的节点；</li>
<li>每当遇到值递减的节点 r_i，则通过出栈来更新节点 r_i 的父节点 root ；</li>
<li>每轮判断 r_i和 root的值关系：
<ul>
<li>若 r_i &gt; root则说明不满足二叉搜索树定义，直接返回 false 。</li>
<li>若 r_i &lt; root则说明满足二叉搜索树定义，则继续遍历。</li>
</ul>
</li>
<li>算法流程：
<ul>
<li><strong>初始化：</strong> 单调栈 stack，父节点值 root = +∞ （初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；</li>
<li>倒序遍历 postorder：记每个节点为 r_i；
<ul>
<li><strong>判断：</strong> 若 r_i&gt;root，说明此后序遍历序列不满足二叉搜索树定义，直接返回 false；</li>
<li>更新父节点root，当栈不为空，且r_i &lt; stack.pop()时，循环执行出栈，并将出栈结点赋给root</li>
<li>入栈：将当前结点r_i入栈</li>
</ul>
</li>
<li>遍历完成，则说明满足二叉搜索树定义，返回true</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, root = [], float(<span class="string">"inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span>(stack <span class="keyword">and</span> postorder[i] &lt; stack[<span class="number">-1</span>]):</span><br><span class="line">                root = stack.pop()</span><br><span class="line">            stack.append(postorder[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h1>
<h2 id="题目-34"><a class="markdownIt-Anchor" href="#题目-34"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题34）：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</li>
</ul>
<h2 id="题解-35"><a class="markdownIt-Anchor" href="#题解-35"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点的值得和刚好等于输入的整数，则当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父节点。因此我们在函数退出之前要再路径上删除当前结点并减去当前结点的值，以确保返回父节点时路径刚好是从根节点到父节点的路径。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+路径记录</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>pathSum(root, sum)</code> 函数：</strong>
<ul>
<li><strong>初始化：</strong> 结果列表 <code>res</code> ，路径列表 <code>path</code> 。</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li><strong><code>recur(root, tar) 函数：</code></strong>
<ul>
<li><strong>递推参数：</strong> 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</li>
<li><strong>终止条件：</strong> 若节点 <code>root</code> 为空，则直接返回。</li>
<li><strong>递推工作</strong>
<ul>
<li>路径更新： 将当前节点值 <code>root.val</code> 加入路径 <code>path</code> ；</li>
<li>目标值更新： <code>tar = tar - root.val</code>（即目标值 <code>tar</code> 从 <code>sum</code> 减至 00 ）；</li>
<li>路径记录： 当 ① <code>root</code> 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 <code>path</code> 加入 <code>res</code> 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop()</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>值得注意的是</strong>，记录路径时若直接执行 <code>res.append(path)</code> ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。正确做法：<code>res.append(list(path))</code> ，相当于复制了一个 path 并加入到 res 。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, tar)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">            recur(root.left, tar)</span><br><span class="line">            recur(root.right, tar)</span><br><span class="line">            path.pop()</span><br><span class="line">        recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="复杂链表的复制"><a class="markdownIt-Anchor" href="#复杂链表的复制"></a> 复杂链表的复制</h1>
<h2 id="题目-35"><a class="markdownIt-Anchor" href="#题目-35"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题35：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
</li>
</ul>
<h2 id="题解-36"><a class="markdownIt-Anchor" href="#题解-36"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：在这里，复制的意思是指 <strong>深拷贝</strong>（Deep Copy），类似我们常用的“复制粘贴”，事实上，与此对应的还有 浅拷贝，它们的区别是：</p>
<ul>
<li><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</strong>。</li>
<li><strong>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</strong>。</li>
</ul>
</li>
<li>
<p>思路：这里考虑深度优先搜索和优化迭代两种方法</p>
<ul>
<li>
<p>深度优先搜索（DFS）</p>
<ul>
<li>
<p>从头结点head开始拷贝</p>
</li>
<li>
<p>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</p>
</li>
<li>
<p>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</p>
</li>
<li>
<p>使用递归拷贝所有的 <code>next</code> 结点，再递归拷贝所有的 <code>random</code> 结点。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited  = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line"></span><br><span class="line">            <span class="comment">#创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>优化迭代</p>
<ul>
<li>
<p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个链表结点的旁边拷贝，比如 A-&gt;B-&gt;C 变成 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’，最后返回 A’-&gt;B’-&gt;C’。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            new_node = Node(cur.val,<span class="literal">None</span>,<span class="literal">None</span>)   <span class="comment"># 克隆新结点</span></span><br><span class="line">            new_node.next = cur.next</span><br><span class="line">            cur.next = new_node   <span class="comment"># 克隆新结点在cur 后面</span></span><br><span class="line">            cur = new_node.next   <span class="comment"># 移动到下一个要克隆的点</span></span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 链接random</span></span><br><span class="line">            cur.next.random = cur.random.next <span class="keyword">if</span> cur.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        cur_old_list = head <span class="comment"># 将两个链表分开</span></span><br><span class="line">        cur_new_list = head.next</span><br><span class="line">        new_head = head.next</span><br><span class="line">        <span class="keyword">while</span> cur_old_list:</span><br><span class="line">            cur_old_list.next = cur_old_list.next.next</span><br><span class="line">            cur_new_list.next = cur_new_list.next.next <span class="keyword">if</span> cur_new_list.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur_old_list = cur_old_list.next</span><br><span class="line">            cur_new_list = cur_new_list.next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#二叉搜索树与双向链表"></a> 二叉搜索树与双向链表</h1>
<h2 id="题目-36"><a class="markdownIt-Anchor" href="#题目-36"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题36）：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
</li>
</ul>
<h2 id="题解-37"><a class="markdownIt-Anchor" href="#题解-37"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：中序遍历</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</a></p>
</blockquote>
</li>
<li>
<p>思想：</p>
<ul>
<li>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</li>
<li>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：
<ul>
<li><strong>排序链表：</strong> 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点；</li>
<li><strong>双向链表</strong>：在构建相邻节点（设前驱节点pre，当前结点cur）关系时，应该满足<code>pre.right = cur</code>，<code>cur.left = pre</code></li>
<li><strong>循环链表</strong>： 设链表头节点 head 和尾节点 tail，则应构建 <code>head.left = tail</code>和 <code>tail.right = head。</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>dfs(cur):</code></strong> 递归法中序遍历；
<ul>
<li><strong>终止条件：</strong> 当节点 cur为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 <code>dfs(cur.left)</code> ；</li>
<li><strong>构建链表：</strong>
<ul>
<li><strong>当 pre为空时：</strong> 代表正在访问链表头节点，记为 head 。</li>
<li><strong>当 pre 不为空时</strong>： 修改双向节点引用，即 pre.right = cur， cur.left = pre。</li>
<li><strong>保存cur</strong>：更新pre = cur，即节点cur是后继节点的pre</li>
</ul>
</li>
<li>递归右子树，即<code>dfs(cur.left)</code></li>
</ul>
</li>
<li><strong><code>treeToDoublyList(root)：</code></strong>
<ul>
<li><strong>特例处理：</strong> 若节点 root 为空，则直接返回；</li>
<li><strong>初始化</strong>： 空节点 pre ；</li>
<li><strong>转化为双向链表</strong>： 调用 <code>dfs(root)</code> ；</li>
<li>构建循环链表： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head和 pre 的双向节点引用即可。</li>
<li>返回值： 返回链表的头节点 head 即可。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left) <span class="comment"># 递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> self.pre: <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 记录头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存 cur</span></span><br><span class="line">            dfs(cur.right) <span class="comment"># 递归右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 牛客网解答</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree.left <span class="keyword">and</span> <span class="keyword">not</span> pRootOfTree.right:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        <span class="comment"># 处理左子树</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        left=pRootOfTree.left</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 连接根与左子树最大结点</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">while</span>(left.right):</span><br><span class="line">                left=left.right</span><br><span class="line">            pRootOfTree.left,left.right=left,pRootOfTree</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 处理右子树</span></span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        right=pRootOfTree.right</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 连接根与右子树最小结点</span></span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">while</span>(right.left):</span><br><span class="line">                right=right.left</span><br><span class="line">            pRootOfTree.right,right.left=right,pRootOfTree</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree.left):</span><br><span class="line">            pRootOfTree=pRootOfTree.left</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="序列化二叉树"><a class="markdownIt-Anchor" href="#序列化二叉树"></a> 序列化二叉树</h1>
<h2 id="题目-37"><a class="markdownIt-Anchor" href="#题目-37"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题37）：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-38"><a class="markdownIt-Anchor" href="#题解-38"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：层序遍历 + BFS</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>序列化：借助队列，对二叉树做层序遍历，并将越过叶节点的 null也打印出来。
<ul>
<li>特例处理：若root为空，直接返回空列表</li>
<li>初始化：队列queue（包含根节点root）；序列化列表res</li>
<li>层序遍历：当queue为空时跳出：
<ul>
<li>节点出队，记为node</li>
<li>若node不为空，① 打印字符串 node.val，② 将左、右子节点加入 queue ；</li>
<li>否则（若 node为空）：打印字符串 <code>&quot;null&quot;</code></li>
</ul>
</li>
<li><strong>返回值：</strong> 拼接列表（用 <code>','</code> 隔开，首尾添加中括号）。</li>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
</li>
<li>反序列化：利用队列按层构建二叉树，借助一个指针 i指向节点 node的左、右子节点，每构建一个 node 的左、右子节点，指针 i就向右移动 1 位。
<ul>
<li>特例处理：若data为空，直接返回null</li>
<li>初始化： 序列化列表 vals（先去掉首尾中括号，再用逗号隔开），指针 i = 1，根节点 root（值为 vals[0] ），队列 queue（包含 root）；</li>
<li>按层构建：当queue为空时跳出：
<ul>
<li>节点出队，记为node</li>
<li>构建 node 的左子节点：node.left的值为 vals[i]，并将 node.left入队；</li>
<li>执行 i+=1 ；</li>
<li>构建 node 的右子节点：node.right的值为 vals[i] ，并将 node.right入队；</li>
<li>执行 i+=1 ；</li>
</ul>
</li>
<li>返回值： 返回根节点 root 即可</li>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">','</span>.join(res) + <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="字符串的排列"><a class="markdownIt-Anchor" href="#字符串的排列"></a> 字符串的排列</h1>
<h2 id="题目-38"><a class="markdownIt-Anchor" href="#题目-38"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题38）：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= s 的长度 &lt;= 8</p>
</li>
</ul>
<h2 id="题解-39"><a class="markdownIt-Anchor" href="#题解-39"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>求所有可能出现在第一个位置的字符,即把第一个字符和后面所有的字符进行交换</li>
<li>固定第一个字符，求后面所有字符的排列，这时候，可以把后面的所有字符分为两部分，后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N!)</p>
</li>
<li>
<p>空间复杂度：O(N^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [s]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ch = s[i] <span class="comment">#取出s中每一个字符</span></span><br><span class="line">                dic = s[:i] + s[i + <span class="number">1</span> :]</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> self.permutation(dic):</span><br><span class="line">                    res.append(ch + x) <span class="comment">#将ch 和子问题的解依次组合</span></span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网</p>
<ul>
<li>输入一个字符串,<strong>按字典序打印</strong>出该字符串中字符的所有排列。</li>
<li>输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = len(ss)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [ss]</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ch = ss[i]</span><br><span class="line">            tmp = ss[:i] + ss[i + <span class="number">1</span> :]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self.Permutation(tmp):</span><br><span class="line">                res.append(ch + x)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(res)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#数组中出现次数超过一半的数字"></a> 数组中出现次数超过一半的数字</h1>
<h2 id="题目-39"><a class="markdownIt-Anchor" href="#题目-39"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题39）：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-40"><a class="markdownIt-Anchor" href="#题解-40"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，要注意以下问题：</p>
<ul>
<li>是否可以修改数组？</li>
<li>特例考虑，数组为空，或数组中不存在元素出现的次数超过数组长度一半</li>
</ul>
</li>
<li>
<p>思路：有三种思路</p>
<ul>
<li>第一种思路，对数组排序，数组n/2位置就是所求的数字。
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
<li>第二种思路，哈希表，遍历一遍数组，记录每个元素出现的次数，返回次数超过数组长度一半的数字
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>第三种思路，<strong>投票法</strong>，数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减一。如果次数为零，我们需要保存下一个数字，并把次数设置为1。由于我们要找的数字出现的次数比其他所有数字出现的次数和要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#投票法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        vote = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote == <span class="number">0</span>:</span><br><span class="line">                x = num</span><br><span class="line">            vote += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#哈希表</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                dic[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dic[num] &gt; len(numbers) // <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="最小的k个数"><a class="markdownIt-Anchor" href="#最小的k个数"></a> 最小的k个数</h1>
<h2 id="题目-40"><a class="markdownIt-Anchor" href="#题目-40"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题40）：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解排序"><a class="markdownIt-Anchor" href="#题解排序"></a> 题解（排序）</h2>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
</search>
