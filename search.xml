<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指offer1</title>
    <url>/2020/06/13/%E5%89%91%E6%8C%87offer1/</url>
    <content><![CDATA[<h1 id="数据流中的中位数"><a class="markdownIt-Anchor" href="#数据流中的中位数"></a> 数据流中的中位数</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题41）：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line"></span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line"></span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line"></span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：最多会对 <code>addNum、findMedia</code>进行 <code>50000</code> 次调用。</p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：优先队列/堆</p>
<ul>
<li><strong>什么是优先队列</strong>？
<ul>
<li>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
</li>
<li>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
</li>
<li>由于删除堆顶元素时的时间复杂度为 O(logN)，因此在优先队列中入队和出队操作的时间复杂度也是 O(logN)。</li>
</ul>
</li>
<li><strong>注意：Python 中没有大顶堆，只能将值取负保存在小顶堆来模拟</strong>。为了方便理解，将堆用优先队列表示。即<strong>Python 中 heapq 模块是小顶堆</strong>。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。</li>
</ul>
</li>
<li>
<p>思路：</p>
<ul>
<li>首先，建立一个小顶堆A和大顶堆B，各保存列表的一半元素，且规定：
<ul>
<li>A保存较大的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
<li>B保存较小的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
</ul>
</li>
<li>然后，中位数可仅根据A，B的堆顶元素计算得到。
<ul>
<li>小顶堆A（存储较大的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>m</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_m,a_{m-1},...,a_3,a_2,a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
<li>大顶堆B（存储较小的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b1,b2,b3,...,b_{n-1},b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">b</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
</ul>
</li>
<li>设共有N = m + n个元素，规定添加元素时保证：
<ul>
<li>m = n + 1 = （N + 1）/ 2 （N为奇数）</li>
<li>m = n = N / 2（N为偶数）</li>
<li>当m≠n，中位数是a1</li>
<li>当m=n，中位数是（a1 + b1）/ 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>设元素总数为 N = m + n ，其中 m和 n分别为 A和 B中的元素个数。</li>
<li><strong><code>addNum(num)</code> 函数</strong>
<ol>
<li>当 m = n（即 N为 偶数）：需向 A添加一个元素。实现方法：将新元素 num插入至 B ，再将 B堆顶元素插入至 A。</li>
<li>当m≠n（即N为奇数）：需向B添加一个元素。实现方法将新元素插入至A，再将A堆顶元素插入至B。
<ul>
<li>假设插入数字 num遇到情况 1. 。由于 num可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B保存较小一半。</li>
</ul>
</li>
</ol>
</li>
<li><strong><code>findMedian()</code> 函数：</strong>
<ul>
<li>当m≠n，（N为奇数）：则中位数是A堆顶的元素</li>
<li>当m=n，（N为偶数）：则中位数是（A堆顶元素 + B堆顶元素） / 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：</p>
<ul>
<li>查找中位数O(1)：获取堆顶元素使用O(1)时间</li>
<li>添加数字O(logN)：堆的插入和弹出操作需要O(logN)时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="keyword">from</span> heapq <span class="keyword">import</span> *
<span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        <span class="string">"""
        initialize your data structure here.
        """</span>
        self.A = [] <span class="comment">#小顶堆，保存较大的一半</span>
        self.B = [] <span class="comment">#大顶堆，保存较小的一半</span>

    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span>
        <span class="string">"""
        :type num: int
        :rtype: None
        """</span>
        <span class="keyword">if</span> len(self.A) != len(self.B):
            heappush(self.B, -heappushpop(self.A, num))
        <span class="keyword">else</span>:
            heappush(self.A, -heappushpop(self.B, -num))

    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span>
        <span class="string">"""
        :rtype: float
        """</span>
        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span>
&lt;!--￼<span class="number">1</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="连续子数组的最大和"><a class="markdownIt-Anchor" href="#连续子数组的最大和"></a> 连续子数组的最大和</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题42）：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li><strong>状态定义</strong>：设动态规划列表dp，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
<ul>
<li>为何定义最大和 dp[i]中必须包含元素 nums[i]：保证 dp[i]递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。</li>
</ul>
</li>
<li><strong>转移方程</strong>：若dp[i-1]≤0，说明dp[i -1]对dp[i]产生负贡献，即dp[i-1] + nums[i]还不如nums[i]本身大。
<ul>
<li>当dp[i-1]≤ 0时：执行dp[i] = nums[i]</li>
<li>当dp[i-1]&gt;0时：执行dp[i] = dp[i-1] + nums[i]</li>
</ul>
</li>
<li><strong>初始状态</strong>：dp[0] = nums[0]，即以nums[0]结尾的连续子数组最大和为 nums[0]。</li>
<li><strong>返回值：</strong> 返回 dp 列表中的最大值，代表全局最大值。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        max_sum = nums[<span class="number">0</span>] <span class="comment">#保存连续子数组最大和</span>
        cur_sum = nums[<span class="number">0</span>] <span class="comment">#保存当前连续子数组最大和</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):
            <span class="keyword">if</span> nums[i] &gt; cur_sum + nums[i]:
                cur_sum = nums[i]
            <span class="keyword">else</span>:
                cur_sum = cur_sum + nums[i]
            max_sum = max(cur_sum, max_sum)
        <span class="keyword">return</span> max_sum
&lt;!--￼<span class="number">3</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="1~n整数中1出现的次数"><a class="markdownIt-Anchor" href="#1~n整数中1出现的次数"></a> 1~n整数中1出现的次数</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题43）：输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">1 ≤ n &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：数字规律  + 递归</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>用一个稍微大一点的数字：21345为例。我们把从1到21345的所有数字分为两段，一段是从1到1345，另一段是从1346到21345。
<ul>
<li>原因：因为把21345的最高位去掉就变成1345，便于采用递归思路。</li>
</ul>
</li>
<li>先看从1346到21345中1出现的次数。1的出现分为两种情况。
<ul>
<li>首先分析1出现在最高位（例子是万位）的情况。从1346到21345的数字中，1出现在10000~19999这10000个数字的万位，一共出现了10000（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)个。
<ul>
<li>值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000个。对于万位是1的数字比如输入12345，1只出现在10000~12345的万位，出现的次数不是10000次，而是2346次，也就是除去最高数字之后剩下的数字再加上1（即2345+1=2346次）</li>
</ul>
</li>
<li>接着分析1出现在除最高位之外的其他四位数中的情况。例子中1346<sub>21345这20000个数字中后4位中1出现的次数是2000次。由于最高位是2，我们可以再把13456</sub>21345分为两段，1346<sub>11345和11346</sub>21345。每一段剩下4位数字中，选择其中其中一位是1，其余三位可以在0~9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2000次。</li>
<li>从1~1345中1的出现次数，可以用递归求得。</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)，循环内的计算操作使用 O(1)时间；循环次数为数字 n的位数，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{10}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        num_s = str(n) 
        high = int(num_s[<span class="number">0</span>])  
        Pow = <span class="number">10</span> ** (len(num_s) - <span class="number">1</span>) 
        last = n - high * Pow
        
        <span class="keyword">if</span> high == <span class="number">1</span>:
            <span class="keyword">return</span> self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last) + last + <span class="number">1</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> Pow + high * self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last)
&lt;!--￼<span class="number">5</span>--&gt;
输入：n = <span class="number">3</span>
输出：<span class="number">3</span>

输入：n = <span class="number">11</span>
输出：<span class="number">0</span>
&lt;!--￼<span class="number">6</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="把数组排成最小的数"><a class="markdownIt-Anchor" href="#把数组排成最小的数"></a> 把数组排成最小的数</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题45）：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<code>0 &lt; nums.length &lt;= 100</code></p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：排序规则</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>根据题目要求，两个数字m和n能拼接成数字mn和nm。如果mn&lt;nm，那么我们应该打印出mn，也就是m应该排在n的前面，我们定义此时m小于n；反之，如果nm&lt;mn，我们定义n小于m。如果mn=nm，m等于n。在下文中符号&quot;&lt;&quot;，&quot;&gt;“和”=&quot;表示常规意义的数值的大小关系，而文字“大于”、“小于”和等于表示我们新定义的大小关系。</li>
<li>接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字mn和nm并比较它们的大小。直接用数值计算不难办到，但需要考虑到一个潜在的问题就是m和n都在int能表达的范围内，但把它们拼起来的数字mn和nm用int表示就有可能溢出了，所以还隐藏大数问题。</li>
<li>一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外，由于把数字m和n拼接起来得到mn和nm，它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>特例判断：当数组为空，返回空字符串</li>
<li>将数组每个元素依次转换为字符串</li>
<li>两两组合，小的放前面，再拼接起来，如5+3&gt;3+5，把3放5前面</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; nums[j] + nums[i]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把数字翻译成字符串"><a class="markdownIt-Anchor" href="#把数字翻译成字符串"></a> 把数字翻译成字符串</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题46）：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：0 &lt;= num &lt; 2^31</p>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li>记数字num第i位数字为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，数字num的位数为n
<ul>
<li>例如，num=12258，n=5，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i]代表以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为结尾的数字的翻译方案数量。</li>
<li><strong>转移方程</strong>：若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>组成的两位数字可以被翻译，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>，否则，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>
<ul>
<li>可被翻译的两位数区间：当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{i-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，组成的两位数是无法被翻译的，（例如：00，01…)，因此区间为[10,25]。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i -1] + dp[i -2]， 10x_{i-1} + x_i∈[10,25]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>99</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]， 10x_{i-1} + x_i ∈[0,10)∪(25,99]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
<li><strong>初始状态</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0] = dp[1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即无数字和第1位数字的翻译方法数均为1</li>
<li><strong>返回值</strong>：dp[n]</li>
</ul>
</li>
<li>
<p>无数字情况 dp[0] = 1 从何而来？</p>
<ul>
<li>当 num第 1, 2 位的组成的数字∈[10,25] 时，显然应有 2种翻译方法，即 dp[2] = dp[1] + dp[0] = 2 ，而显然 dp[1] = 1，因此推出 dp[0] = 1 。</li>
</ul>
</li>
<li>
<p>为方便获取数字的各位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，考虑先将数字 num转化为字符串 s ，通过遍历 s 实现动态规划。</p>
</li>
<li>
<p>通过字符串切片s[i-2:i]获取组合数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">10x_{i-1} + x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.852771em;vertical-align:-0.208331em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，通过对比字符串ASCII码判断字符串对应数字区间</p>
</li>
<li>
<p>空间优化：由于dp[i]只和dp[i-1]有关，因此可使用两个变量 a, b分别记录 dp[i], dp[i - 1]，两变量交替前进即可。此方法可省去 dp列表使用的 O(N)的额外空间。</p>
</li>
<li>
<p>时间复杂度：O(N)， N为字符串 s的长度（即数字 num的位数log(num) ），其决定了循环次数。</p>
</li>
<li>
<p>空间复杂度：O(N)，字符串使用O(N)额外空间</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span>
        <span class="string">"""
        :type num: int
        :rtype: int
        """</span>
        s = str(num)
        a = b = <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(s) + <span class="number">1</span>):
            a, b = (a + b <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i - <span class="number">2</span>:i] &lt;= <span class="string">"25"</span> <span class="keyword">else</span> a), a
        <span class="keyword">return</span> a
&lt;!--￼<span class="number">10</span>--&gt;
输入: 
[
  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],
  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],
  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]
]
输出: <span class="number">12</span>
解释: 路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">5</span>→<span class="number">2</span>→<span class="number">1</span> 可以拿到最多价值的礼物
&lt;!--￼<span class="number">11</span>--&gt;

</code></pre>
</li>
<li>
<p>以上代码逻辑清晰，和转移方程直接对应，但仍可提升效率：当 grid矩阵很大时， i = 0 或 j = 0的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid)</span>:</span>
        <span class="string">"""
        :type grid: List[List[int]]
        :rtype: int
        """</span>
        m, n = len(grid), len(grid[<span class="number">0</span>])
        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n): <span class="comment"># 初始化第一行</span>
            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m): <span class="comment"># 初始化第一列</span>
            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):
                grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])
        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]
&lt;!--￼<span class="number">12</span>--&gt;
输入: <span class="string">"abcabcbb"</span>
输出: <span class="number">3</span> 
解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。

输入: <span class="string">"bbbbb"</span>
输出: <span class="number">1</span>
解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。

输入: <span class="string">"pwwkew"</span>
输出: <span class="number">3</span>
解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。
     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。
&lt;!--￼<span class="number">13</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="丑数"><a class="markdownIt-Anchor" href="#丑数"></a> 丑数</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题49）：我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong>1690</li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<p>思路：创建数组保存已经找到的丑数，用空间换时间。丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “丑数 == 某较小丑数 × 某因子” （例如：10=5×2）。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></li>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/%EF%BC%88%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0%E5%8F%82%E8%80%83%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/（思路描述参考）</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>,n):
            n2 = dp[a] * <span class="number">2</span>
            n3 = dp[b] * <span class="number">3</span>
            n5 = dp[c] * <span class="number">5</span>
            dp[i] = min(n2, n3, n5)
            <span class="keyword">if</span> dp[i] == n2:
                a += <span class="number">1</span>
            <span class="keyword">if</span> dp[i] == n3:
                b += <span class="number">1</span>
            <span class="keyword">if</span> dp[i] == n5:
                c += <span class="number">1</span>
        <span class="keyword">return</span> dp[<span class="number">-1</span>]
&lt;!--￼<span class="number">15</span>--&gt;
s = <span class="string">"abaccdeff"</span>
返回 <span class="string">"b"</span>

s = <span class="string">""</span> 
返回 <span class="string">" "</span>
&lt;!--￼<span class="number">16</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题51）：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把数组分隔成子数组，先统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个排序的过程实际上就是<strong>归并排序</strong>。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, start, mid, end)</span>:</span></span><br><span class="line">            i, j, temp = start, mid + <span class="number">1</span>, []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                    temp.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.cnt += mid - i + <span class="number">1</span></span><br><span class="line">                    temp.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                temp.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                nums[start + i] = temp[i]</span><br><span class="line">                    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            mergeSort(nums, start, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">            merge(nums, start, mid,  end)</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br></pre></td></tr></table></figure>
<h1 id="两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#两个链表的第一个公共节点"></a> 两个链表的第一个公共节点</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>难度：简单</li>
<li>题目（leetcode-面试题52）：输入两个链表，找出它们的第一个公共节点。</li>
<li>注意：
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针</p>
</li>
<li>
<p>思路：有四种方法</p>
<ol>
<li>可以暴力求解，分别遍历两个链表，看是否有重合的结点，时间复杂度：O(mn)</li>
<li>利用辅助栈：可以将两个链表放入栈中，比较栈顶元素（链表长度相同）</li>
<li>分别得到两个链表的长度，计算链表差n，然后设置双指针，让长链表先走n步，然后两个链表一起走，看是否有相同的点。</li>
<li>设置双指针指向两个链表头，然后一起走，指针A遍历完一个链A后，指向另一个链B的头，指针B同理，直到两个指针指向的结点相同，即若存在公共节点则返回公共节点，若不存在，两个指针都会指向null节点。
<ul>
<li>假设链表A长度是m，链表B是n，公共部分是b，那么走过m+n+b步之后一定会相遇，返回结果。 如果没有公共部分，b=0， 那么走过m+n都指向None，返回None</li>
</ul>
</li>
</ol>
</li>
<li>
<p>时间复杂度：O(m+n)，m，n分别为两个链表的长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment">#思路4</span>
<span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span>
        <span class="string">"""
        :type head1, head1: ListNode
        :rtype: ListNode
        """</span>
        l1 = headA
        l2 = headB
        <span class="keyword">while</span> l1 != l2:
            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> headB
            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> headA
        <span class="keyword">return</span> l1
&lt;!--￼<span class="number">19</span>--&gt;
输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span>
输出: <span class="number">2</span>

输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span>
输出: <span class="number">0</span>
&lt;!--￼<span class="number">20</span>--&gt;

</code></pre>
</li>
<li>
<p>简化代码：<code>helper()</code> 函数旨在查找数字 tar在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。即<strong>找target的右边界和target-1的右边界。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tar)</span>:</span></span><br><span class="line">            i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= tar: i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> helper(target) - helper(target - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#0~n-1中缺失的数字"></a> 0~n-1中缺失的数字</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题53II）：<strong>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内</strong>。在范围0～n-1内的n个数字中<strong>有且只有一个数字不在该数组中</strong>，请找出这个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：二分法，<strong>排序数组中的搜索问题，首先想到 二分法 解决。</strong></p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>根据题意，数组可以按照以下规则划分为两部分。
<ul>
<li>左子数组：nums[i] = i</li>
<li>右子数组：nums[i] ≠ i</li>
</ul>
</li>
<li>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>初始化左边界，i = 0， 右边界， j = len(nums) - 1，代表闭区间[i,j]。</li>
</ul>
</li>
<li>
<p>循环二分：当i &lt;= j时循环（当闭区间i，j为空时，跳出）</p>
<ul>
<li>计算中点 m = (i + j) // 2，其中 “//” 为向下取整除法；</li>
<li>若 nums[m] = m ，则 “右子数组的首位元素” 一定在闭区间 [m + 1, j]中，因此执行 i = m + 1；</li>
<li>若 nums[m] ≠ m ，则 “左子数组的末位元素” 一定在闭区间 [i, m - 1]中，因此执行 j = m - 1；</li>
<li><strong>返回值：</strong> 跳出时，变量 i和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt;= j:
            m = (i + j) // <span class="number">2</span>
            <span class="keyword">if</span> nums[m] == m:
                i = m + <span class="number">1</span>
            <span class="keyword">else</span>:
                j = m - <span class="number">1</span>
        <span class="keyword">return</span> i
&lt;!--￼<span class="number">23</span>--&gt;
输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,null,<span class="number">2</span>], k = <span class="number">1</span>
   <span class="number">3</span>
  / \
 <span class="number">1</span>   <span class="number">4</span>
  \
   <span class="number">2</span>
输出: <span class="number">4</span>

输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,null,null,<span class="number">1</span>], k = <span class="number">3</span>
       <span class="number">5</span>
      / \
     <span class="number">3</span>   <span class="number">6</span>
    / \
   <span class="number">2</span>   <span class="number">4</span>
  /
 <span class="number">1</span>
输出: <span class="number">4</span>
&lt;!--￼<span class="number">24</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉树的深度"><a class="markdownIt-Anchor" href="#二叉树的深度"></a> 二叉树的深度</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55I）：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：后序遍历/层序遍历</p>
<ul>
<li>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；
<ul>
<li><strong>常见的 DFS ：</strong> 先序遍历、中序遍历、后序遍历；</li>
<li><strong>常见的 BFS ：</strong> 层序遍历（即按层遍历）。</li>
</ul>
</li>
<li>树的后序遍历/深度优先搜索往往利用<strong>递归或栈</strong>。
<ul>
<li><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</li>
</ul>
</li>
<li>树的层序遍历 / 广度优先搜索往往利用 <strong>队列</strong> 实现。
<ul>
<li><strong>关键点：</strong> 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>思路：<strong>递归-后序遍历</strong></p>
<ul>
<li><strong>终止条件</strong>：当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li><strong>递推工作</strong>：本质上是对树做后序遍历
<ul>
<li>计算结点<code>root</code>的左子树深度，即调用<code>maxDepth(root.left)</code></li>
<li>计算节点 <code>root</code> 的 <strong>右子树的深度</strong> ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回 <strong>此树的深度</strong> ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span>
&lt;!--￼<span class="number">26</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55II）：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line"> </span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>1 &lt;= 树的结点个数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<ul>
<li>
<p><strong>思路</strong>：</p>
<ul>
<li>先序遍历+判断深度（自顶向下），比较容易想到。
<ul>
<li>构造一个depth函数递归计算二叉树的左右子树高度</li>
<li>比较左右子树高度差是否≤1，判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(NlogN)，最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。</p>
<ul>
<li>满二叉树高度的复杂度 O(log N) ，将满二叉树按层分为 log (N+1) 层；</li>
<li>总体时间复杂度 == 每层执行复杂度× 层数复杂度 = O(N×logN) 。</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)

    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span>
&lt;!--￼<span class="number">28</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数组中数字出现的次数"><a class="markdownIt-Anchor" href="#数组中数字出现的次数"></a> 数组中数字出现的次数</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题56I）：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：2 &lt;= nums.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<blockquote>
<ul>
<li>异或类型题目的总结：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>异或有这样的性质：
<ul>
<li>0<sup>a=a，a</sup>a=0，a<sup>a</sup>a=a</li>
</ul>
</li>
<li>设所求的两个数为x,y，先将所有元素都异或，得到结果r，r其实就是x与y的异或。由于x!=y，r肯定不为0，即在其二进制形式中存在1，我们从右向左找第一个为1的位置（其实只要能找到任意一位为1的位置即可），记录其位置为i。这样通过i便可将数组分为两部分，一部分元素的二进制在i处为0，另一部分为1。x与y必定分散在这两部分中，而且相同的数都会在同一部分。将这两部分分别异或，结果便为x，y。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        ret = <span class="number">0</span>  <span class="comment"># 所有数字异或的结果</span>
        a = <span class="number">0</span>
        b = <span class="number">0</span>
        <span class="keyword">for</span> n <span class="keyword">in</span> nums:
            ret ^= n
        <span class="comment"># 找到第一位不是0的</span>
        h = <span class="number">1</span>
        <span class="keyword">while</span>(ret &amp; h == <span class="number">0</span>):
            h &lt;&lt;= <span class="number">1</span>
        <span class="keyword">for</span> n <span class="keyword">in</span> nums:
            <span class="comment"># 根据该位是否为0将其分为两组</span>
            <span class="keyword">if</span> (h &amp; n == <span class="number">0</span>):
                a ^= n
            <span class="keyword">else</span>:
                b ^= n

        <span class="keyword">return</span> [a, b]
&lt;!--￼<span class="number">30</span>--&gt;
输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]
输出：<span class="number">4</span>

输入：nums = [<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>]
输出：<span class="number">1</span>
&lt;!--￼<span class="number">31</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="和为s的两个数字"><a class="markdownIt-Anchor" href="#和为s的两个数字"></a> 和为s的两个数字</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57I）：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针 / 字典</p>
</li>
<li>
<p>思路：双指针：</p>
<ul>
<li>根据题意，是递增排序数组，可以初始化两个指针，分别指向数组的第一个元素和最后一个元素，即<code>i = 0, j = len(nums) - 1</code></li>
<li>当i &lt; j时，判断nums[i] + nums[j]的和是否等于target，如果等于，则输出这两个数，如果大于，将j前移。如果小于，将i后移。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """</span>
        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            s = nums[i] + nums[j] 
            <span class="keyword">if</span> s == target:
                <span class="keyword">return</span> nums[i], nums[j]
            <span class="keyword">elif</span> s &lt; target:
                i += <span class="number">1</span>
            <span class="keyword">else</span>:
                j -= <span class="number">1</span>
        <span class="keyword">return</span> <span class="literal">None</span>
&lt;!--￼<span class="number">33</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="和为s的连续正数序列"><a class="markdownIt-Anchor" href="#和为s的连续正数序列"></a> 和为s的连续正数序列</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57II）：输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= target &lt;= 10^5</p>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p>思路：双指针滑动窗口法</p>
<ul>
<li>针对目前这个题，我们可以把左指针i指向1，右指针j指向2，然后就能计算出当前窗口范围各数字的和，<code>cur_sum = sum(list(range(i,j+1)))</code>，如果cur_sum小于target，说明当前窗口数字之和过小，这时候咱们可以令j += 1，这样我们的新窗口就向右边扩大了。同样的道理，如果cur_sum大于target，这说明我们当前窗口数字之和过大，这时候就令i += 1，这样窗口的左边界就向右边移动了一个单位，就使得窗口变小了。</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target)</span>:</span>
        <span class="string">"""
        :type target: int
        :rtype: List[List[int]]
        """</span>
        <span class="comment"># 初始化窗口指针和输出列表</span>
        i, j, res = <span class="number">1</span>,<span class="number">2</span>, []

        <span class="comment"># 滑动窗口的右边界不能超过target的中值</span>
        <span class="keyword">while</span> j &lt;= target//<span class="number">2</span> + <span class="number">1</span>:
            <span class="comment"># 计算当前窗口内数字之和</span>
            cur_sum = sum(list(range(i,j+<span class="number">1</span>)))
            <span class="comment"># 若和小于目标，右指针向右移动，扩大窗口</span>
            <span class="keyword">if</span> cur_sum &lt; target:
                j += <span class="number">1</span>
            <span class="comment"># 若和大于目标，左指针向右移动，减小窗口</span>
            <span class="keyword">elif</span> cur_sum &gt; target:
                i += <span class="number">1</span>
            <span class="comment"># 相等就把指针形成的窗口添加进输出列表中</span>
            <span class="comment"># 别忘了，这里还要继续扩大寻找下一个可能的窗口哦</span>
            <span class="keyword">else</span>:
                res.append(list(range(i,j+<span class="number">1</span>)))
                <span class="comment"># 这里用j+=1，i+=1，i+=2都可以的</span>
                j += <span class="number">1</span>
        
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">35</span>--&gt;
输入: <span class="string">"the sky is blue"</span>
输出: <span class="string">"blue is sky the"</span>

输入: <span class="string">"  hello world!  "</span>
输出: <span class="string">"world! hello"</span>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

输入: <span class="string">"a good   example"</span>
输出: <span class="string">"example good a"</span>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
&lt;!--￼<span class="number">36</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="左旋转字符串"><a class="markdownIt-Anchor" href="#左旋转字符串"></a> 左旋转字符串</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题58II）：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把字符串分为两部分，由于想把它的前k个字符移到后面，我们就先把前k个字符分隔到第一部分，把后面的所有字符都分到第二部分。然后，分别反转这两个部分，最后反转整个字符串。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：字符串切片、列表遍历拼接、字符串遍历拼接</p>
<ul>
<li>
<p>字符串切片</p>
<ul>
<li>
<p>应用字符串切片函数，可方便实现左旋转字符串。</p>
</li>
<li>
<p>获取字符串 s[n:]切片和 s[:n] 切片，使用 “+” 运算符拼接并返回即可。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span>
        <span class="string">"""
        :type s: str
        :type n: int
        :rtype: str
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:
            <span class="keyword">return</span> <span class="string">""</span>
        <span class="keyword">return</span> s[n:] + s[:n]
&lt;!--￼<span class="number">38</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>字符串遍历拼接</p>
<ul>
<li>
<p>若面试不允许用join，可以使用该方法</p>
</li>
<li>
<p>新建一个str，记为res</p>
</li>
<li>
<p>遍历字符串，用&quot;+&quot;依次拼接字符串</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span>
        <span class="string">"""
        :type s: str
        :type n: int
        :rtype: str
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:
            <span class="keyword">return</span>
        res = <span class="string">""</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(s)):
            res += s[i]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
            res += s[i]
        <span class="keyword">return</span> res        
&lt;!--￼<span class="number">39</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="滑动窗口的最大值"><a class="markdownIt-Anchor" href="#滑动窗口的最大值"></a> 滑动窗口的最大值</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题59I）：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：单调队列</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li><strong>初始化</strong>：双端队列deque，结果列表res，数组长度n</li>
<li><strong>滑动窗口</strong>：左边界范围i∈[1-k, n+1-k]，右边界范围j∈[0, n-1]
<ul>
<li>若i＞0且队首元素deque[0]=被删除元素nums[i-1]，则队首元素出队</li>
<li>删除deque内所有＜nums[j]的元素，以保持deque递减</li>
<li>将nums[j]添加至deque尾部</li>
<li>若已形成窗口(即i≥0)，将窗口最大值（即队首元素deque[0]）添加至列表res</li>
</ul>
</li>
<li><strong>返回值</strong>：返回结果列表res</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，其中 n为数组 nums长度；线性遍历 nums占用 O(N)；每个元素最多仅入队和出队一次，因此单调队列 deque占用 O(2N) 。</p>
</li>
<li>
<p>空间复杂度：O(k)，双端队列 deque中最多同时存储 k个元素（即窗口大小）。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:
            <span class="keyword">return</span> []
        deque = collections.deque()
        <span class="comment">#未形成窗口</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):
            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:
                deque.pop()
            deque.append(nums[i])
        res = [deque[<span class="number">0</span>]]
        <span class="comment">#形成窗口后</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):
            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]: <span class="comment"># 删除 deque 中对应的 nums[i-1]</span>
                deque.popleft()
            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:
                deque.pop()
            deque.append(nums[i])
            res.append(deque[<span class="number">0</span>])
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">41</span>--&gt;
输入: 
[<span class="string">"MaxQueue"</span>,<span class="string">"push_back"</span>,<span class="string">"push_back"</span>,<span class="string">"max_value"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]
[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]
输出: [null,null,null,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]

输入: 
[<span class="string">"MaxQueue"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]
[[],[],[]]
输出: [null,<span class="number">-1</span>,<span class="number">-1</span>]
&lt;!--￼<span class="number">42</span>--&gt;

</code></pre>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="n个骰子的点数"><a class="markdownIt-Anchor" href="#n个骰子的点数"></a> n个骰子的点数</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题60）：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 11</p>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：骰子一共6个面，每个面上都有一个点数，对应的是1~6之间的一个数字。所以n个骰子的点数和的最小值为n，最大值为6n。另外根据排列组合的知识，我们还知道n个骰子的所有点数的排列数位6<sup>n。要解决这个问题，我们需要先统计出每一个点数出现的次数，然后把每一个点数出现的次数除以6</sup>n，就能求出每个点数出现的概率。
<ul>
<li>基于递归求骰子点数，时间效率不够高
<ul>
<li>可以先把n个骰子分为两堆：第一堆只有一个，另一个有n-1个。单独的那一个有可能出现从1到6的点数。我们需要计算1到6的每一种点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子还是分成两堆，第一堆只有一个，第二堆有n-2个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加，再和剩下的n-2骰子来计算点数和。递归的思路，递归结束条件就是最后只剩下一个骰子。我们可以定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组第s-n个元素里。</li>
</ul>
</li>
<li>基于循环求骰子点数，时间性能好
<ul>
<li>我们可以考虑用两个数组来存储骰子点数的每一个总数出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。下一循环中，我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的总和，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：动态规划</p>
<ul>
<li>
<p><strong>表示状态</strong>：dp[i][j]，表示投掷完i个骰子后，点数j的出现次数</p>
</li>
<li>
<p><strong>找出状态转移方程</strong>：找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。最后一个阶段也就是投掷完 n枚骰子后的这个阶段，我们用 dp[n][j]来表示最后一个阶段点数 j 出现的次数。单单看第 n枚骰子，它的点数可能为 1 , 2, 3, … , 6 ，因此投掷完 n 枚骰子后点数 j出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, … , j-6 出现的次数之和转化过来。</p>
<ul>
<li>
<pre class="highlight"><code class>for (第n枚骰子的点数 i = 1; i &lt;= 6; i ++) {
    dp[n][j] += dp[n-1][j - i]
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 写成数学公式：</span><br><span class="line"></span><br><span class="line">    - $$</span><br><span class="line">      dp[n][j] &#x3D; \sum^&#123;6&#125;_&#123;i &#x3D; 1&#125;dp[n-1][j-i]</span><br><span class="line">      $$</span><br><span class="line"></span><br><span class="line">    - n表示阶段，j表示投掷完n枚骰子之后的点数和，i表示第n枚骰子会出现的六个点数</span><br><span class="line"></span><br><span class="line">- **边界处理：**这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 6，并且每个点数出现的次数都是 1.</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
for (int i = 1; i &lt;= 6; i ++) {
    dp[1][i] = 1;
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  class Solution(object):</span><br><span class="line">      def twoSum(self, n):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type n: int</span><br><span class="line">          :rtype: List[float]</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          dp &#x3D; [[0 for _ in range(6 * n + 1)] for _ in range(n + 1)] #表示i个骰子投掷出s点的次数</span><br><span class="line">          for i in range(1,7):</span><br><span class="line">              dp[1][i] &#x3D; 1  #表示一个骰子投掷出i点的次数为1</span><br><span class="line">          for i in range(2, n + 1):  #表示骰子的个数</span><br><span class="line">              for j in range(i, i * 6 + 1): #表示可能会出现的点数之和</span><br><span class="line">                  for k in range(1,7):</span><br><span class="line">                      if j &gt;&#x3D; k + 1:</span><br><span class="line">                          dp[i][j] +&#x3D; dp[i - 1][j - k] #当前n个骰子出现的点数之和等于前一次出现的点数之和加上这一次出现的点数</span><br><span class="line">          res &#x3D; []</span><br><span class="line">          for i in range(n,n * 6 + 1):  #投掷n次点数出现的所有情况</span><br><span class="line">              res.append(dp[n][i] * 1.0 &#x2F; 6 ** n)</span><br><span class="line">          return res</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n^2)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="扑克牌中的顺子"><a class="markdownIt-Anchor" href="#扑克牌中的顺子"></a> 扑克牌中的顺子</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题61）：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li>数组长度为 5</li>
<li>数组的数取值为 [0, 13] .</li>
</ul>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：首先把数组排序，再统计数组中0的个数，最后统计排序之后的数组中相邻数组之间的空缺总数。如果空缺的总数小于或等于0的个数，那么这个数组就是连续的，反之则不连续。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据题意，此5张牌是顺子的充分条件如下：</p>
<ul>
<li>除大小王外，所有牌<strong>无重复</strong></li>
<li>设此5张牌中最大的牌为max，最小的牌为min（大小王除外），则需满足：max-min&lt;5</li>
</ul>
</li>
<li>
<p>思路：集合set+遍历 、 排序+遍历</p>
<ul>
<li>
<p>集合set+遍历</p>
<ul>
<li>
<p>遍历5张牌，遇到大小王（即0）直接跳过</p>
</li>
<li>
<p>判别重复牌，利用 set实现遍历判重，set的查找方法的时间复杂度为O(1)</p>
</li>
<li>
<p>获取最大牌和最小牌，借助辅助遍历ma和mi，遍历统计即可。</p>
</li>
<li>
<p>时间复杂度： O(N) = O(5) = O(1)， 其中 N为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</p>
</li>
<li>
<p>空间复杂度：O(N)=O(5)=O(1) ，用于判重的辅助 Set 使用 O(N)额外空间。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: bool
        """</span>
        repeat = set()
        ma, mi = <span class="number">0</span>, <span class="number">14</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> nums:
            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 跳过大小王</span>
            ma = max(ma, num) <span class="comment"># 最大牌</span>
            mi = min(mi, num) <span class="comment"># 最小牌</span>
            <span class="keyword">if</span> num <span class="keyword">in</span> repeat: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 若有重复，提前返回 false</span>
            repeat.add(num) <span class="comment"># 添加牌至 Set</span>
        <span class="keyword">return</span> ma - mi &lt; <span class="number">5</span> <span class="comment"># 最大牌 - 最小牌 &lt; 5 则可构成顺子 </span>
&lt;!--￼<span class="number">47</span>--&gt;

</code></pre>
</li>
<li>
<p>时间复杂度 O(N log N) = O(5 log 5) = O(1)， 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用O(NlogN) 时间。</p>
</li>
<li>
<p>空间复杂度 O(1) ，变量 joker 使用 O(1)大小的额外空间。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#圆圈中最后剩下的数字"></a> 圆圈中最后剩下的数字</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题62）：0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：约瑟夫环问题，有以下两种解法：</p>
<ol>
<li>用环形链表模拟圆圈的经典解法，时间复杂度：O(mn)，空间复杂度：O(n)</li>
<li>分析每次被删除数字的规律并直接计算出圆圈中最后剩下的数字</li>
</ol>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/</a></li>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：根据递推公式就可以使用递归或者迭代</p>
<ul>
<li>
<p>迭代：</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n, m)</span>:</span>
        <span class="string">"""
        :type n: int
        :type m: int
        :rtype: int
        """</span>
        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:
            <span class="keyword">return</span> <span class="number">-1</span>
        f = <span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):
            f = (m + f) % i
        <span class="keyword">return</span> f
&lt;!--￼<span class="number">49</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格</p>
<p>输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">&gt; - 参考：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;gu-piao-de-zui-da-li-run-lcof&#x2F;solution&#x2F;mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2&#x2F;</span><br><span class="line"></span><br><span class="line">- 思路：动态规划</span><br><span class="line"></span><br><span class="line">  - **状态定义**：设动态规划列表 dp ，dp[i] 代表以 prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。</span><br><span class="line">  - **转移方程**：由于题目限定 “买卖该股票一次” ，因此前 i日最大利润 dp[i] 等于前 i - 1日最大利润 dp[i-1]和第 i 日卖出的最大利润中的最大值。</span><br><span class="line">    - 前*i*日最大利润&#x3D;max(前(*i*−1)日最大利润,第*i*日价格−前*i*日最低价格)</span><br><span class="line">    - dp[i] &#x3D; max(dp[i - 1] , prices[i] - min(prices[0:i]))</span><br><span class="line">  - **初始状态**：dp[i] &#x3D; 0，首日利润为0</span><br><span class="line">  - **返回值**：dp[n-1]，其中n为dp列表长度</span><br><span class="line">  - **效率优化**：</span><br><span class="line">    - 时间复杂度降低： 前 i 日的最低价格 min(prices[0:i]) 时间复杂度为 O(i) 。而在遍历 prices时，可以借助一个变量（记为成本 cost ）每日更新最低价格。优化后的转移方程为：</span><br><span class="line">      - dp[i] &#x3D; max(dp[i - 1] , prices[i] - min(cost, prices[i]))</span><br><span class="line">    - 空间复杂度降低：由于dp[i]只与dp[i-1]，pirces[i]，cost有关，因此可以用一个变量（记为profit）代表dp列表：</span><br><span class="line">      - profit &#x3D; max(profit, prices[i] - min(cost, prices[i]))</span><br><span class="line">  - 时间复杂度：O(n)</span><br><span class="line">  - 空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  class Solution(object):</span><br><span class="line">      def maxProfit(self, prices):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type prices: List[int]</span><br><span class="line">          :rtype: int</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          if len(prices) &#x3D;&#x3D; 0 or len(prices) &gt; 10**5:</span><br><span class="line">              return 0</span><br><span class="line">          profit &#x3D; 0</span><br><span class="line">          cost &#x3D; float(&#39;inf&#39;)</span><br><span class="line">          for price in prices:</span><br><span class="line">              cost &#x3D; min(cost, price)</span><br><span class="line">              profit &#x3D; max(profit, price - cost)</span><br><span class="line">          return profit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="求12n"><a class="markdownIt-Anchor" href="#求12n"></a> 求1+2+…+n</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题64）:求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：通常求1+2+3+…+n，除了用公式n(n+1)/2之外，无外乎循环和递归两种思路。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/</a></li>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归使用if判断的写法：</p>
<ul>
<li>
<pre class="highlight"><code class="python"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(n)</span>:</span>
    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span>
    n += sumNums(n - <span class="number">1</span>)
    <span class="keyword">return</span> n
&lt;!--￼<span class="number">52</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>思路：快速乘</p>
<ul>
<li>
<p>回到本题，由等差数列求和公式我们可以知道 1+2+3+…+n等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，对于除以 2 我们可以用右移操作符来模拟，那么等式变成了 n(n+1)&gt;&gt;1，剩下不符合题目要求的部分即为 n(n+1)，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 n 为 [1,10000]，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。</p>
</li>
<li>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    res = <span class="number">0</span>
    <span class="function"><span class="keyword">def</span> <span class="title">add_a</span><span class="params">(self, a)</span>:</span>
        self.res += a

    <span class="function"><span class="keyword">def</span> <span class="title">sum_by_recursive</span><span class="params">(self, a, b)</span>:</span>
        b &amp; <span class="number">1</span> <span class="keyword">and</span> self.add_a(a)
        b <span class="keyword">and</span> self.sum_by_recursive(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>)


    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n)</span>:</span>
        a = n
        b = n + <span class="number">1</span>
        self.sum_by_recursive(a, b)

        <span class="keyword">return</span> self.res &gt;&gt; <span class="number">1</span>
&lt;!--￼<span class="number">53</span>--&gt;
</code></pre>
</li>
</ul>
<p>输入: a = 1, b = 1<br>
输出: 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 提示：</span><br><span class="line"></span><br><span class="line">  - &#96;a&#96;, &#96;b&#96; 均可能是负数或 0</span><br><span class="line">  - 结果不会溢出 32 位整数</span><br><span class="line"></span><br><span class="line">## 题解 </span><br><span class="line"></span><br><span class="line">- &gt; **Tips**：：位运算</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; - python负数存储介绍：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof&#x2F;solution&#x2F;mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7&#x2F;</span><br><span class="line">  &gt; - 二进制公式推导：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof&#x2F;solution&#x2F;er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h&#x2F;</span><br><span class="line"></span><br><span class="line">- 思路：</span><br><span class="line"></span><br><span class="line">  1. 第一步不考虑进位对每一位相加。0加0、1加1的结果都0，0加1、1加0的结果都是1。这和异或结果一样。</span><br><span class="line">  2. 考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时，我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0.</span><br><span class="line">  3. 第三步把前两个步骤的结果相加，相加的过程依然是重复前面两步，直到不产生进位为止。</span><br><span class="line"></span><br><span class="line">- 时间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">- 空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  class Solution(object):</span><br><span class="line">      def add(self, a, b):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type a: int</span><br><span class="line">          :type b: int</span><br><span class="line">          :rtype: int</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">          x &#x3D; 0xffffffff</span><br><span class="line">          a, b &#x3D; a &amp; x, b &amp; x #计算两个数的二进制补码</span><br><span class="line">          while b !&#x3D; 0:</span><br><span class="line">              a, b &#x3D; (a ^ b), (a &amp; b) &lt;&lt; 1 &amp; x  #计算无进位和赋给a，计算进位赋给b</span><br><span class="line">          return a if a &lt;&#x3D; 0x7fffffff else ~(a ^ x) #~是按位取反运算符</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="构建乘积数组"><a class="markdownIt-Anchor" href="#构建乘积数组"></a> 构建乘积数组</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题66）：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li><code>a.length &lt;= 100000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：列表格，根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p>
<ul>
<li>算法流程：
<ol>
<li>初始化：数组 B ，其中 B[0] = 1 ；辅助变量 tmp = 1 ；</li>
<li>计算 B[i]的 下三角 各元素的乘积，直接乘入 B[i] ；</li>
<li>计算 B[i] 的 上三角 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li>
<li>返回 B 。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span>
        <span class="string">"""
        :type a: List[int]
        :rtype: List[int]
        """</span>

        b, tmp = [<span class="number">1</span>] * len(a), <span class="number">1</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):
            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>): 
            tmp *= a[i + <span class="number">1</span>] <span class="comment"># 上三角</span>
            b[i] *= tmp <span class="comment"># 下三角 * 上三角</span>
        <span class="keyword">return</span> b
&lt;!--￼<span class="number">56</span>--&gt;
输入: <span class="string">"42"</span>
输出: <span class="number">42</span>

输入: <span class="string">"   -42"</span>
输出: <span class="number">-42</span>
解释: 第一个非空白字符为 <span class="string">'-'</span>, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 <span class="number">-42</span> 

输入: <span class="string">"4193 with words"</span>
输出: <span class="number">4193</span>
解释: 转换截止于数字 <span class="string">'3'</span> ，因为它的下一个字符不为数字。

输入: <span class="string">"-91283472332"</span>
输出: <span class="number">-2147483648</span>
解释: 数字 <span class="string">"-91283472332"</span> 超过 <span class="number">32</span> 位有符号整数范围。 
     因此返回 INT_MIN (−<span class="number">231</span>) 。
&lt;!--￼<span class="number">57</span>--&gt;
例如，给定如下二叉搜索树:  root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>]

示例<span class="number">1</span>：
输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span>
输出: <span class="number">6</span> 
解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。

示例<span class="number">2</span>：
输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span>
输出: <span class="number">2</span>
解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。
&lt;!--￼<span class="number">58</span>--&gt;

- 优化：若可保证 p.val &lt; q.val ，则在循环中可减少判断条件。

- ```python
  <span class="comment"># Definition for a binary tree node.</span>
  <span class="comment"># class TreeNode(object):</span>
  <span class="comment">#     def __init__(self, x):</span>
  <span class="comment">#         self.val = x</span>
  <span class="comment">#         self.left = None</span>
  <span class="comment">#         self.right = None</span>
  
  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
      <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span>
          <span class="string">"""
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """</span>
          <span class="keyword">if</span> p.val &gt; q.val: p, q = q, p <span class="comment"># 保证 p.val &lt; q.val</span>
          <span class="keyword">while</span> root:
              <span class="keyword">if</span> root.val &lt; p.val: <span class="comment"># p,q 都在 root 的右子树中</span>
                  root = root.right <span class="comment"># 遍历至右子节点</span>
              <span class="keyword">elif</span> root.val &gt; q.val: <span class="comment"># p,q 都在 root 的左子树中</span>
                  root = root.left <span class="comment"># 遍历至左子节点</span>
              <span class="keyword">else</span>: <span class="keyword">break</span>
          <span class="keyword">return</span> root
  &lt;!--￼<span class="number">59</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉树的最近公共祖先"></a> 二叉树的最近公共祖先</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题68II）：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/（递归）</a></li>
<li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/</a> (多种解法)</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q在节点 root 的异侧时，节点 root即为最近公共祖先，则向上返回 root。</li>
<li>递推解析见参考链接</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right
        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left
        <span class="keyword">return</span> root
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/06/02/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 面试必备《剑指offer》，题解整理，方便今后自己查阅，要为接下来的秋招做准备了呀~</p>
<h1 id="数组中重复的数字"><a class="markdownIt-Anchor" href="#数组中重复的数字"></a> 数组中重复的数字</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题03)：找出数组中重复的数字。<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有多种解法，如果面试中遇到这道题，让你找出数组中重复的数字，要向面试官询问，<u><strong>是否可以使用额外空间</strong></u>？<u><strong>是否可以修改原数组</strong></u>？然后，根据要求给出解决方案。（<strong><u>本题对数组长度做了限制，如果没有限制数组长度，需要进行非空判断</u></strong>）</p>
<ol>
<li>
<p><strong>使用额外空间，不修改原数组——哈希表</strong></p>
<ul>
<li>
<p>思路：遍历数组，用哈希表记录数组中每个数字出现的情况，如果该数字没有出现在哈希表，就将其加入哈希表，如果该数字在哈希表中已经存在，就直接返回。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——sort排序</strong></p>
<ul>
<li>
<p>思路：对数组排序，这样重复的两个数字的位置就是相邻的，然后，遍历一遍数组，判断相邻位置的两个数字是否相等，相等就返回，不相等就继续遍历。</p>
</li>
<li>
<blockquote>
<p>list.sort()的原理：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">https://blog.csdn.net/yangzhongblog/article/details/8184707</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(nlogn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        nums.sort()
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):
            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:
                <span class="keyword">return</span> nums[i]
        <span class="keyword">return</span> <span class="literal">None</span>   
&lt;!--￼<span class="number">2</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> 二维数组中的查找</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题04）：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn><mi mathvariant="normal">，</mi><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤n≤1000，0≤m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：如果这个n * m的数组是无序的，要查找该数组中是否存在目标整数，需要遍历完二维数组每一行或者每一列，即暴力求解法，时间复杂度是O(n*m)，空间复杂度是O(1)。仔细观察题目的二维数组，可以发现行和列的数字是按一定顺序排列的。</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后从数组中选取一个数字，分3种情况来分析查找过程。当数组中选取的数字刚好要和查找的数字相等时，就结束查找过程。如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取的位置的上边或者右边。（若当前选取位置在正中间，则在右下角或左上角可能会出现查找重叠区域）。</p>
</blockquote>
</li>
<li>
<p>思路：从数组的一个角上选取数字来和要查找的数字做比较。</p>
<ul>
<li>
<p>左上角数字：是所在列和行最小的数字（如果查找的数字大于左上角数字，情况和上述分析一样，可以往右边或者下边查找）</p>
</li>
<li>
<p>左下角数字：是所在列最大的数字，所在行最小的数字（如果查找的数字大于左下角数字，往右边查找，如果小于做左下角数字，往上边查找）</p>
</li>
<li>
<p>右上角数字：是所在列最小的数字，所在行最大的数字（如果查找的数字大于右上角数字，往下边查找，如果小于右上角数字，往左边查找）</p>
</li>
<li>
<p>右下角数字：是所在列和行最大的数字（如果查找的数字小于右下角数字，情况和上述分析一样，可以往左边或者上边查找）</p>
</li>
<li>
<p>因此，本题可以选择左下角数字或右上角数字来和查找的数字做比较。</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>特殊用例：二维数组为空，返回空</li>
<li>假设从矩阵matrix的左下角数字开始遍历（索引设为i，j），与要查找的数字做比较：（右上角同理分析）
<ul>
<li>当<code>matrix[i][j] == target</code>，返回True</li>
<li>当<code>matrix[i][j] &gt; target</code>，行索引<code>i</code>向上查找，即<code>i--</code></li>
<li>当<code>matrix[i][j] &lt; target</code>，列索引<code>j</code>向右查找，即<code>j++</code></li>
</ul>
</li>
<li>若行索引或列索引越界，则代表矩阵中无目标值，返回 False。</li>
</ul>
</li>
<li>
<blockquote>
<p>算法本质： 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n + m)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span>
        <span class="string">"""
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> target:
            <span class="keyword">return</span> <span class="literal">False</span>
        i = len(matrix) - <span class="number">1</span>
        j = <span class="number">0</span>
        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]):
            <span class="keyword">if</span> matrix[i][j] == target:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">elif</span> matrix[i][j] &gt; target:
                i -= <span class="number">1</span>
            <span class="keyword">else</span>:
                j += <span class="number">1</span>
        <span class="keyword">return</span> <span class="literal">False</span>
&lt;!--￼<span class="number">4</span>--&gt;
输入：s = <span class="string">"We are happy."</span>
输出：<span class="string">"We%20are%20happy."</span>
&lt;!--￼<span class="number">5</span>--&gt;

<span class="number">2.</span> 循环（新）

   &gt; - Python的六个标准数据类型中不可变数据（<span class="number">3</span> 个）：Number（数字）、String（字符串）、Tuple（元组）。

   - 将字符串先转换为list，然后，遍历list，当遍历到空格，就将空格替换成<span class="string">'%20'</span>，最后，将list转成str。

   - 时间复杂度：O(n)

   - 空间复杂度：O(n)

   - ```python
     <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
         <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span>
             <span class="string">"""
             :type s: str
             :rtype: str
             """</span>
             <span class="keyword">if</span> len(s) == <span class="number">0</span>:
                 <span class="keyword">return</span> s
             l = list(s)
             <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):
                 <span class="keyword">if</span> l[i] == <span class="string">' '</span>:
                     l[i] = <span class="string">'%20'</span>
             <span class="keyword">return</span> <span class="string">''</span>.join(l)
     &lt;!--￼<span class="number">6</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题06）：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 链表长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：面试时候，需要明确**<u>是否允许在打印链表的时候修改链表的结构</u>**？如果可以修改，那么就是<u><strong>面试题24-反转链表</strong></u>，先对链表进行反转，然后输出。如果不可以修改，那肯定需要遍历链表，遍历顺序是从头到尾，输出是从尾到头，典型的“后进先出”，我们可以<u><strong>使用栈实现</strong></u>。想到栈，我们还可以想到递归，<u><strong>递归在本质上就是一个栈结构</strong></u>，即每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身。</p>
<ol>
<li>
<p><strong>修改链表结构-反转链表</strong>（具体看面试题24-反转链表）</p>
<ul>
<li>
<p>特殊用例：链表头结点指针为空，返回[]</p>
</li>
<li>
<p>双指针反转链表：</p>
</li>
<li>
<p>初始化两个指针，<code>pre == None</code>，<code>cur == head</code></p>
</li>
<li>
<p>遍历链表，用临时变量tmp记录当前结点，并将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></p>
</li>
<li>
<p>pre和cur都向链表尾部移动，直到cur为空。</p>
</li>
<li>
<p>题目要求用数组返回，因此，初始化数组<code>s = []</code>，遍历反转后的链表，依次将每个结点的值加入数组，然后返回数组s。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> []
        pre = <span class="literal">None</span>
        cur = head
        <span class="keyword">while</span> cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        s = []
        <span class="keyword">while</span> pre:
            s.append(pre.val)
            pre = pre.next
        <span class="keyword">return</span> s
&lt;!--￼<span class="number">8</span>--&gt;

</code></pre>
</li>
<li>
<p>python可以对上面的代码优化，不需要再创建一个数组s，可以直接利用切片，直接输出倒序列表stack</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> []
        stack = []
        i = head
        <span class="keyword">while</span> i:
            stack.append(i.val)
            i = i.next
        <span class="keyword">return</span> stack[::<span class="number">-1</span>]
&lt;!--￼<span class="number">9</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="重建二叉树"><a class="markdownIt-Anchor" href="#重建二叉树"></a> 重建二叉树</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题07）：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给出</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 节点个数 ≤ 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p>思路：根据前序遍历和中序遍历的特点，可以对前序遍历和中序遍历序列进行划分，划分出左子树、根节点、右子树的区间，然后，递归构造二叉树。</p>
<ul>
<li>特殊用例：前序遍历为空或中序遍历为空或节点个数≤0，返回None（前序遍历和中序遍历不匹配）</li>
<li>根据前序遍历特点，前序遍历序列的第一个数字是根节点的值，即<code>root_val = preorder[0]</code></li>
<li>构建根节点，<code>root = TreeNode(root_val)</code></li>
<li>确定根节点在中序遍历的序列的索引：<code>root_in_index = inorder.index(root_val)</code></li>
<li>确定左子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>确定右子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>递归构建左子树和右子树</li>
<li>返回root</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span>
        <span class="string">"""
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:
            <span class="keyword">return</span> <span class="literal">None</span>
        root_val = preorder[<span class="number">0</span>]
        root = TreeNode(root_val)
        root_in_index = inorder.index(root_val)
        left_pre = preorder[<span class="number">1</span>: root_in_index + <span class="number">1</span>]
        left_in = inorder[: root_in_index]
        right_pre = preorder[root_in_index + <span class="number">1</span>:]
        right_in = inorder[root_in_index + <span class="number">1</span>:]
        root.left = self.buildTree(left_pre, left_in)
        root.right = self.buildTree(right_pre, right_in)
        <span class="keyword">return</span> root
&lt;!--￼<span class="number">11</span>--&gt;
示例<span class="number">1</span>：
输入：
[<span class="string">"CQueue"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]
[[],[<span class="number">3</span>],[],[]]
输出：[null,null,<span class="number">3</span>,<span class="number">-1</span>]

示例<span class="number">2</span>：
输入：
[<span class="string">"CQueue"</span>,<span class="string">"deleteHead"</span>,<span class="string">"appendTail"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]
[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]
输出：[null,<span class="number">-1</span>,null,null,<span class="number">5</span>,<span class="number">2</span>]
&lt;!--￼<span class="number">12</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="用两个队列实现栈"><a class="markdownIt-Anchor" href="#用两个队列实现栈"></a> 用两个队列实现栈</h1>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：pop(0)是pop第一个元素，pop()是pop最后一个元素，时间效率上pop最后一个元素效率高。pop用于stack，可带参数，popleft用于collections中，不可带参数。（都是pop出来且在原数据删除）</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>初始化两个队列，q1和q2</li>
<li>进栈：元素队列q1</li>
<li>出栈：当队列q1只有一个元素，直接出队，否则，把q1的元素出队并入队q2，直到q1中只有一个元素，再直接出队。为了下一次继续操作，互换q1和q2</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.q1 = []
        self.q2 = []
    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val)</span>:</span>
        self.q1.append(val)
    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span>
        <span class="keyword">if</span> len(self.q1) == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="literal">None</span>
        <span class="keyword">while</span> len(self.q1) != <span class="number">1</span>:
            self.q2.append(self.q1.pop(<span class="number">0</span>))
        self.q1, self.q2 = self.q2, self.q1
        <span class="keyword">return</span> self.q2.pop()
    
<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    s = Stack()
    l = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):
        s.push(l[i])
    print(l)
    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):
        print(s.pop(), <span class="string">','</span>, end = <span class="string">''</span>)
&lt;!--￼<span class="number">13</span>--&gt;
F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span>
F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span>
&lt;!--￼<span class="number">14</span>--&gt;
输入：n = <span class="number">2</span>
输出：<span class="number">1</span>

输入：n = <span class="number">5</span>
输出：<span class="number">5</span>
&lt;!--￼<span class="number">15</span>--&gt;

</code></pre>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<p>可以用3个变量，sum，a，b，优化上述代码，时间复杂度不变，空间复杂度降为O(1)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h1 id="青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#青蛙跳台阶问题"></a> 青蛙跳台阶问题</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-II）：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</li>
<li>此类求 多少种可能性 的题目一般都有 递推性质 ，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n - 1)....f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间是有联系的。</li>
<li>设跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。</li>
<li>当为 1 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>种跳法；</li>
<li>当为 2 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>种跳法。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为以上两种情况之和，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> ，以上递推性质为斐波那契数列。</li>
<li>本题可转化为 求斐波那契数列第 n项的值 ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。
<ul>
<li>青蛙跳台阶问题： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(0)=1 , f(1)=1 , f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ；</li>
<li>斐波那契数列问题：$ f(0)=0 , f(1)=1 , f(2)=1$ ;</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：直接在面试题10-I 斐波那契数列的基础上，将起始数字做一个修改。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        a = <span class="number">1</span>
        b = <span class="number">1</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):
            a, b = b, a+b
        <span class="keyword">return</span> a % <span class="number">1000000007</span>
&lt;!--￼<span class="number">18</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="旋转数组中最小的数字"><a class="markdownIt-Anchor" href="#旋转数组中最小的数字"></a> 旋转数组中最小的数字</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题11）：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<strong>输入一个递增排序的数组的一个旋转</strong>，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li><strong>Tips</strong>：<strong><u>如果面试题是要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。关于查找和排序见另一篇博客《八大排序》</u></strong></li>
</ul>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></li>
<li>参考2：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>根据题目可以发现，输入的递增排序数组，可以从中点划分成两个递增数组。左排序数组的任一元素都大于右排序数组的任一元素。</li>
<li>双指针法，初始化两个指针i，j，指向数组的头和尾，即<code>i == 0</code>， <code>j == len(numbers)</code></li>
<li><code>mid = (i + j) // 2</code>，每次二分的中点</li>
<li>当<code>numbers[mid] &gt; numbers[j]</code>，m在左边的递增数组，最小元素一定在[m+1, j]</li>
<li>当<code>numbers[mid] &lt; numbers[j]</code>，m在右边的递增数组，最小元素一定在[i,m]</li>
<li>当<code>numbers[mid] = numbers[j]</code>，无法判断m在哪，缩小区间即可[i,j-1]</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span>
        <span class="string">"""
        :type numbers: List[int]
        :rtype: int
        """</span>
        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            mid = (i + j) // <span class="number">2</span>
            <span class="keyword">if</span> numbers[mid] &gt; numbers[j]:
                i = mid + <span class="number">1</span>
            <span class="keyword">elif</span> numbers[mid] &lt; numbers[j]:
                j = mid
            <span class="keyword">else</span>:
                j -= <span class="number">1</span>
        <span class="keyword">return</span> numbers[i]
&lt;!--￼<span class="number">20</span>--&gt;
输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCCED"</span>
输出：true

输入：board = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>]], word = <span class="string">"abcd"</span>
输出：false
&lt;!--￼<span class="number">21</span>--&gt;

</code></pre>
</li>
<li>
<p>牛客网对应的这个题的python解法的通过榜单的榜首的代码都会有部分case过不了，正确代码如下：</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):
                <span class="keyword">if</span> matrix[i*cols + j] == path[<span class="number">0</span>]:
                    <span class="keyword">if</span> self.dfs(list(matrix), rows, cols, path[<span class="number">1</span>:], i, j):
                        <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">return</span> <span class="literal">False</span>

    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, rows, cols, path, i, j)</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> path:
            <span class="keyword">return</span> <span class="literal">True</span>
        matrix[i*cols + j] = <span class="string">'-'</span>
        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):
            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> matrix[x*cols+y]==path[<span class="number">0</span>]:
                <span class="keyword">if</span> self.dfs(matrix, rows, cols, path[<span class="number">1</span>:], x, y):
                    <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">return</span> <span class="literal">False</span>
&lt;!--￼<span class="number">22</span>--&gt;
输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span>
输出：<span class="number">3</span>

输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span>
输出：<span class="number">1</span>
&lt;!--￼<span class="number">23</span>--&gt;

</code></pre>
</li>
<li>
<p>思路2：</p>
<ul>
<li>BFS
<ul>
<li>初始化： 将机器人初始点 (0, 0)加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：</li>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li>
<li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span>
        <span class="string">"""
        :type m: int
        :type n: int
        :type k: int
        :rtype: int
        """</span>
        queue, visited = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()
        <span class="keyword">while</span> queue:
            i, j, si, sj = queue.pop(<span class="number">0</span>)
            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:
                <span class="keyword">continue</span>
            visited.add((i, j))
            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))
            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))
        <span class="keyword">return</span> len(visited)
&lt;!--￼<span class="number">24</span>--&gt;
输入: <span class="number">2</span>
输出: <span class="number">1</span>
解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>

输入: <span class="number">10</span>
输出: <span class="number">36</span>
解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>
&lt;!--￼<span class="number">25</span>--&gt;

</code></pre>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码适合了解学习，属于找规律，数学方法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a)</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="剪绳子ii"><a class="markdownIt-Anchor" href="#剪绳子ii"></a> 剪绳子II</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14II）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：和面试题14I - 剪绳子I的解题思想是一样的，在此基础上，考虑<strong>大数越界情况下的求余</strong>问题。</p>
</li>
<li>
<blockquote>
<p>参考链接里介绍的求余方法：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
</blockquote>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span>
        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):
            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),
                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),
                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))
        <span class="keyword">return</span> dp[n % <span class="number">3</span>] % <span class="number">1000000007</span>
&lt;!--￼<span class="number">28</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二进制中1的个数"><a class="markdownIt-Anchor" href="#二进制中1的个数"></a> 二进制中1的个数</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题15）：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：（剑指offer)位运算的使用**。位运算总共只有五种运算：<strong>与、或、异或、左移、右移</strong>。与、或和异或运算的规律我们可以用下表总结：</p>
<table>
<thead>
<tr>
<th>与（&amp;）</th>
<th>0&amp;0 = 0</th>
<th>1&amp;0=0</th>
<th>0&amp;1=0</th>
<th>1&amp;1=1</th>
</tr>
</thead>
<tbody>
<tr>
<td>或（！）</td>
<td>0|0 = 0</td>
<td>1|0=1</td>
<td>0|1=0</td>
<td>1|1=1</td>
</tr>
<tr>
<td>异或（^）</td>
<td>0^0 = 0</td>
<td>1^0=1</td>
<td>0^1=1</td>
<td>1^1=0</td>
</tr>
</tbody>
</table>
<ul>
<li>左移运算符m&lt;&lt;n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。比如：
<ul>
<li>00001010&lt;&lt;2 = 00101000</li>
<li>10001010&lt;&lt;3=01010000</li>
</ul>
</li>
<li>右移运算符m&gt;&gt;n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。
<ul>
<li>00001010&gt;&gt;2=00000010</li>
<li>10001010&gt;&gt;3=11110001</li>
</ul>
</li>
<li><strong>除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。</strong></li>
<li>面试时候可以按照基本思路到下面代码思路进行描述：
<ul>
<li>先判断整数二进制表示中最右边一位是不是1，只需要把整数与1做位与运算，是1就右移1位，直到整个整数为0（如果是有符号数，也就是如果输入负数，这样会产生死循环。</li>
<li>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多次这样的操作。
<ul>
<li>例如，二进制数1100，它的第二位是从最右边数起的一个1。减去1后，第二位变成0，而前面的1保持不变，因此得到结果1011，然后再把1100与1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)，n为整数二进制1的个数</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        res = <span class="number">0</span>
        <span class="keyword">while</span> n:
            res += <span class="number">1</span>
            n &amp;= n - <span class="number">1</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">30</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数值的整数次方"><a class="markdownIt-Anchor" href="#数值的整数次方"></a> 数值的整数次方</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题16）：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，<strong>同时不需要考虑大数问题。</strong></p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2^-2 &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</li>
</ul>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<blockquote>
<ul>
<li>（剑指offer)：用一条语句判断<strong>一个整数是不是2的整数次方</strong>。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位是都是0。根据二进制中1的个数分析思路，判断一个整数是不是2的整数次方，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。因此，解决这个问题可以分为两步：
<ul>
<li>第一步：求这两个数的异或</li>
<li>第二步：统计异或结果中1的位数</li>
</ul>
</li>
<li>本题思路参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></li>
</ul>
</li>
<li><strong>计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。</strong>
<ul>
<li>python比较两个float类型的数据是否相等：<a href="https://blog.csdn.net/weixin_34227447/article/details/88713033" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34227447/article/details/88713033</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制问题都可以用这个思路解决。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>考虑输入指数是负数和零的情况。</li>
<li>考虑特殊用例：0的0次方，可以输出0或1</li>
<li><strong>细节</strong>：判断两个double或float类型数值是否相等。位运算代替乘除法以及求余运算。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码可以通过leetcode，但是通过上述分析，我们可以知道，x是double类型，不能直接写 x == 0，因此可以定义一个equal函数进行判断（<code>return abs(num1 - num2) &lt;= 0.0000001</code>)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span>
        <span class="string">"""
        :type x: float
        :type n: int
        :rtype: float
        """</span>
        <span class="keyword">if</span> x == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">if</span> n &lt; <span class="number">0</span>:
            x = <span class="number">1</span> / x
            n = -n
        res = <span class="number">1</span>
        <span class="keyword">while</span> n:
            <span class="keyword">if</span> n &amp; <span class="number">1</span>:
                res *= x
            x *= x
            n &gt;&gt;= <span class="number">1</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">32</span>--&gt;
输入: n = <span class="number">1</span>
输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]
&lt;!--￼<span class="number">33</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="删除链表的节点"><a class="markdownIt-Anchor" href="#删除链表的节点"></a> 删除链表的节点</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题18）：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>**注意：**此题对比原题有改动</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有两种思路.</p>
<ul>
<li>第一个是得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code>（数据输入类型是整型val）</li>
<li>第二个是把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除（剑指offer思路，数据输入类型是链表ListNode）</li>
</ul>
</li>
<li>
<p>思路1：得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code></p>
<ul>
<li>初始化双指针，pre指向head，cur指向head.next</li>
<li>当head为空时，返回head</li>
<li>当head是要删除的结点，返回head.next</li>
<li>遍历链表，当cur指向的结点是要删除的结点时，pre.next = cur.next，直到链表遍历完</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，n是链表长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """</span>
        pre = head
        cur = head.next
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head
        <span class="keyword">if</span> head.val == val:
            <span class="keyword">return</span> head.next
        <span class="keyword">while</span> cur:
            <span class="keyword">if</span> cur.val == val:
                pre.next = cur.next
            pre = pre.next
            cur = cur.next
        <span class="keyword">return</span> head
&lt;!--￼<span class="number">35</span>--&gt;

</code></pre>
</li>
<li>
<p>思路2：把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除。</p>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/</a></li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题19）：请实现一个函数用来匹配包含 <code>'.'</code> 和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</p>
</li>
<li>
<p><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>'*'</code>。</p>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></li>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</a></li>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：回溯法+动态规划</p>
</li>
<li>
<p>思路1：回溯</p>
</li>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中T和P分别表示匹配串和模式串的长度。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span>
        <span class="string">"""
        :type s: str
        :type p: str
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p: 
            <span class="keyword">return</span> <span class="keyword">not</span> s
        <span class="comment"># 第一个字母是否匹配</span>
        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> {s[<span class="number">0</span>],<span class="string">'.'</span>})
        <span class="comment"># 如果 p 第二个字母是 *</span>
        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:
            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \
            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])
&lt;!--￼<span class="number">37</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="表示数值的字符串"><a class="markdownIt-Anchor" href="#表示数值的字符串"></a> 表示数值的字符串</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题20）：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 除去两端空格</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 检查字符合法性</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"0987654321+-e."</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有e的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 检查e的个数</span></span><br><span class="line">            <span class="keyword">if</span> s.count(<span class="string">'e'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 划分，并检查左右子串是否为空</span></span><br><span class="line">            p = s.index(<span class="string">'e'</span>)</span><br><span class="line">            ls = s[:p]</span><br><span class="line">            rs = s[p+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> len(ls)==<span class="number">0</span> <span class="keyword">or</span> len(rs)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串+-</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串小数点个数</span></span><br><span class="line">            <span class="keyword">if</span> ls.count(<span class="string">'.'</span>)&gt;<span class="number">1</span> <span class="keyword">or</span> rs.count(<span class="string">'.'</span>)&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = ls.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查小数点左或右有没有数字</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = ls.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> ls[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(ls) <span class="keyword">and</span> ls[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 没e的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(s)&lt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = s.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = s.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> s[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(s) <span class="keyword">and</span> s[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#调整数组顺序使奇数位于偶数前面"></a> 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题21）：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>位运算比求余效率高</strong>。在《剑指offer》分析中，双指针方法适合初级程序员，高级一点的写法，应该把整个函数解耦成两部分，一是判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作，这样无论是奇数在偶数前面的数组划分，还是能被3整除的数划分就可以直接求解了，提高代码重用性。</p>
</li>
<li>
<p>思路：双指针</p>
<ul>
<li>初始化双指针，<code>i = 0</code>，<code>j = len(nums) - 1</code></li>
<li>遍历数组，指针i从左向右找偶数，指针j从右向左找奇数</li>
<li>将偶数nums[i]和奇数nums[j]交换</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:
                i += <span class="number">1</span>
            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:
                j -= <span class="number">1</span>
            nums[i], nums[j] = nums[j], nums[i]
        <span class="keyword">return</span> nums
&lt;!--￼<span class="number">40</span>--&gt;

</code></pre>
</li>
<li>
<p>高级一点写法</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) == <span class="number">0</span>:
            <span class="keyword">return</span> []
        pBegin = <span class="number">0</span>
        pEnd = len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> pBegin &lt; pEnd:
            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> <span class="keyword">not</span> self.isEven(nums[pBegin]):
                pBegin += <span class="number">1</span>
            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> self.isEven(nums[pEnd]):
                pEnd -= <span class="number">1</span>
            nums[pBegin], nums[pEnd] = nums[pEnd], nums[pBegin]
        <span class="keyword">return</span> nums
    <span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(self, n)</span>:</span>
        <span class="keyword">return</span> n &amp; <span class="number">1</span> == <span class="number">0</span>
&lt;!--￼<span class="number">41</span>--&gt;
给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span>
返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span>
&lt;!--￼<span class="number">42</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题24）：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有三种解法求解，双指针（最优）、辅助栈、递归。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/</a></p>
</blockquote>
</li>
<li>
<p>思路1：双指针</p>
<ul>
<li>定义3个指针，tmp，pre，cur，分别指向当前遍历结点、它的前一个结点和后一个结点</li>
<li>遍历链表，将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head
        pre = <span class="literal">None</span>
        cur = head
        <span class="keyword">while</span> cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        <span class="keyword">return</span> pre
&lt;!--￼<span class="number">44</span>--&gt;

</code></pre>
</li>
<li>
<p>思路3：递归</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:
            <span class="keyword">return</span> head
        <span class="comment"># 这里的cur就是最后一个节点</span>
        cur = self.reverseList(head.next)
        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span>
				<span class="comment"># 而head是4，head的下一个是5，下下一个是空</span>
				<span class="comment"># 所以head.next.next 就是5-&gt;4</span>
        head.next.next = head
        <span class="comment"># 防止链表循环，需要将head.next设置为空</span>
        head.next = <span class="literal">None</span>
        <span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span>
        <span class="keyword">return</span> cur
&lt;!--￼<span class="number">45</span>--&gt;
输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>
输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>
&lt;!--￼<span class="number">46</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="树的子结构"><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题26）：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> </span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line"> </span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+包含判断+递归</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>第一步：在树A种找到和B的根节点的值一样的结点R（实质：树的遍历）</li>
<li>第二步：判断树A中以R为根节点的子树是不是包含和树B一样的结构</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)，M和N分别为两棵树的节点数</p>
</li>
<li>
<p>空间复杂度：O(M)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A, B)</span>:</span>
        <span class="string">"""
        :type A: TreeNode
        :type B: TreeNode
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> (A <span class="keyword">and</span> B):
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, B)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> B:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">return</span> dfs(A.left, B.left) <span class="keyword">and</span> dfs(A.right, B.right)
        <span class="keyword">return</span> dfs(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)
&lt;!--￼<span class="number">48</span>--&gt;
例如输入：

     <span class="number">4</span>
   /   \
  <span class="number">2</span>     <span class="number">7</span>
 / \   / \
<span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span>

镜像输出：

     <span class="number">4</span>
   /   \
  <span class="number">7</span>     <span class="number">2</span>
 / \   / \
<span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span>

示例 <span class="number">1</span>：
输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]
输出：[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]
&lt;!--￼<span class="number">49</span>--&gt;

</code></pre>
</li>
<li>
<p>辅助栈：</p>
<ul>
<li>利用栈（或队列）遍历树的所有节点node ，并交换每个node的左 / 右子节点。</li>
<li>算法流程：
<ul>
<li>特例处理：当root为空，返回root</li>
<li>初始化：栈，并加入根节点</li>
<li>循环交换：当栈stack为空时跳出
<ul>
<li>出栈：记为node</li>
<li>添加子结点：将node的左右子结点入栈</li>
<li>交换，交换node的左右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> root
        stack = [root]
        <span class="keyword">while</span> stack:
            node = stack.pop()
            <span class="keyword">if</span> node.left:
                stack.append(node.left)
            <span class="keyword">if</span> node.right:
                stack.append(node.right)
            node.left, node.right = node.right, node.left
        <span class="keyword">return</span> root
&lt;!--￼<span class="number">50</span>--&gt;
例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">2</span>
 / \ / \
<span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span>

但是下面这个 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>] 则不是镜像对称的:

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">2</span>
   \   \
   <span class="number">3</span>    <span class="number">3</span>

示例 <span class="number">1</span>：
输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]
输出：true

示例 <span class="number">2</span>：
输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>]
输出：false
&lt;!--￼<span class="number">51</span>--&gt;

</code></pre>
</li>
<li>
<p>思路：队列</p>
<ul>
<li>特例处理：如果root为空，返回True</li>
<li>初始化：队列，并顺序加入root的左右结点</li>
<li>循环判断：当队列为空时跳出
<ul>
<li>出队列：依次记为left和right</li>
<li>如果left和right都为空，说明穿过叶子节点，继续执行</li>
<li>如果left或right其中一个为空，说明不对称，返回False</li>
<li>如果left和right的值不相等，说明不对称，返回False</li>
<li>入队：（成对加入）
<ul>
<li>加入left的左节点和righ的右节点</li>
<li>加入left的右节点和right的左节</li>
</ul>
</li>
</ul>
</li>
<li>返回True</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root.left, root.right]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            left = queue.pop(<span class="number">0</span>)</span><br><span class="line">            right = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">and</span> right) <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(left.left)</span><br><span class="line">            queue.append(right.right)</span><br><span class="line">            queue.append(left.right)</span><br><span class="line">            queue.append(right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="顺时针打印矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵"></a> 顺时针打印矩阵</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题29）：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制</p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<ul>
<li>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</a></li>
<li>剑指offer：
<ul>
<li>当我们遇到一个复杂问题的时候，可以用图形来帮助我们思考。由于是以外圈到内圈的顺序依次打印，我们可以把矩阵想象成若干个圈，可以用一个循环来打印矩阵，每一次打印矩阵中的一个圈。</li>
<li>分析循环结束的条件。假设这个矩阵的行数是rows，列数是columns。打印第一圈的左上角的坐标是(1,1)，第二圈的左上角的坐标是(2,2)，以此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。</li>
<li>对一个5 * 5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2)。我们发现5 &gt; 2 * 2。对于一个6 * 6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为(2,2)。我们发现6 &gt; 2 * 2依然成立。于是我们可以得出，让循环继续的条件是columns &gt; startX * 2并且 rows &gt; startX * 2。</li>
<li>考虑如何打印一圈的功能。我们可以把打印一圈分为4步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或一列。不过值得注意的是，最后一圈有可能退化成只有一行，只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要4步。</li>
<li>分析打印时每一步的前提条件。第一步总是需要的，因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始起始行号至少大2，同时终止列号大于起始列号。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(MN）,M和N分别为矩阵的行列</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span>
        <span class="string">"""
        :type matrix: List[List[int]]
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> matrix:
            <span class="keyword">return</span> []
        l, r, t, b, res = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, len(matrix) - <span class="number">1</span>, []
        <span class="keyword">while</span> <span class="literal">True</span>:
            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):
                res.append(matrix[t][i]) <span class="comment"># left to right</span>
            t += <span class="number">1</span>
            <span class="keyword">if</span> t &gt; b:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>):
                res.append(matrix[i][r]) <span class="comment"># top to bottom</span>
            r -= <span class="number">1</span>
            <span class="keyword">if</span> l &gt; r:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):
                res.append(matrix[b][i]) <span class="comment"># right to left</span>
            b -= <span class="number">1</span>
            <span class="keyword">if</span> t &gt; b:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>):
                res.append(matrix[i][l]) <span class="comment"># bottom to top</span>
            l += <span class="number">1</span>
            <span class="keyword">if</span> l &gt; r:
                <span class="keyword">break</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">54</span>--&gt;
MinStack minStack = new MinStack();
minStack.push(<span class="number">-2</span>);
minStack.push(<span class="number">0</span>);
minStack.push(<span class="number">-3</span>);
minStack.min();   --&gt; 返回 <span class="number">-3.</span>
minStack.pop();
minStack.top();      --&gt; 返回 <span class="number">0.</span>
minStack.min();   --&gt; 返回 <span class="number">-2.</span>
&lt;!--￼<span class="number">55</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#栈的压入-弹出序列"></a> 栈的压入、弹出序列</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题31）：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列</li>
</ul>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：辅助栈</p>
<ul>
<li>面试时，需要确定一个序列和弹出序列的长度是否一致，序列中数字是否有重复。</li>
</ul>
</li>
<li>
<p>思路：判断一个序列是不是栈的弹出序列的规律。如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<ul>
<li>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span>
        <span class="string">"""
        :type pushed: List[int]
        :type popped: List[int]
        :rtype: bool
        """</span>
        stack, i = [], <span class="number">0</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:
            stack.append(num) <span class="comment"># num 入栈</span>
            <span class="keyword">while</span> stack <span class="keyword">and</span> i &lt; len(popped)<span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[i]: <span class="comment"># 循环判断与出栈</span>
                stack.pop()
                i += <span class="number">1</span>
        <span class="keyword">return</span> <span class="keyword">not</span> stack
&lt;!--￼<span class="number">57</span>--&gt;
例如:
给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],

    <span class="number">3</span>
   / \
  <span class="number">9</span>  <span class="number">20</span>
    /  \
   <span class="number">15</span>   <span class="number">7</span>
   
返回：
[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]
&lt;!--￼<span class="number">58</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="从上到下打印二叉树ii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树ii"></a> 从上到下打印二叉树II</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题32II）：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>算法流程：</p>
<ul>
<li>特例处理：当前结点为空，则返回列表[]</li>
<li>初始化： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；
<ul>
<li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li>
<li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；
<ul>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ul>
</li>
<li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: List[List[int]]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            tmp = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):
                node = queue.popleft()
                tmp.append(node.val)
                <span class="keyword">if</span> node.left:
                    queue.append(node.left)
                <span class="keyword">if</span> node.right:
                    queue.append(node.right)
            res.append(tmp)
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">60</span>--&gt;
例如:
给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],

    <span class="number">3</span>
   / \
  <span class="number">9</span>  <span class="number">20</span>
    /  \
   <span class="number">15</span>   <span class="number">7</span>
   
返回其层次遍历结果：

[
  [<span class="number">3</span>],
  [<span class="number">20</span>,<span class="number">9</span>],
  [<span class="number">15</span>,<span class="number">7</span>]
]
&lt;!--￼<span class="number">61</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题33）：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例1： </span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：数组长度 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>后序遍历定义：<code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li>二叉搜索树定义： 左子树中所有节点的值 &lt;根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
</li>
<li>
<blockquote>
<ul>
<li>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p>
</li>
<li>
<p>剑指offer：</p>
<ul>
<li><strong>相关题目</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和本题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根节点的值</li>
<li><strong>举一反三</strong>：如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归分治：根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p>
<ul>
<li>递归解析：
<ul>
<li><strong>终止条件：</strong> 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i≥j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，说明此子树结点数量≤1，无需判别正确性，因此直接返回true。</li>
<li>递推工作：
<ul>
<li>划分左右子树：遍历后序遍历[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时可划分出左子树区间[i,m-1]，右子树区间[m,j-1]，根节点索引j。</li>
<li><strong>判断是否为二叉搜索树：</strong>
<ul>
<li>左子树区间[i,m-1]内的所有结点都应小于postorder[j]。而上一步划分左右子树的步骤，已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间[m,j-1]内的所有结点都应大于postorder[j]。实现方式为遍历，当遇到小于等于postorder[j]的结点则跳出，否则可通过p=j判断是否为二叉搜索树。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> &amp;&amp;连接
<ul>
<li>p = j：判断此树是否正确</li>
<li>recur(i, m-1)：判断此树的左子树是否正确</li>
<li>recur(m, j - 1)：判断此树的右子树是否正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span>
        <span class="string">"""
        :type postorder: List[int]
        :rtype: bool
        """</span>
        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span>
            <span class="keyword">if</span> i &gt;= j:
                <span class="keyword">return</span> <span class="literal">True</span>
            p = i
            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:
                p += <span class="number">1</span>
            m = p
            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:
                p += <span class="number">1</span>
            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j <span class="number">-1</span>)
        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)
&lt;!--￼<span class="number">63</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题34）：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点的值得和刚好等于输入的整数，则当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父节点。因此我们在函数退出之前要再路径上删除当前结点并减去当前结点的值，以确保返回父节点时路径刚好是从根节点到父节点的路径。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+路径记录</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>pathSum(root, sum)</code> 函数：</strong>
<ul>
<li><strong>初始化：</strong> 结果列表 <code>res</code> ，路径列表 <code>path</code> 。</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li><strong><code>recur(root, tar) 函数：</code></strong>
<ul>
<li><strong>递推参数：</strong> 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</li>
<li><strong>终止条件：</strong> 若节点 <code>root</code> 为空，则直接返回。</li>
<li><strong>递推工作</strong>
<ul>
<li>路径更新： 将当前节点值 <code>root.val</code> 加入路径 <code>path</code> ；</li>
<li>目标值更新： <code>tar = tar - root.val</code>（即目标值 <code>tar</code> 从 <code>sum</code> 减至 00 ）；</li>
<li>路径记录： 当 ① <code>root</code> 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 <code>path</code> 加入 <code>res</code> 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop()</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>值得注意的是</strong>，记录路径时若直接执行 <code>res.append(path)</code> ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。正确做法：<code>res.append(list(path))</code> ，相当于复制了一个 path 并加入到 res 。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """</span>
        res, path = [], []
        
        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, tar)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> 
            path.append(root.val)
            tar -= root.val
            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
                res.append(list(path))
            recur(root.left, tar)
            recur(root.right, tar)
            path.pop()
        recur(root, sum)
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">64</span>--&gt;
输入：head = [[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]
输出：[[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]

输入：head = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]
输出：[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]

输入：head = [[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]
输出：[[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]

输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
&lt;!--￼<span class="number">65</span>--&gt;

- 优化迭代

  - 不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个链表结点的旁边拷贝，比如 A-&gt;B-&gt;C 变成 A-&gt;A<span class="string">'-&gt;B-&gt;B'</span>-&gt;C-&gt;C<span class="string">'，然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A'</span>-&gt;B<span class="string">'-&gt;C'</span>，最后返回 A<span class="string">'-&gt;B'</span>-&gt;C<span class="string">'。

  - 时间复杂度：O(N)

  - 空间复杂度：O(1)

  - ```python
    """
    # Definition for a Node.
    class Node:
        def __init__(self, x, next=None, random=None):
            self.val = int(x)
            self.next = next
            self.random = random
    """
    class Solution(object):
        def copyRandomList(self, head):
            """
            :type head: Node
            :rtype: Node
            """
            if not head:
                return head
            cur = head
            while cur:
                new_node = Node(cur.val,None,None)   # 克隆新结点
                new_node.next = cur.next
                cur.next = new_node   # 克隆新结点在cur 后面
                cur = new_node.next   # 移动到下一个要克隆的点
            cur = head
    
            while cur:  # 链接random
                cur.next.random = cur.random.next if cur.random else None
                cur = cur.next.next
    
            cur_old_list = head # 将两个链表分开
            cur_new_list = head.next
            new_head = head.next
            while cur_old_list:
                cur_old_list.next = cur_old_list.next.next
                cur_new_list.next = cur_new_list.next.next if cur_new_list.next else None
                cur_old_list = cur_old_list.next
                cur_new_list = cur_new_list.next
            return new_head
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 二叉搜索树与双向链表</span><br><span class="line"></span><br><span class="line">## 题目</span><br><span class="line"></span><br><span class="line">- 难度：中等</span><br><span class="line"></span><br><span class="line">- 题目（leetcode-面试题36）：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</span><br><span class="line"></span><br><span class="line">  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</span><br><span class="line"></span><br><span class="line">  特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">- **Tips**：中序遍历</span><br><span class="line"></span><br><span class="line">- &gt; 参考：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof&#x2F;solution&#x2F;mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5&#x2F;</span><br><span class="line"></span><br><span class="line">- 思想：</span><br><span class="line"></span><br><span class="line">  - 本文解法基于性质：二叉搜索树的中序遍历为 **递增序列** 。</span><br><span class="line">  - 将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</span><br><span class="line">    - **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点；</span><br><span class="line">    - **双向链表**：在构建相邻节点（设前驱节点pre，当前结点cur）关系时，应该满足&#96;pre.right &#x3D; cur&#96;，&#96;cur.left &#x3D; pre&#96;</span><br><span class="line">    - **循环链表**： 设链表头节点 head 和尾节点 tail，则应构建 &#96;head.left &#x3D; tail&#96;和 &#96;tail.right &#x3D; head。&#96;</span><br><span class="line"></span><br><span class="line">- 算法流程：</span><br><span class="line"></span><br><span class="line">  - **&#96;dfs(cur):&#96;** 递归法中序遍历；</span><br><span class="line">    - **终止条件：** 当节点 cur为空，代表越过叶节点，直接返回；</span><br><span class="line">    - 递归左子树，即 &#96;dfs(cur.left)&#96; ；</span><br><span class="line">    - **构建链表：**</span><br><span class="line">      - **当 pre为空时：** 代表正在访问链表头节点，记为 head 。</span><br><span class="line">      - **当 pre 不为空时**： 修改双向节点引用，即 pre.right &#x3D; cur， cur.left &#x3D; pre。</span><br><span class="line">      - **保存cur**：更新pre &#x3D; cur，即节点cur是后继节点的pre</span><br><span class="line">    - 递归右子树，即&#96;dfs(cur.left)&#96;</span><br><span class="line">  - **&#96;treeToDoublyList(root)：&#96;**</span><br><span class="line">    - **特例处理：** 若节点 root 为空，则直接返回；</span><br><span class="line">    - **初始化**： 空节点 pre ；</span><br><span class="line">    - **转化为双向链表**： 调用 &#96;dfs(root)&#96; ；</span><br><span class="line">    - 构建循环链表： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head和 pre 的双向节点引用即可。</span><br><span class="line">    - 返回值： 返回链表的头节点 head 即可。</span><br><span class="line"></span><br><span class="line">- 时间复杂度：O(N)</span><br><span class="line"></span><br><span class="line">- 空间复杂度：O(N)</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # Definition for a Node.</span><br><span class="line">  class Node(object):</span><br><span class="line">      def __init__(self, val, left&#x3D;None, right&#x3D;None):</span><br><span class="line">          self.val &#x3D; val</span><br><span class="line">          self.left &#x3D; left</span><br><span class="line">          self.right &#x3D; right</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  class Solution(object):</span><br><span class="line">      def treeToDoublyList(self, root):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type root: Node</span><br><span class="line">          :rtype: Node</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          def dfs(cur):</span><br><span class="line">              if not cur:</span><br><span class="line">                  return</span><br><span class="line">              dfs(cur.left) # 递归左子树</span><br><span class="line">              if self.pre: # 修改节点引用</span><br><span class="line">                  self.pre.right, cur.left &#x3D; cur, self.pre</span><br><span class="line">              else: # 记录头节点</span><br><span class="line">                  self.head &#x3D; cur</span><br><span class="line">              self.pre &#x3D; cur # 保存 cur</span><br><span class="line">              dfs(cur.right) # 递归右子树</span><br><span class="line">          </span><br><span class="line">          if not root:</span><br><span class="line">              return</span><br><span class="line">          self.pre &#x3D; None</span><br><span class="line">          dfs(root)</span><br><span class="line">          self.head.left, self.pre.right &#x3D; self.pre, self.head</span><br><span class="line">          return self.head</span><br></pre></td></tr></table></figure>

</span></code></pre>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># 牛客网解答</span>
<span class="comment"># -*- coding:utf-8 -*-</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span>
        <span class="comment"># write code here</span>
        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:
            <span class="keyword">return</span> pRootOfTree
        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree.left <span class="keyword">and</span> <span class="keyword">not</span> pRootOfTree.right:
            <span class="keyword">return</span> pRootOfTree
        <span class="comment"># 处理左子树</span>
        self.Convert(pRootOfTree.left)
        left=pRootOfTree.left
 
        <span class="comment"># 连接根与左子树最大结点</span>
        <span class="keyword">if</span> left:
            <span class="keyword">while</span>(left.right):
                left=left.right
            pRootOfTree.left,left.right=left,pRootOfTree
 
        <span class="comment"># 处理右子树</span>
        self.Convert(pRootOfTree.right)
        right=pRootOfTree.right
 
        <span class="comment"># 连接根与右子树最小结点</span>
        <span class="keyword">if</span> right:
            <span class="keyword">while</span>(right.left):
                right=right.left
            pRootOfTree.right,right.left=right,pRootOfTree
             
        <span class="keyword">while</span>(pRootOfTree.left):
            pRootOfTree=pRootOfTree.left
        <span class="keyword">return</span> pRootOfTree
&lt;!--￼<span class="number">67</span>--&gt;
你可以将以下二叉树：

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">3</span>
     / \
    <span class="number">4</span>   <span class="number">5</span>

序列化为 <span class="string">"[1,2,3,null,null,4,5]"</span>
&lt;!--￼<span class="number">68</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="字符串的排列"><a class="markdownIt-Anchor" href="#字符串的排列"></a> 字符串的排列</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题38）：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= s 的长度 &lt;= 8</p>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>求所有可能出现在第一个位置的字符,即把第一个字符和后面所有的字符进行交换</li>
<li>固定第一个字符，求后面所有字符的排列，这时候，可以把后面的所有字符分为两部分，后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N!)</p>
</li>
<li>
<p>空间复杂度：O(N^2)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span>
        <span class="string">"""
        :type s: str
        :rtype: List[str]
        """</span>
        n = len(s)
        <span class="keyword">if</span> n == <span class="number">1</span>:
            <span class="keyword">return</span> [s]
        <span class="keyword">else</span>:
            res = []
            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
                ch = s[i] <span class="comment">#取出s中每一个字符</span>
                dic = s[:i] + s[i + <span class="number">1</span> :]
                <span class="keyword">for</span> x <span class="keyword">in</span> self.permutation(dic):
                    res.append(ch + x) <span class="comment">#将ch 和子问题的解依次组合</span>
        <span class="keyword">return</span> list(set(res))
&lt;!--￼<span class="number">70</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#数组中出现次数超过一半的数字"></a> 数组中出现次数超过一半的数字</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题39）：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，要注意以下问题：</p>
<ul>
<li>是否可以修改数组？</li>
<li>特例考虑，数组为空，或数组中不存在元素出现的次数超过数组长度一半</li>
</ul>
</li>
<li>
<p>思路：有三种思路</p>
<ul>
<li>第一种思路，对数组排序，数组n/2位置就是所求的数字。
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
<li>第二种思路，哈希表，遍历一遍数组，记录每个元素出现的次数，返回次数超过数组长度一半的数字
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>第三种思路，<strong>投票法</strong>，数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减一。如果次数为零，我们需要保存下一个数字，并把次数设置为1。由于我们要找的数字出现的次数比其他所有数字出现的次数和要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment">#投票法</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span>
        vote = <span class="number">0</span>
        count = <span class="number">0</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> nums:
            <span class="keyword">if</span> vote == <span class="number">0</span>:
                x = num
            vote += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> nums:
            <span class="keyword">if</span> num == x:
                count += <span class="number">1</span>
        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>
&lt;!--￼<span class="number">72</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="最小的k个数"><a class="markdownIt-Anchor" href="#最小的k个数"></a> 最小的k个数</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题40）：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解排序"><a class="markdownIt-Anchor" href="#题解排序"></a> 题解（排序）</h2>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
</search>
