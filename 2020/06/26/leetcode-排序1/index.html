<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>leetcode-排序1 | </title><meta name="description" content="leetcode-排序1"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="leetcode-排序1"><meta name="twitter:description" content="leetcode-排序1"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="leetcode-排序1"><meta property="og:url" content="https://lesylin.com/2020/06/26/leetcode-%E6%8E%92%E5%BA%8F1/"><meta property="og:site_name" content=""><meta property="og:description" content="leetcode-排序1"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/06/26/leetcode-%E6%8E%92%E5%BA%8F1/"><link rel="prev" title="leetcode-贪心" href="https://lesylin.com/2020/06/27/leetcode-%E8%B4%AA%E5%BF%83/"><link rel="next" title="leetcode-排序" href="https://lesylin.com/2020/06/24/leetcode-%E6%8E%92%E5%BA%8F/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 前言</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#215-数组中的第k个最大元素"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text"> 215-数组中的第k个最大元素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#347-前k个高频元素"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text"> 347-前k个高频元素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#451-根据字符出现频率排序"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text"> 451-根据字符出现频率排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#75-颜色分类"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text"> 75-颜色分类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#215-数组中的第k个最大元素"><span class="toc-number">1.1.</span> <span class="toc-text"> 215-数组中的第k个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-前k个高频元素"><span class="toc-number">1.2.</span> <span class="toc-text"> 347-前k个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-2"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#451-根据字符出现频率排序"><span class="toc-number">1.3.</span> <span class="toc-text"> 451-根据字符出现频率排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-3"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-颜色分类"><span class="toc-number">1.4.</span> <span class="toc-text"> 75-颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目-4"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解-4"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">leetcode-排序1</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-06-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-27</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">4.2k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 16分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾完八大排序，刷一下leetcode中排序的经典题目。</p>
<ul>
<li>215-数组中的第k个最大元素</li>
<li>347-前k个高频元素</li>
<li>451-根据字符出现频率排序</li>
<li>75-颜色分类</li>
</ul>
<h2 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215-数组中的第k个最大元素</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
</li>
</ul>
<h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3>
<ul>
<li>思路：Topk问题 和 kth 问题，可以使用快排和堆排序。</li>
<li>快排步骤
<ul>
<li>挑选基准值：从数列中挑出一个元素，称为&quot;基准&quot;（pivot）;</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快排递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            i = low - <span class="number">1</span>  <span class="comment">#最小元素索引</span></span><br><span class="line">            pivot = arr[high]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">              	<span class="comment"># 当前元素小于或等于pivot</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> low &lt; high:</span><br><span class="line">                pi = partition(arr, low, high)</span><br><span class="line">                quickSort(arr, low, pi - <span class="number">1</span>)</span><br><span class="line">                quickSort(arr, pi + <span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#快排非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            i = low - <span class="number">1</span></span><br><span class="line">            pivot = arr[high]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr, low, high)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            stack = [len(arr) - <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                low = stack.pop()</span><br><span class="line">                high = stack.pop()</span><br><span class="line">                index = partition(arr, low, high)</span><br><span class="line">                <span class="keyword">if</span> low &lt; index - <span class="number">1</span>:</span><br><span class="line">                    stack.append(index - <span class="number">1</span>)</span><br><span class="line">                    stack.append(low)</span><br><span class="line">                <span class="keyword">if</span> high &gt; index + <span class="number">1</span>:</span><br><span class="line">                    stack.append(high)</span><br><span class="line">                    stack.append(index + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最坏情况，存在倒序数组，此时递归树画出来是链表。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>堆排序步骤：（大顶堆升序）</p>
<ul>
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)；</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素；</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素；</li>
<li>如此反复进行交换、重建、交换，直到整个序列有序。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆排序-大顶堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span></span><br><span class="line">            largest = i</span><br><span class="line">            l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]:</span><br><span class="line">                largest = l</span><br><span class="line">            <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]:</span><br><span class="line">                largest = r</span><br><span class="line">            <span class="keyword">if</span> largest != i:</span><br><span class="line">                arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">                heapify(arr, n, largest)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">            n = len(arr)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                heapify(arr, n, i)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">                heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        heapSort(nums)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(Nlogk)，大小为 k 的堆中添加元素的时间复杂度为 O(logk)，我们将重复该操作 N 次，故总时间复杂度为O(Nlogk)。</li>
<li>空间复杂度：O(k)，存储堆元素</li>
<li>在 Python 的 <code>heapq</code> 库中有一个 <code>nlargest</code> 方法，具有同样的时间复杂度，能将代码简化到只有一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>另一种一行的代码sorted()，时间复杂度：O(NlogN)，空间复杂度：O(1)。</p>
</li>
<li>
<blockquote>
<p>python中，sorted和sort区别：<a href="https://www.runoob.com/python/python-func-sorted.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-sorted.html</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)[-k]</span><br></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素"><a class="markdownIt-Anchor" href="#347-前k个高频元素"></a> 347-前k个高频元素</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个非空的整数数组，返回其中出现频率前 k高的元素。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的<strong>时间复杂度必须优于 O(n log n)</strong> , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</li>
</ul>
<h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3>
<ul>
<li>
<p>思路：哈希表/桶排序</p>
</li>
<li>
<p>哈希表</p>
<ul>
<li>现将数组中的数写到dict={}中</li>
<li>对哈希表中的value排序</li>
<li>取前k个值对应的key</li>
</ul>
</li>
<li>
<blockquote>
<p>涉及知识点：</p>
<ul>
<li>python字典排序：
<ul>
<li><a href="https://blog.csdn.net/tangtanghao511/article/details/47810729" target="_blank" rel="noopener">https://blog.csdn.net/tangtanghao511/article/details/47810729</a></li>
<li><a href="https://blog.csdn.net/liuweiyuxiang/article/details/98944416" target="_blank" rel="noopener">https://blog.csdn.net/liuweiyuxiang/article/details/98944416</a></li>
<li>格式：
<ul>
<li>lambda 参数列表：return [表达式] 变量</li>
<li>由于lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收</li>
</ul>
</li>
</ul>
</li>
<li>lambda函数的用法：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528</a></li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[num] += <span class="number">1</span></span><br><span class="line">        dict = sorted(dict.items(), key = <span class="keyword">lambda</span> items:items[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict:</span><br><span class="line">            res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(Nlogk)，遍历一遍数组O(N)，N为数组长度，字典排序时间复杂度：O(Nlogk)，k是k个键值对数</p>
</li>
<li>
<p>空间复杂度：O(K)，dict存储键值对K，res存储key值K个，O(2K)。</p>
</li>
<li>
<p>思路：桶排序</p>
<ul>
<li>当桶个数很大的时候，就是计数排序。基于桶排序的计数排序的过程，第一步就是需要统计原数组中各个数字的出现的频率，使用的方法是，先遍历出原始数组，找到最大值maxValue和最小值minValue，开辟maxValue-minValue大小的计数器数组counter。如nums =[2, 1, 3, 1, 5]， counter = [2, 1, 1, 0, 1] ， counter[0] 表示值 0 + minValue = 1 出现了2次。（1出现2次）。</li>
<li>这和上述哈希表统计各个数字出现的次数效果一样，时间复杂度和空间复杂度都是一样的，哈希表效果相对较好，原因是：当maxValue-minValue过大时，会产生内存浪费。</li>
<li>统计完各个数字出现的频率后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。时间复杂度上优化了对字典的排序。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>根据value获取key的三种方法：
<ul>
<li><a href="https://blog.csdn.net/weixin_41712499/article/details/89284930" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41712499/article/details/89284930</a></li>
</ul>
</li>
<li>python常用的字典操作：
<ul>
<li>dict.values()：Python 字典(Dictionary) values() 函数以列表返回字典中的所有值。</li>
<li>dict.items()：Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。</li>
</ul>
</li>
<li>append和extend的区别：
<ul>
<li><a href="https://www.jianshu.com/p/d83053742cb9" target="_blank" rel="noopener">https://www.jianshu.com/p/d83053742cb9</a></li>
<li><a href="https://blog.csdn.net/dpengwang/article/details/79102305" target="_blank" rel="noopener">https://blog.csdn.net/dpengwang/article/details/79102305</a></li>
<li>append：简单的说，append是直接在list后面添加元素，该元素是什么样就添加什么样。如a = [1,2,3]，b=[4]，a.append(b)–&gt;[1,2,3[4]]</li>
<li>extend：extend是扩展，在原有List上进行修改，没有返回值，可以扩展不同类型的变量，并将其内容以List变量的形式加入到原List中。如果extend的是字符串，则字符串会被拆分成字符数组，如果extend的是字典，则字典的key会被加入到List中。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        max_time = max(dict.values()) <span class="comment">#获取出现的最大次数</span></span><br><span class="line">        TongList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(max_time + <span class="number">1</span>)] <span class="comment">#根据最大次数生成桶</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict.items():</span><br><span class="line">            TongList[value].append(key)  <span class="comment">#将索引value放入key对应的字典索引 eg1:[[],[3],[2],[1]]</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_time, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment">#按桶索引排序</span></span><br><span class="line">            <span class="keyword">if</span> TongList[i]:</span><br><span class="line">                res.extend(TongList[i])  <span class="comment">#如果是append，eg1:[[1],[2]]</span></span><br><span class="line">            <span class="keyword">if</span> len(res) &gt;= k:</span><br><span class="line">                <span class="keyword">return</span> res[:k]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<blockquote>
<p>思路：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/yi-xing-python3dai-ni-zou-jin-counterlei-by-jimmy0/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/solution/yi-xing-python3dai-ni-zou-jin-counterlei-by-jimmy0/</a></p>
<ul>
<li>统计每个数的频率，输出最大的几个，这完全迎合了Python中的Counter类，调用其的几个方法即可。</li>
<li>什么是Counter？
<ul>
<li>Counter 是一个在collections包里的类，正如其名，是一个用于计数的工具。</li>
<li>我们可以用Counter(nums)这样的构造函数构造一个Counter类，其中nums是一个列表。</li>
<li>构造好的Counter实例可以看作一个字典，键是nums的每一项，值是它的出现次数。</li>
<li>如果上面的叙述让你感到很混乱的话，我不妨举个例子。
<ul>
<li>如果一个列表a = [1,1,3,4,3]，你想要统计每项的出现次数，那么你使用b = Counter(a)，那么这时候b就像一个这样的字典{1:2,3:2,4:1}，表示数字1出现了2次，数字3出现了2次，数字4出现了1次。</li>
<li>还是很好理解的吧？</li>
<li>可是题目里要我们输出的是最多的K项</li>
<li>这时候可以应用Counter的一个函数，most_common(k)</li>
<li>这个函数就是返回最多出现的K项</li>
<li>但是返回的形式是一个元祖列表，类似[(1,2),(3,2),(4,1)]的形式</li>
<li>我们只需要键也就是第一项，所以要使用列表生成式处理一下即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="keyword">not</span> k <span class="keyword">or</span> k &gt; len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>
<h2 id="451-根据字符出现频率排序"><a class="markdownIt-Anchor" href="#451-根据字符出现频率排序"></a> 451-根据字符出现频率排序</h2>
<h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。</span><br><span class="line">因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3>
<ul>
<li>思路：本题和347题思路一致，只是在处理返回结果时操作不同：
<ul>
<li>哈希表+字典排序：
<ul>
<li>将字符串转为list，遍历一遍list，获取每个字符出现的频率</li>
<li>sorted函数倒序排序字典</li>
<li>初始化list保存字符出现频率按降序排序后的结果</li>
<li>遍历降序排序好的字典的键值对，当value（频率）≥1时，说明该字符（key）出现≥1次，那就append value次对应的key。</li>
<li>将list转为字符串返回即可。</li>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>桶排序：
<ul>
<li>将字符串转为list，遍历一遍list，获取每个字符出现的频率</li>
<li>获取最大出现次数</li>
<li>根据最大出现次数生成桶</li>
<li>将索引value放入key对应的字典索引</li>
<li>初始化res保存字符出现频率按降序排序后的结果</li>
<li>按桶索引i倒排序，如果对应桶索引有值，就遍历桶中的元素j，把每个元素逐一添加i次。</li>
<li>将list转为字符串</li>
<li>时间复杂度：O(n)，O(max_time^2 * len(TongList) )</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#哈希表 + 字典排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i] += <span class="number">1</span></span><br><span class="line">        dict = sorted(dict.items(), key = <span class="keyword">lambda</span> items: items[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict:</span><br><span class="line">            <span class="keyword">while</span> value &gt;= <span class="number">1</span>:</span><br><span class="line">                res.append(key)</span><br><span class="line">                value -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        max_times = max(dict.values())</span><br><span class="line">        TongList = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(max_times + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict.items():</span><br><span class="line">            TongList[value].append(key)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_times, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> TongList[i]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> TongList[i]:</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                        res.append(j)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类"></a> 75-颜色分类</h2>
<h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
</li>
<li>
<p>注意：不能使用代码库中的排序函数来解决这道题。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进阶：</p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li>
<li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个<strong>仅使用常数空间的一趟扫描算法</strong>吗？</li>
</ul>
</li>
</ul>
<h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3>
<ul>
<li>
<p>思路：一次遍历和两次遍历</p>
<ul>
<li>
<p>两次遍历（非原地）：（如果没有要求原地处理数组，那是可以的，注意审题，题目要求的是原地处理！因为没注意审题，纠结了很久）</p>
<ul>
<li>用哈希表统计每个元素出现的个数</li>
<li>按照key值排序</li>
<li>初始化数组res保存返回结果</li>
<li>按照排好序的键值对填充数组res</li>
</ul>
</li>
<li>
<p>两次遍历（原地）：</p>
<ul>
<li>初始化数组res，由于最多只有3种颜色，res长度为3。</li>
<li>统计每个数字出现的次数，下标对应数字，数组值对应次数</li>
<li>初始化指针j指向nums第一个位置</li>
<li>依次读取每个数字出现的次数，对nums进行重写</li>
</ul>
</li>
<li>
<p>一次遍历：</p>
<ul>
<li>
<p>类似”冒泡“思想，遇到小的值就上浮到顶部，遇到大的值就下沉到底部。</p>
</li>
<li>
<p>需要使用三个指针，p0用来确定0的右边界、p2用来确定2的左边界、curr用来当前元素</p>
</li>
<li>
<p>沿着数组移动 <code>curr</code> 指针，若<code>nums[curr] = 0</code>，则将其与 <code>nums[p0]</code>互换；若 <code>nums[curr] = 2</code> ，则与 <code>nums[p2]</code>互换。</p>
</li>
<li>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</p>
<ul>
<li>初始化当前考虑的元素序号 ：curr = 0.</li>
</ul>
</li>
<li>
<p>While curr &lt;= p2 :</p>
<ul>
<li>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。
<ul>
<li>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</li>
</ul>
</li>
<li>若 nums[curr] = 1 ：将指针curr右移。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#两次遍历（原地）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        color = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#统计每个数字出现的次数，下标对应数字，数组值对应次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:  </span><br><span class="line">            color[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        j = <span class="number">0</span>  <span class="comment">#初始化指针j指向nums第一个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#依次读取每个数字出现的次数，对nums进行重写</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(color[m]):</span><br><span class="line">                nums[j] = m</span><br><span class="line">                j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m为元素种类数，n为每种元素的出现的次数</li>
<li>空间复杂度：O(m)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0</span></span><br><span class="line">        <span class="comment"># curr是当前考虑元素的下标</span></span><br><span class="line">        p0 = curr = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2</span></span><br><span class="line">        p2 = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr &lt;= p2:</span><br><span class="line">            <span class="keyword">if</span> nums[curr] == <span class="number">0</span>:</span><br><span class="line">                nums[p0], nums[curr] = nums[curr], nums[p0]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                curr +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[curr] == <span class="number">2</span>:</span><br><span class="line">                nums[curr], nums[p2] = nums[p2], nums[curr]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，遍历一遍数组，n为数组长度</li>
<li>空间复杂度：O(1)，额外使用三个指针</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/06/26/leetcode-%E6%8E%92%E5%BA%8F1/">https://lesylin.com/2020/06/26/leetcode-%E6%8E%92%E5%BA%8F1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/27/leetcode-%E8%B4%AA%E5%BF%83/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>leetcode-贪心</span></div></a></div><div class="next-post pull_right"><a href="/2020/06/24/leetcode-%E6%8E%92%E5%BA%8F/"><img class="next_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>leetcode-排序</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>