<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>剑指offer1 | </title><meta name="description" content="剑指offer1"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="剑指offer1"><meta name="twitter:description" content="剑指offer1"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="剑指offer1"><meta property="og:url" content="https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/"><meta property="og:site_name" content=""><meta property="og:description" content="剑指offer1"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/"><link rel="prev" title="百面机器学习-特征工程" href="https://lesylin.com/2020/06/21/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"><link rel="next" title="剑指offer" href="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据流中的中位数"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 数据流中的中位数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#连续子数组的最大和"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 连续子数组的最大和</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1~n整数中1出现的次数"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 1~n整数中1出现的次数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数字序列中某一位的数字"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 数字序列中某一位的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#把数组排成最小的数"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 把数组排成最小的数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-5"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-5"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#把数字翻译成字符串"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 把数字翻译成字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-6"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-6"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#礼物的最大价值"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 礼物的最大价值</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-7"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-7"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#最长不含重复字符的子字符串"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 最长不含重复字符的子字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-8"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-8"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#丑数"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text"> 丑数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-9"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-9"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第一个只出现一次的字符"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text"> 第一个只出现一次的字符</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-10"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-10"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中的逆序对"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text"> 数组中的逆序对</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-11"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-11"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#两个链表的第一个公共节点"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text"> 两个链表的第一个公共节点</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-12"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-12"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#在排序数组中查找数字i"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text"> 在排序数组中查找数字I</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-13"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-13"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#0~n-1中缺失的数字"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text"> 0~n-1中缺失的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-14"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-14"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉搜索树第k大节点"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text"> 二叉搜索树第k大节点</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-15"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-15"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉树的深度"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text"> 二叉树的深度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-16"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-16"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#平衡二叉树"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text"> 平衡二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-17"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-17"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中数字出现的次数"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text"> 数组中数字出现的次数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-18"><span class="toc_mobile_items-number">18.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-18"><span class="toc_mobile_items-number">18.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中数字出现的次数ii"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text"> 数组中数字出现的次数II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-19"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-19"><span class="toc_mobile_items-number">19.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#和为s的两个数字"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text"> 和为s的两个数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-20"><span class="toc_mobile_items-number">20.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-20"><span class="toc_mobile_items-number">20.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#和为s的连续正数序列"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text"> 和为s的连续正数序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-21"><span class="toc_mobile_items-number">21.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-21"><span class="toc_mobile_items-number">21.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#翻转单词顺序"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text"> 翻转单词顺序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-22"><span class="toc_mobile_items-number">22.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-22"><span class="toc_mobile_items-number">22.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#左旋转字符串"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text"> 左旋转字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-23"><span class="toc_mobile_items-number">23.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-23"><span class="toc_mobile_items-number">23.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#滑动窗口的最大值"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text"> 滑动窗口的最大值</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-24"><span class="toc_mobile_items-number">24.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-24"><span class="toc_mobile_items-number">24.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#队列的最大值"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text"> 队列的最大值</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-25"><span class="toc_mobile_items-number">25.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-25"><span class="toc_mobile_items-number">25.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#n个骰子的点数"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text"> n个骰子的点数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-26"><span class="toc_mobile_items-number">26.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-26"><span class="toc_mobile_items-number">26.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#扑克牌中的顺子"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text"> 扑克牌中的顺子</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-27"><span class="toc_mobile_items-number">27.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-27"><span class="toc_mobile_items-number">27.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#圆圈中最后剩下的数字"><span class="toc_mobile_items-number">28.</span> <span class="toc_mobile_items-text"> 圆圈中最后剩下的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-28"><span class="toc_mobile_items-number">28.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-28"><span class="toc_mobile_items-number">28.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#股票的最大利润"><span class="toc_mobile_items-number">29.</span> <span class="toc_mobile_items-text"> 股票的最大利润</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-29"><span class="toc_mobile_items-number">29.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-29"><span class="toc_mobile_items-number">29.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#求12n"><span class="toc_mobile_items-number">30.</span> <span class="toc_mobile_items-text"> 求1+2+…+n</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-30"><span class="toc_mobile_items-number">30.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-30"><span class="toc_mobile_items-number">30.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#不用加减乘除做加法"><span class="toc_mobile_items-number">31.</span> <span class="toc_mobile_items-text"> 不用加减乘除做加法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-31"><span class="toc_mobile_items-number">31.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-31"><span class="toc_mobile_items-number">31.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#构建乘积数组"><span class="toc_mobile_items-number">32.</span> <span class="toc_mobile_items-text"> 构建乘积数组</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-32"><span class="toc_mobile_items-number">32.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-32"><span class="toc_mobile_items-number">32.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#把字符串转换成整数"><span class="toc_mobile_items-number">33.</span> <span class="toc_mobile_items-text"> 把字符串转换成整数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-33"><span class="toc_mobile_items-number">33.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-33"><span class="toc_mobile_items-number">33.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉搜索树的最近公共祖先"><span class="toc_mobile_items-number">34.</span> <span class="toc_mobile_items-text"> 二叉搜索树的最近公共祖先</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-34"><span class="toc_mobile_items-number">34.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-34"><span class="toc_mobile_items-number">34.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉树的最近公共祖先"><span class="toc_mobile_items-number">35.</span> <span class="toc_mobile_items-text"> 二叉树的最近公共祖先</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-35"><span class="toc_mobile_items-number">35.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-35"><span class="toc_mobile_items-number">35.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据流中的中位数"><span class="toc-number">1.</span> <span class="toc-text"> 数据流中的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">1.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-number">1.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连续子数组的最大和"><span class="toc-number">2.</span> <span class="toc-text"> 连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-2"><span class="toc-number">2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-number">2.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1~n整数中1出现的次数"><span class="toc-number">3.</span> <span class="toc-text"> 1~n整数中1出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-3"><span class="toc-number">3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-number">3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数字序列中某一位的数字"><span class="toc-number">4.</span> <span class="toc-text"> 数字序列中某一位的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-4"><span class="toc-number">4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-number">4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#把数组排成最小的数"><span class="toc-number">5.</span> <span class="toc-text"> 把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-5"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-number">5.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#把数字翻译成字符串"><span class="toc-number">6.</span> <span class="toc-text"> 把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-6"><span class="toc-number">6.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-number">6.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#礼物的最大价值"><span class="toc-number">7.</span> <span class="toc-text"> 礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-7"><span class="toc-number">7.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-7"><span class="toc-number">7.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最长不含重复字符的子字符串"><span class="toc-number">8.</span> <span class="toc-text"> 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-8"><span class="toc-number">8.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-8"><span class="toc-number">8.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#丑数"><span class="toc-number">9.</span> <span class="toc-text"> 丑数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-9"><span class="toc-number">9.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-9"><span class="toc-number">9.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个只出现一次的字符"><span class="toc-number">10.</span> <span class="toc-text"> 第一个只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-10"><span class="toc-number">10.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-10"><span class="toc-number">10.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中的逆序对"><span class="toc-number">11.</span> <span class="toc-text"> 数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-11"><span class="toc-number">11.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-11"><span class="toc-number">11.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两个链表的第一个公共节点"><span class="toc-number">12.</span> <span class="toc-text"> 两个链表的第一个公共节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-12"><span class="toc-number">12.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-12"><span class="toc-number">12.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在排序数组中查找数字i"><span class="toc-number">13.</span> <span class="toc-text"> 在排序数组中查找数字I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-13"><span class="toc-number">13.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-13"><span class="toc-number">13.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0~n-1中缺失的数字"><span class="toc-number">14.</span> <span class="toc-text"> 0~n-1中缺失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-14"><span class="toc-number">14.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-14"><span class="toc-number">14.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树第k大节点"><span class="toc-number">15.</span> <span class="toc-text"> 二叉搜索树第k大节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-15"><span class="toc-number">15.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-15"><span class="toc-number">15.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树的深度"><span class="toc-number">16.</span> <span class="toc-text"> 二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-16"><span class="toc-number">16.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-16"><span class="toc-number">16.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">17.</span> <span class="toc-text"> 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-17"><span class="toc-number">17.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-17"><span class="toc-number">17.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中数字出现的次数"><span class="toc-number">18.</span> <span class="toc-text"> 数组中数字出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-18"><span class="toc-number">18.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-18"><span class="toc-number">18.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中数字出现的次数ii"><span class="toc-number">19.</span> <span class="toc-text"> 数组中数字出现的次数II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-19"><span class="toc-number">19.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-19"><span class="toc-number">19.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#和为s的两个数字"><span class="toc-number">20.</span> <span class="toc-text"> 和为s的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-20"><span class="toc-number">20.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-20"><span class="toc-number">20.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#和为s的连续正数序列"><span class="toc-number">21.</span> <span class="toc-text"> 和为s的连续正数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-21"><span class="toc-number">21.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-21"><span class="toc-number">21.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#翻转单词顺序"><span class="toc-number">22.</span> <span class="toc-text"> 翻转单词顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-22"><span class="toc-number">22.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-22"><span class="toc-number">22.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#左旋转字符串"><span class="toc-number">23.</span> <span class="toc-text"> 左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-23"><span class="toc-number">23.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-23"><span class="toc-number">23.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#滑动窗口的最大值"><span class="toc-number">24.</span> <span class="toc-text"> 滑动窗口的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-24"><span class="toc-number">24.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-24"><span class="toc-number">24.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列的最大值"><span class="toc-number">25.</span> <span class="toc-text"> 队列的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-25"><span class="toc-number">25.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-25"><span class="toc-number">25.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#n个骰子的点数"><span class="toc-number">26.</span> <span class="toc-text"> n个骰子的点数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-26"><span class="toc-number">26.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-26"><span class="toc-number">26.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扑克牌中的顺子"><span class="toc-number">27.</span> <span class="toc-text"> 扑克牌中的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-27"><span class="toc-number">27.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-27"><span class="toc-number">27.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#圆圈中最后剩下的数字"><span class="toc-number">28.</span> <span class="toc-text"> 圆圈中最后剩下的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-28"><span class="toc-number">28.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-28"><span class="toc-number">28.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#股票的最大利润"><span class="toc-number">29.</span> <span class="toc-text"> 股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-29"><span class="toc-number">29.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-29"><span class="toc-number">29.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#求12n"><span class="toc-number">30.</span> <span class="toc-text"> 求1+2+…+n</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-30"><span class="toc-number">30.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-30"><span class="toc-number">30.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不用加减乘除做加法"><span class="toc-number">31.</span> <span class="toc-text"> 不用加减乘除做加法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-31"><span class="toc-number">31.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-31"><span class="toc-number">31.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构建乘积数组"><span class="toc-number">32.</span> <span class="toc-text"> 构建乘积数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-32"><span class="toc-number">32.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-32"><span class="toc-number">32.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#把字符串转换成整数"><span class="toc-number">33.</span> <span class="toc-text"> 把字符串转换成整数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-33"><span class="toc-number">33.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-33"><span class="toc-number">33.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树的最近公共祖先"><span class="toc-number">34.</span> <span class="toc-text"> 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-34"><span class="toc-number">34.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-34"><span class="toc-number">34.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树的最近公共祖先"><span class="toc-number">35.</span> <span class="toc-text"> 二叉树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-35"><span class="toc-number">35.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-35"><span class="toc-number">35.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指offer1</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-06-13<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-24</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">20.1k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 80分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="数据流中的中位数"><a class="markdownIt-Anchor" href="#数据流中的中位数"></a> 数据流中的中位数</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题41）：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line"></span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line"></span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line"></span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：最多会对 <code>addNum、findMedia</code>进行 <code>50000</code> 次调用。</p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：优先队列/堆</p>
<ul>
<li><strong>什么是优先队列</strong>？
<ul>
<li>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：
<ul>
<li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li>
<li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li>
</ul>
</li>
<li>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：
<ul>
<li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li>
<li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li>
</ul>
</li>
<li>由于删除堆顶元素时的时间复杂度为 O(logN)，因此在优先队列中入队和出队操作的时间复杂度也是 O(logN)。</li>
</ul>
</li>
<li><strong>注意：Python 中没有大顶堆，只能将值取负保存在小顶堆来模拟</strong>。为了方便理解，将堆用优先队列表示。即<strong>Python 中 heapq 模块是小顶堆</strong>。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。</li>
</ul>
</li>
<li>
<p>思路：</p>
<ul>
<li>首先，建立一个小顶堆A和大顶堆B，各保存列表的一半元素，且规定：
<ul>
<li>A保存较大的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
<li>B保存较小的一半，长度为N/2（N为偶数）或（N+1）/2（N为奇数）</li>
</ul>
</li>
<li>然后，中位数可仅根据A，B的堆顶元素计算得到。
<ul>
<li>小顶堆A（存储较大的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>m</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_m,a_{m-1},...,a_3,a_2,a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
<li>大顶堆B（存储较小的一半）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b1,b2,b3,...,b_{n-1},b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">b</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是堆顶。</li>
</ul>
</li>
<li>设共有N = m + n个元素，规定添加元素时保证：
<ul>
<li>m = n + 1 = （N + 1）/ 2 （N为奇数）</li>
<li>m = n = N / 2（N为偶数）</li>
<li>当m≠n，中位数是a1</li>
<li>当m=n，中位数是（a1 + b1）/ 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>设元素总数为 N = m + n ，其中 m和 n分别为 A和 B中的元素个数。</li>
<li><strong><code>addNum(num)</code> 函数</strong>
<ol>
<li>当 m = n（即 N为 偶数）：需向 A添加一个元素。实现方法：将新元素 num插入至 B ，再将 B堆顶元素插入至 A。</li>
<li>当m≠n（即N为奇数）：需向B添加一个元素。实现方法将新元素插入至A，再将A堆顶元素插入至B。
<ul>
<li>假设插入数字 num遇到情况 1. 。由于 num可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B保存较小一半。</li>
</ul>
</li>
</ol>
</li>
<li><strong><code>findMedian()</code> 函数：</strong>
<ul>
<li>当m≠n，（N为奇数）：则中位数是A堆顶的元素</li>
<li>当m=n，（N为偶数）：则中位数是（A堆顶元素 + B堆顶元素） / 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：</p>
<ul>
<li>查找中位数O(1)：获取堆顶元素使用O(1)时间</li>
<li>添加数字O(logN)：堆的插入和弹出操作需要O(logN)时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = [] <span class="comment">#小顶堆，保存较大的一半</span></span><br><span class="line">        self.B = [] <span class="comment">#大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网python写法，GetMedian需要加个参数，否则python版会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.min_heap = [] <span class="comment">#小顶堆，保存较大的一半</span></span><br><span class="line">        self.max_heap = [] <span class="comment">#大顶堆，保存较小的一半</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(self.min_heap) != len(self.max_heap):</span><br><span class="line">            heappush(self.max_heap, -heappushpop(self.min_heap, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.min_heap, -heappushpop(self.max_heap, -num))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, n = None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.min_heap[<span class="number">0</span>] <span class="keyword">if</span> len(self.min_heap) != len(self.max_heap) <span class="keyword">else</span> (self.min_heap[<span class="number">0</span>] - self.max_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="连续子数组的最大和"><a class="markdownIt-Anchor" href="#连续子数组的最大和"></a> 连续子数组的最大和</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题42）：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li><strong>状态定义</strong>：设动态规划列表dp，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
<ul>
<li>为何定义最大和 dp[i]中必须包含元素 nums[i]：保证 dp[i]递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。</li>
</ul>
</li>
<li><strong>转移方程</strong>：若dp[i-1]≤0，说明dp[i -1]对dp[i]产生负贡献，即dp[i-1] + nums[i]还不如nums[i]本身大。
<ul>
<li>当dp[i-1]≤ 0时：执行dp[i] = nums[i]</li>
<li>当dp[i-1]&gt;0时：执行dp[i] = dp[i-1] + nums[i]</li>
</ul>
</li>
<li><strong>初始状态</strong>：dp[0] = nums[0]，即以nums[0]结尾的连续子数组最大和为 nums[0]。</li>
<li><strong>返回值：</strong> 返回 dp 列表中的最大值，代表全局最大值。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_sum = nums[<span class="number">0</span>] <span class="comment">#保存连续子数组最大和</span></span><br><span class="line">        cur_sum = nums[<span class="number">0</span>] <span class="comment">#保存当前连续子数组最大和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; cur_sum + nums[i]:</span><br><span class="line">                cur_sum = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_sum = cur_sum + nums[i]</span><br><span class="line">            max_sum = max(cur_sum, max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态规划分析写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="1~n整数中1出现的次数"><a class="markdownIt-Anchor" href="#1~n整数中1出现的次数"></a> 1~n整数中1出现的次数</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题43）：输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">1 ≤ n &lt; 2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：数字规律  + 递归</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>用一个稍微大一点的数字：21345为例。我们把从1到21345的所有数字分为两段，一段是从1到1345，另一段是从1346到21345。
<ul>
<li>原因：因为把21345的最高位去掉就变成1345，便于采用递归思路。</li>
</ul>
</li>
<li>先看从1346到21345中1出现的次数。1的出现分为两种情况。
<ul>
<li>首先分析1出现在最高位（例子是万位）的情况。从1346到21345的数字中，1出现在10000~19999这10000个数字的万位，一共出现了10000（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)个。
<ul>
<li>值得注意的是，并不是对所有5位数而言在万位出现的次数都是10000个。对于万位是1的数字比如输入12345，1只出现在10000~12345的万位，出现的次数不是10000次，而是2346次，也就是除去最高数字之后剩下的数字再加上1（即2345+1=2346次）</li>
</ul>
</li>
<li>接着分析1出现在除最高位之外的其他四位数中的情况。例子中1346<sub>21345这20000个数字中后4位中1出现的次数是2000次。由于最高位是2，我们可以再把13456</sub>21345分为两段，1346<sub>11345和11346</sub>21345。每一段剩下4位数字中，选择其中其中一位是1，其余三位可以在0~9这10个数字中任意选择，因此根据排列组合原则，总共出现的次数是2000次。</li>
<li>从1~1345中1的出现次数，可以用递归求得。</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/pythondi-gui-by-rainiee-pan/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)，循环内的计算操作使用 O(1)时间；循环次数为数字 n的位数，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{10}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_s = str(n) </span><br><span class="line">        high = int(num_s[<span class="number">0</span>])  </span><br><span class="line">        Pow = <span class="number">10</span> ** (len(num_s) - <span class="number">1</span>) </span><br><span class="line">        last = n - high * Pow</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> high == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last) + last + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Pow + high * self.countDigitOne(Pow - <span class="number">1</span>) + self.countDigitOne(last)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>第一个return</strong>：举例：1234，<code>countDigitOne(pow-1)</code>表示 0-999 出现过多少次 1，<code>countDigitOne(last)</code>指 1000-1234 后三位出现过多少次 1（与 0-234 出现的次数相同），<code>last</code> 表示 1001-1234 最高位的 1 出现了多少次 1，最后一个 1 表示 1000 这个数最高位的 1。</p>
</li>
<li>
<p><strong>第二个return</strong>： 举例：2234 ，<code>high*self.countDigitOne(pow-1)</code>就是指，从 1~999 以及 1001~1999 这两个阶段后三位出现了多少次 1，<code>self.countDigitOne(last)</code>是指从 2000 到 2234 出现了多少次 1（和 0~234 相同，因为首位不为 1），<code>Pow</code> 指是指从 1000~1999 最高位一共出现了 1000 次 1</p>
</li>
</ul>
<h1 id="数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#数字序列中某一位的数字"></a> 数字序列中某一位的数字</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题44）：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= n &lt; 2^31</p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：数字规律 + 迭代+求整/求余</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/zhe-shi-yi-dao-shu-xue-ti-ge-zhao-gui-lu-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/zhe-shi-yi-dao-shu-xue-ti-ge-zhao-gui-lu-by-z1m/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>
<p>规律：</p>
<table>
<thead>
<tr>
<th>123456789</th>
<th>1011…9899</th>
<th>100101…998999</th>
</tr>
</thead>
<tbody>
<tr>
<td>9个数</td>
<td>90个数</td>
<td>900个数</td>
</tr>
<tr>
<td>9*1位</td>
<td>90*2位</td>
<td>900*3位</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对于第 n 位对应的数字，我们令这个数字对应的数为 <code>target</code>，然后分三步进行。</p>
<ol>
<li>首先找到这个数字对应的数是几位数，用 <code>digits</code> 表示；</li>
<li>然后确定这个对应的数的数值 <code>target</code>；</li>
<li>最后确定返回值是 <code>target</code> 中的哪个数字。</li>
</ol>
</li>
<li>
<p>举例：输入365</p>
<ul>
<li>经过第一步计算我们可以得到第365个数字表示的是三位数，<code>digits = 3</code>， <code>n = 365 - 9 - 90*2 = 176</code>。这时n = 176表示目标数字是三位数中的第176个数字。</li>
<li>我们设目标数字所在的数为 number，计算得到 number=100+176/3=158，idx 是目标数字在 number 中的索引，如果 idx = 0，表示目标数字是 number 中的最后一个数字。</li>
<li>根据步骤2，我们可以计算得到 idx = n % digits = 176 % 3 = 2，说明目标数字应该是 number = 158 中的第二个数字，即输出为 5。</li>
</ul>
</li>
<li>
<p>掌握了方法之后可以对代码进行简化，思路与之前一样，这里注意的是 <code>first_num</code> 表示每组数的第一个数。即1位数的组的1，二位数的组的10，三位数的组的100…</p>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(logn)，将数字转为字符串需要O(logn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        digit, start, count = <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span> <span class="comment">#digit是位数+=1、start是起始数字 = start*10、count是数位数量=9*digit*start</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; count: <span class="comment"># 1. 确定n所在数字的位数，循环执行n减去一位数、两位数的数位数量，因此n是从start开始计数的</span></span><br><span class="line">            n -= count</span><br><span class="line">            start *= <span class="number">10</span></span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span> * start * digit  <span class="comment"># 结论：所求数位①在某个digit位数中；②为从数字start开始的第n个数位。</span></span><br><span class="line">        num = start + (n - <span class="number">1</span>) // digit <span class="comment"># 2.确定所求数位所在的数字，结论：所求数位在数字 num中，start为第0个数</span></span><br><span class="line">        <span class="keyword">return</span> int(str(num)[(n - <span class="number">1</span>) % digit]) <span class="comment"># 3.确定所求数位在num的哪一数位，数字的首个数位为第0位，所求数位是 res</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把数组排成最小的数"><a class="markdownIt-Anchor" href="#把数组排成最小的数"></a> 把数组排成最小的数</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题45）：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<code>0 &lt; nums.length &lt;= 100</code></p>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：排序规则</p>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li>根据题目要求，两个数字m和n能拼接成数字mn和nm。如果mn&lt;nm，那么我们应该打印出mn，也就是m应该排在n的前面，我们定义此时m小于n；反之，如果nm&lt;mn，我们定义n小于m。如果mn=nm，m等于n。在下文中符号&quot;&lt;&quot;，&quot;&gt;“和”=&quot;表示常规意义的数值的大小关系，而文字“大于”、“小于”和等于表示我们新定义的大小关系。</li>
<li>接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字mn和nm并比较它们的大小。直接用数值计算不难办到，但需要考虑到一个潜在的问题就是m和n都在int能表达的范围内，但把它们拼起来的数字mn和nm用int表示就有可能溢出了，所以还隐藏大数问题。</li>
<li>一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外，由于把数字m和n拼接起来得到mn和nm，它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了</li>
</ul>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>特例判断：当数组为空，返回空字符串</li>
<li>将数组每个元素依次转换为字符串</li>
<li>两两组合，小的放前面，再拼接起来，如5+3&gt;3+5，把3放5前面</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; nums[j] + nums[i]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(nums)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把数字翻译成字符串"><a class="markdownIt-Anchor" href="#把数字翻译成字符串"></a> 把数字翻译成字符串</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题46）：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：0 &lt;= num &lt; 2^31</p>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/</a></p>
</blockquote>
</li>
<li>
<p>动态规划解析：</p>
<ul>
<li>记数字num第i位数字为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，数字num的位数为n
<ul>
<li>例如，num=12258，n=5，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i]代表以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为结尾的数字的翻译方案数量。</li>
<li><strong>转移方程</strong>：若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>组成的两位数字可以被翻译，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>，否则，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>
<ul>
<li>可被翻译的两位数区间：当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{i-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，组成的两位数是无法被翻译的，（例如：00，01…)，因此区间为[10,25]。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i -1] + dp[i -2]， 10x_{i-1} + x_i∈[10,25]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">，</mi><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>99</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1]， 10x_{i-1} + x_i ∈[0,10)∪(25,99]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
<li><strong>初始状态</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0] = dp[1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即无数字和第1位数字的翻译方法数均为1</li>
<li><strong>返回值</strong>：dp[n]</li>
</ul>
</li>
<li>
<p>无数字情况 dp[0] = 1 从何而来？</p>
<ul>
<li>当 num第 1, 2 位的组成的数字∈[10,25] 时，显然应有 2种翻译方法，即 dp[2] = dp[1] + dp[0] = 2 ，而显然 dp[1] = 1，因此推出 dp[0] = 1 。</li>
</ul>
</li>
<li>
<p>为方便获取数字的各位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，考虑先将数字 num转化为字符串 s ，通过遍历 s 实现动态规划。</p>
</li>
<li>
<p>通过字符串切片s[i-2:i]获取组合数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">10x_{i-1} + x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.852771em;vertical-align:-0.208331em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，通过对比字符串ASCII码判断字符串对应数字区间</p>
</li>
<li>
<p>空间优化：由于dp[i]只和dp[i-1]有关，因此可使用两个变量 a, b分别记录 dp[i], dp[i - 1]，两变量交替前进即可。此方法可省去 dp列表使用的 O(N)的额外空间。</p>
</li>
<li>
<p>时间复杂度：O(N)， N为字符串 s的长度（即数字 num的位数log(num) ），其决定了循环次数。</p>
</li>
<li>
<p>空间复杂度：O(N)，字符串使用O(N)额外空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            a, b = (a + b <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i - <span class="number">2</span>:i] &lt;= <span class="string">"25"</span> <span class="keyword">else</span> a), a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="礼物的最大价值"><a class="markdownIt-Anchor" href="#礼物的最大价值"></a> 礼物的最大价值</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题47）：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>0 &lt; grid.length &lt;= 200</code></li>
<li><code>0 &lt; grid[0].length &lt;= 200</code></li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<blockquote>
<ul>
<li>参考<strong>动态规划</strong>解析：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<p>时间复杂度：O(MN)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>: grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以上代码逻辑清晰，和转移方程直接对应，但仍可提升效率：当 grid矩阵很大时， i = 0 或 j = 0的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n): <span class="comment"># 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m): <span class="comment"># 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#最长不含重复字符的子字符串"></a> 最长不含重复字符的子字符串</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题48）：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：s.length &lt;= 40000</p>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：滑动窗口 + 双指针</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>题目中要求答案必须是 子串 的长度，意味着子串内的字符在原字符串中一定是连续的。因此我们可以将答案看作原字符串的一个滑动窗口，并维护窗口内不能有重复字符，同时更新窗口的最大值。</li>
<li>我们可以使用哈希表记录每个字符的下一个索引，然后尽量向右移动尾指针来拓展窗口，并更新窗口的最大长度。如果尾指针指向的元素重复，则将头指针直接移动到窗口中重复元素的右侧。</li>
<li>算法步骤：
<ul>
<li><code>tail</code> 指针向末尾方向移动；</li>
<li>如果尾指针指向的元素存在于哈希表中：<code>head</code> 指针跳跃到重复字符的下一位；</li>
<li>更新哈希表和窗口长度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)， 字符的 ASCII 码范围为 0 ~ 127，哈希表 dic 最多使用 O(128) = O(1) 大小的额外空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        head, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> tail <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[tail] <span class="keyword">in</span> dic:</span><br><span class="line">                head = max(dic[s[tail]], head)</span><br><span class="line">            dic[s[tail]] = tail + <span class="number">1</span></span><br><span class="line">            res = max(res, tail - head + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="丑数"><a class="markdownIt-Anchor" href="#丑数"></a> 丑数</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题49）：我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong>1690</li>
</ul>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：动态规划</p>
</li>
<li>
<p>思路：创建数组保存已经找到的丑数，用空间换时间。丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “丑数 == 某较小丑数 × 某因子” （例如：10=5×2）。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></li>
<li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/%EF%BC%88%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0%E5%8F%82%E8%80%83%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/（思路描述参考）</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>,n):</span><br><span class="line">            n2 = dp[a] * <span class="number">2</span></span><br><span class="line">            n3 = dp[b] * <span class="number">3</span></span><br><span class="line">            n5 = dp[c] * <span class="number">5</span></span><br><span class="line">            dp[i] = min(n2, n3, n5)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#第一个只出现一次的字符"></a> 第一个只出现一次的字符</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题50）：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= s 的长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>哈希表</strong></p>
</li>
<li>
<blockquote>
<p>剑指offer：如果需要判断多个字符是不是在某个字符串里出现过或统计多个字符在某个字符串出现的次数，我们可以考虑基于数组创建一个简单的哈希表。</p>
</blockquote>
</li>
<li>
<p>思路：遍历一遍字符串，统计每个字符出现的次数；再遍历一次字符串，确定每个字符串出现的次数，即可找到第一个只出现一次的字符。</p>
</li>
<li>
<p>时间复杂度：O(2N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题51）：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把数组分隔成子数组，先统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个排序的过程实际上就是<strong>归并排序</strong>。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, start, mid, end)</span>:</span></span><br><span class="line">            i, j, temp = start, mid + <span class="number">1</span>, []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                    temp.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.cnt += mid - i + <span class="number">1</span></span><br><span class="line">                    temp.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                temp.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                nums[start + i] = temp[i]</span><br><span class="line">                    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            mergeSort(nums, start, mid)</span><br><span class="line">            mergeSort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">            merge(nums, start, mid,  end)</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br></pre></td></tr></table></figure>
<h1 id="两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#两个链表的第一个公共节点"></a> 两个链表的第一个公共节点</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>难度：简单</li>
<li>题目（leetcode-面试题52）：输入两个链表，找出它们的第一个公共节点。</li>
<li>注意：
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针</p>
</li>
<li>
<p>思路：有四种方法</p>
<ol>
<li>可以暴力求解，分别遍历两个链表，看是否有重合的结点，时间复杂度：O(mn)</li>
<li>利用辅助栈：可以将两个链表放入栈中，比较栈顶元素（链表长度相同）</li>
<li>分别得到两个链表的长度，计算链表差n，然后设置双指针，让长链表先走n步，然后两个链表一起走，看是否有相同的点。</li>
<li>设置双指针指向两个链表头，然后一起走，指针A遍历完一个链A后，指向另一个链B的头，指针B同理，直到两个指针指向的结点相同，即若存在公共节点则返回公共节点，若不存在，两个指针都会指向null节点。
<ul>
<li>假设链表A长度是m，链表B是n，公共部分是b，那么走过m+n+b步之后一定会相遇，返回结果。 如果没有公共部分，b=0， 那么走过m+n都指向None，返回None</li>
</ul>
</li>
</ol>
</li>
<li>
<p>时间复杂度：O(m+n)，m，n分别为两个链表的长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路4</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1 = headA</span><br><span class="line">        l2 = headB</span><br><span class="line">        <span class="keyword">while</span> l1 != l2:</span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> headB</span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="在排序数组中查找数字i"><a class="markdownIt-Anchor" href="#在排序数组中查找数字i"></a> 在排序数组中查找数字I</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题53I）：统计一个数字在排序数组中出现的次数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：二分查找</p>
</li>
<li>
<p>思路：有两种</p>
<ul>
<li>遍历一遍数组，用哈希表记录每个数出现的次数，返回target出现的次数。时间复杂度和空间复杂度都是O(n)</li>
<li>用二分查找确定数组第一个target和最后一个target的位置，计算两个位置的下标之差。时间复杂度：O(logn)，空间复杂度：O(1)</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 搜索右边界 right</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt;= target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        right = i</span><br><span class="line">        <span class="comment"># 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] != target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 搜索左边界 left</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        left = j</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>简化代码：<code>helper()</code> 函数旨在查找数字 tar在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。即<strong>找target的右边界和target-1的右边界。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tar)</span>:</span></span><br><span class="line">            i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= tar: i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> helper(target) - helper(target - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#0~n-1中缺失的数字"></a> 0~n-1中缺失的数字</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题53II）：<strong>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内</strong>。在范围0～n-1内的n个数字中<strong>有且只有一个数字不在该数组中</strong>，请找出这个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：二分法，<strong>排序数组中的搜索问题，首先想到 二分法 解决。</strong></p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>根据题意，数组可以按照以下规则划分为两部分。
<ul>
<li>左子数组：nums[i] = i</li>
<li>右子数组：nums[i] ≠ i</li>
</ul>
</li>
<li>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>初始化左边界，i = 0， 右边界， j = len(nums) - 1，代表闭区间[i,j]。</li>
</ul>
</li>
<li>
<p>循环二分：当i &lt;= j时循环（当闭区间i，j为空时，跳出）</p>
<ul>
<li>计算中点 m = (i + j) // 2，其中 “//” 为向下取整除法；</li>
<li>若 nums[m] = m ，则 “右子数组的首位元素” 一定在闭区间 [m + 1, j]中，因此执行 i = m + 1；</li>
<li>若 nums[m] ≠ m ，则 “左子数组的末位元素” 一定在闭区间 [i, m - 1]中，因此执行 j = m - 1；</li>
<li><strong>返回值：</strong> 跳出时，变量 i和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉搜索树第k大节点"><a class="markdownIt-Anchor" href="#二叉搜索树第k大节点"></a> 二叉搜索树第k大节点</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题54）：给定一棵二叉搜索树，请找出其中第k大的节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 ≤ k ≤ 二叉搜索树元素个数</p>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>二叉搜索树的中序遍历为递增序列</strong>（中序遍历+提前返回）</p>
<ul>
<li><strong>python-self参数含义小结</strong>：<a href="https://blog.csdn.net/houhuipeng/article/details/91948827" target="_blank" rel="noopener">https://blog.csdn.net/houhuipeng/article/details/91948827</a></li>
<li><strong>self后面的不是模块级的变量，是类/实例级的变量，就是在你定义的类里，是可以访问到的。</strong></li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/</a></p>
</blockquote>
</li>
<li>
<p>思路：求 “二叉搜索树第 k大的节点” 可转化为求 “此树的中序遍历倒序的第 k个节点”。</p>
<ul>
<li>为求第 k 个节点，需要实现以下 三项工作 ：
<ol>
<li>递归遍历时计数，统计当前节点的序号；</li>
<li>递归到第 k个节点时，应记录结果 res；</li>
<li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>递归解析</strong>：</p>
<ul>
<li><strong>终止条件：</strong> 当节点 root为空（越过叶节点），则直接返回；</li>
<li><strong>递归右子树：</strong> 即 dfs(root.right)；</li>
<li><strong>三项工作</strong>：
<ol>
<li>提前返回： 若 k = 0 ，代表已找到目标节点，无需继续遍历，因此直接返回；</li>
<li>统计序号： 执行 k = k - 1 （即从 k减至 0 ）；</li>
<li>记录结果： 若 k = 0 ，代表当前节点为第 k大的节点，因此记录 res = root.val ；</li>
</ol>
</li>
<li><strong>递归左子树：</strong> 即 dfs(root.left)；</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.k, self.res = k, <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right)</span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">            inorder(root.left)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树的深度"><a class="markdownIt-Anchor" href="#二叉树的深度"></a> 二叉树的深度</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55I）：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：后序遍历/层序遍历</p>
<ul>
<li>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；
<ul>
<li><strong>常见的 DFS ：</strong> 先序遍历、中序遍历、后序遍历；</li>
<li><strong>常见的 BFS ：</strong> 层序遍历（即按层遍历）。</li>
</ul>
</li>
<li>树的后序遍历/深度优先搜索往往利用<strong>递归或栈</strong>。
<ul>
<li><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</li>
</ul>
</li>
<li>树的层序遍历 / 广度优先搜索往往利用 <strong>队列</strong> 实现。
<ul>
<li><strong>关键点：</strong> 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>思路：<strong>递归-后序遍历</strong></p>
<ul>
<li><strong>终止条件</strong>：当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li><strong>递推工作</strong>：本质上是对树做后序遍历
<ul>
<li>计算结点<code>root</code>的左子树深度，即调用<code>maxDepth(root.left)</code></li>
<li>计算节点 <code>root</code> 的 <strong>右子树的深度</strong> ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回 <strong>此树的深度</strong> ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：<strong>队列-层序遍历</strong></p>
<ul>
<li><strong>特例处理</strong>：当<code>root</code>为空，直接返回深度0</li>
<li><strong>初始化：</strong> 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li><strong>循环遍历：</strong> 当 <code>queue</code> 为空时跳出。
<ul>
<li>初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li>
<li>遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入 <code>tmp</code>；</li>
<li>更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>；</li>
<li>统计层数： 执行 <code>res += 1</code> ，代表层数加 11；</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题55II）：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line"> </span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>1 &lt;= 树的结点个数 &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<ul>
<li>
<p><strong>思路</strong>：</p>
<ul>
<li>先序遍历+判断深度（自顶向下），比较容易想到。
<ul>
<li>构造一个depth函数递归计算二叉树的左右子树高度</li>
<li>比较左右子树高度差是否≤1，判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(NlogN)，最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。</p>
<ul>
<li>满二叉树高度的复杂度 O(log N) ，将满二叉树按层分为 log (N+1) 层；</li>
<li>总体时间复杂度 == 每层执行复杂度× 层数复杂度 = O(N×logN) 。</li>
</ul>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>思路</strong>：后序遍历+剪枝（从底至顶）：</p>
<ul>
<li>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</li>
<li>算法流程：
<ul>
<li><strong><code>recur(root)</code> 函数：</strong>
<ul>
<li><strong>返回值</strong>
<ul>
<li>当节点root左/右子树的深度差&lt;=1：则返回当前子树的深度，即节点root的左/右子树的深度最大值 + 1</li>
<li>当节点root左/右子树的深度差＞2：则返回-1，代表此子树不是平衡树</li>
</ul>
</li>
<li><strong>终止条件</strong>
<ul>
<li>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 0</li>
<li>当左（右）子树深度为-1，代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 -1；</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>isBalanced(root)</code> 函数：</strong>
<ul>
<li><strong>返回值：</strong> 若 <code>recur(root) != -1</code> ，则说明此树平衡，返回 true ； 否则返回 false 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = recur(root.left)</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            right = recur(root.right)</span><br><span class="line">            <span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> max(left, right) + <span class="number">1</span> <span class="keyword">if</span> abs(left - right) &lt;= <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> recur(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中数字出现的次数"><a class="markdownIt-Anchor" href="#数组中数字出现的次数"></a> 数组中数字出现的次数</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题56I）：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：2 &lt;= nums.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<blockquote>
<ul>
<li>异或类型题目的总结：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/xiang-xi-zong-jie-kan-bu-dong-ni-gen-wo-xing-xi-li/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>异或有这样的性质：
<ul>
<li>0<sup>a=a，a</sup>a=0，a<sup>a</sup>a=a</li>
</ul>
</li>
<li>设所求的两个数为x,y，先将所有元素都异或，得到结果r，r其实就是x与y的异或。由于x!=y，r肯定不为0，即在其二进制形式中存在1，我们从右向左找第一个为1的位置（其实只要能找到任意一位为1的位置即可），记录其位置为i。这样通过i便可将数组分为两部分，一部分元素的二进制在i处为0，另一部分为1。x与y必定分散在这两部分中，而且相同的数都会在同一部分。将这两部分分别异或，结果便为x，y。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span>  <span class="comment"># 所有数字异或的结果</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ret ^= n</span><br><span class="line">        <span class="comment"># 找到第一位不是0的</span></span><br><span class="line">        h = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(ret &amp; h == <span class="number">0</span>):</span><br><span class="line">            h &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 根据该位是否为0将其分为两组</span></span><br><span class="line">            <span class="keyword">if</span> (h &amp; n == <span class="number">0</span>):</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中数字出现的次数ii"><a class="markdownIt-Anchor" href="#数组中数字出现的次数ii"></a> 数组中数字出现的次数II</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题56II）：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：位运算 / 字典 / 排序 /数学方法</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/pythonti-jie-san-chong-fang-shi-man-zu-mian-shi-gu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/pythonti-jie-san-chong-fang-shi-man-zu-mian-shi-gu/</a></p>
</blockquote>
</li>
<li>
<p>思路：位运算</p>
<ul>
<li>我们想一下如果一个数字出现三次,那么他的二进制位表示的每一位(0或1)也出现了三次.如果把所有出现三次的数字的二进制表示的每一位都分别加起来,那么每一位的和都能被3整除</li>
<li>我们把所有数字的二进制位的每一位加起来.若果某一位的和能被3整除,那么那个只出现一次的数字二进制表示中对应的那一位为0,否则为1</li>
<li>步骤：
<ul>
<li>统计所有数字二进制位的和</li>
<li>判断每一位的和能否被3整除,求解最后结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        bitSum = [<span class="number">0</span>] *<span class="number">32</span> <span class="comment">#定义存储各个位的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums: <span class="comment">#统计各位之和</span></span><br><span class="line">            mask = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(<span class="number">32</span>)):</span><br><span class="line">                <span class="keyword">if</span> mask &amp; i:</span><br><span class="line">                    bitSum[j] += <span class="number">1</span></span><br><span class="line">                mask = mask &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#得到最终结果</span></span><br><span class="line">            result = result &lt;&lt; <span class="number">1</span></span><br><span class="line">            result += bitSum[i] % <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="和为s的两个数字"><a class="markdownIt-Anchor" href="#和为s的两个数字"></a> 和为s的两个数字</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57I）：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针 / 字典</p>
</li>
<li>
<p>思路：双指针：</p>
<ul>
<li>根据题意，是递增排序数组，可以初始化两个指针，分别指向数组的第一个元素和最后一个元素，即<code>i = 0, j = len(nums) - 1</code></li>
<li>当i &lt; j时，判断nums[i] + nums[j]的和是否等于target，如果等于，则输出这两个数，如果大于，将j前移。如果小于，将i后移。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s = nums[i] + nums[j] </span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> nums[i], nums[j]</span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典，空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = target - num</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> dic[a], num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = num</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="和为s的连续正数序列"><a class="markdownIt-Anchor" href="#和为s的连续正数序列"></a> 和为s的连续正数序列</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题57II）：输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= target &lt;= 10^5</p>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<ul>
<li>
<p>思路：双指针滑动窗口法</p>
<ul>
<li>针对目前这个题，我们可以把左指针i指向1，右指针j指向2，然后就能计算出当前窗口范围各数字的和，<code>cur_sum = sum(list(range(i,j+1)))</code>，如果cur_sum小于target，说明当前窗口数字之和过小，这时候咱们可以令j += 1，这样我们的新窗口就向右边扩大了。同样的道理，如果cur_sum大于target，这说明我们当前窗口数字之和过大，这时候就令i += 1，这样窗口的左边界就向右边移动了一个单位，就使得窗口变小了。</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/xiang-jie-hua-dong-chuang-kou-fa-qiu-gen-fa-jian-g/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化窗口指针和输出列表</span></span><br><span class="line">        i, j, res = <span class="number">1</span>,<span class="number">2</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滑动窗口的右边界不能超过target的中值</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= target//<span class="number">2</span> + <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 计算当前窗口内数字之和</span></span><br><span class="line">            cur_sum = sum(list(range(i,j+<span class="number">1</span>)))</span><br><span class="line">            <span class="comment"># 若和小于目标，右指针向右移动，扩大窗口</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若和大于目标，左指针向右移动，减小窗口</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum &gt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 相等就把指针形成的窗口添加进输出列表中</span></span><br><span class="line">            <span class="comment"># 别忘了，这里还要继续扩大寻找下一个可能的窗口哦</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(list(range(i,j+<span class="number">1</span>)))</span><br><span class="line">                <span class="comment"># 这里用j+=1，i+=1，i+=2都可以的</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="翻转单词顺序"><a class="markdownIt-Anchor" href="#翻转单词顺序"></a> 翻转单词顺序</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题58I）：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：双指针滑动窗口确定单词</p>
</li>
<li>
<blockquote>
<p>剑指offer：可以进行两次反转，第一次反转所有字符，第二次依次反转每个单词的字符。</p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>去除字符串首尾空格</li>
<li>初始化两个指针，i，j指向字符串最后一个字符</li>
<li>当i大于等于0时，如果当i&gt;=0且s[i]不是空格，i继续前移，如果遇到空格，说明扫描了一个单词，将这个单词加入res，当遇到空格，i前移，并且让j指向i此刻位置，重新开始扫描下一个单词。</li>
<li>最后将列表转为字符串</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        i = j = len(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            res.append(s[i + <span class="number">1</span> : j + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            j = i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="左旋转字符串"><a class="markdownIt-Anchor" href="#左旋转字符串"></a> 左旋转字符串</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题58II）：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：先把字符串分为两部分，由于想把它的前k个字符移到后面，我们就先把前k个字符分隔到第一部分，把后面的所有字符都分到第二部分。然后，分别反转这两个部分，最后反转整个字符串。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：字符串切片、列表遍历拼接、字符串遍历拼接</p>
<ul>
<li>
<p>字符串切片</p>
<ul>
<li>
<p>应用字符串切片函数，可方便实现左旋转字符串。</p>
</li>
<li>
<p>获取字符串 s[n:]切片和 s[:n] 切片，使用 “+” 运算符拼接并返回即可。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>列表遍历拼接</p>
<ul>
<li>
<p>若面试不允许字符串切片，可以使用该方法</p>
</li>
<li>
<p>新建一个 list(Python) ，记为 res ；</p>
</li>
<li>
<p>先向 res 添加 “第 n + 1 位至末位的字符” ；</p>
</li>
<li>
<p>再向 res添加 “首位至第 n 位的字符” ；</p>
</li>
<li>
<p>将 res 转化为字符串并返回。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,len(s)):</span><br><span class="line">            res.append(s[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res.append(s[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>字符串遍历拼接</p>
<ul>
<li>
<p>若面试不允许用join，可以使用该方法</p>
</li>
<li>
<p>新建一个str，记为res</p>
</li>
<li>
<p>遍历字符串，用&quot;+&quot;依次拼接字符串</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(s)):</span><br><span class="line">            res += s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res += s[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>剑指offer方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        s = list(s)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        self.reverse(s, n, len(s) - <span class="number">1</span>)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, len(s) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            s[start], s[end] = s[end], s[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="滑动窗口的最大值"><a class="markdownIt-Anchor" href="#滑动窗口的最大值"></a> 滑动窗口的最大值</h1>
<h2 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题59I）：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
</li>
</ul>
<h2 id="题解-24"><a class="markdownIt-Anchor" href="#题解-24"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：单调队列</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li><strong>初始化</strong>：双端队列deque，结果列表res，数组长度n</li>
<li><strong>滑动窗口</strong>：左边界范围i∈[1-k, n+1-k]，右边界范围j∈[0, n-1]
<ul>
<li>若i＞0且队首元素deque[0]=被删除元素nums[i-1]，则队首元素出队</li>
<li>删除deque内所有＜nums[j]的元素，以保持deque递减</li>
<li>将nums[j]添加至deque尾部</li>
<li>若已形成窗口(即i≥0)，将窗口最大值（即队首元素deque[0]）添加至列表res</li>
</ul>
</li>
<li><strong>返回值</strong>：返回结果列表res</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，其中 n为数组 nums长度；线性遍历 nums占用 O(N)；每个元素最多仅入队和出队一次，因此单调队列 deque占用 O(2N) 。</p>
</li>
<li>
<p>空间复杂度：O(k)，双端队列 deque中最多同时存储 k个元素（即窗口大小）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        <span class="comment">#未形成窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res = [deque[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#形成窗口后</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]: <span class="comment"># 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="队列的最大值"><a class="markdownIt-Anchor" href="#队列的最大值"></a> 队列的最大值</h1>
<h2 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题59II）：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
</li>
</ul>
<h2 id="题解-25"><a class="markdownIt-Anchor" href="#题解-25"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>我们知道对于一个普通队列，push_back 和 pop_front 的时间复杂度都是 O(1)，因此我们直接使用队列的相关操作就可以实现这两个函数。</li>
<li>使用一个双端队列 deque，在每次入队时，如果 deque 队尾元素小于即将入队的元素 value，则将小于 value的元素全部出队后，再将 value 入队；否则直接入队。这时，辅助队列 deque<em>d<strong>e</strong>q<strong>u</strong>e</em> 队首元素就是队列的最大值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        self.que = deque()</span><br><span class="line">        self.sort_que = deque()   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sort_que[<span class="number">0</span>] <span class="keyword">if</span> self.sort_que <span class="keyword">else</span> <span class="number">-1</span>   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.que.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.sort_que <span class="keyword">and</span> self.sort_que[<span class="number">-1</span>] &lt; value:</span><br><span class="line">            self.sort_que.pop()</span><br><span class="line">        self.sort_que.append(value)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.que: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = self.que.popleft()</span><br><span class="line">        <span class="keyword">if</span> res == self.sort_que[<span class="number">0</span>]:</span><br><span class="line">            self.sort_que.popleft()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="n个骰子的点数"><a class="markdownIt-Anchor" href="#n个骰子的点数"></a> n个骰子的点数</h1>
<h2 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题60）：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 11</p>
</li>
</ul>
<h2 id="题解-26"><a class="markdownIt-Anchor" href="#题解-26"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：骰子一共6个面，每个面上都有一个点数，对应的是1~6之间的一个数字。所以n个骰子的点数和的最小值为n，最大值为6n。另外根据排列组合的知识，我们还知道n个骰子的所有点数的排列数位6<sup>n。要解决这个问题，我们需要先统计出每一个点数出现的次数，然后把每一个点数出现的次数除以6</sup>n，就能求出每个点数出现的概率。
<ul>
<li>基于递归求骰子点数，时间效率不够高
<ul>
<li>可以先把n个骰子分为两堆：第一堆只有一个，另一个有n-1个。单独的那一个有可能出现从1到6的点数。我们需要计算1到6的每一种点数和剩下的n-1个骰子来计算点数和。接下来把剩下的n-1个骰子还是分成两堆，第一堆只有一个，第二堆有n-2个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加，再和剩下的n-2骰子来计算点数和。递归的思路，递归结束条件就是最后只剩下一个骰子。我们可以定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组第s-n个元素里。</li>
</ul>
</li>
<li>基于循环求骰子点数，时间性能好
<ul>
<li>我们可以考虑用两个数组来存储骰子点数的每一个总数出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。下一循环中，我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的总和，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/rong-yi-li-jie-de-pythondong-tai-gui-hua-fang-fa-b/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：动态规划</p>
<ul>
<li>
<p><strong>表示状态</strong>：dp[i][j]，表示投掷完i个骰子后，点数j的出现次数</p>
</li>
<li>
<p><strong>找出状态转移方程</strong>：找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。最后一个阶段也就是投掷完 n枚骰子后的这个阶段，我们用 dp[n][j]来表示最后一个阶段点数 j 出现的次数。单单看第 n枚骰子，它的点数可能为 1 , 2, 3, … , 6 ，因此投掷完 n 枚骰子后点数 j出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, … , j-6 出现的次数之和转化过来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (第n枚骰子的点数 i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;</span><br><span class="line">    dp[n][j] +&#x3D; dp[n-1][j - i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>写成数学公式：</p>
<ul>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></munderover><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][j] = \sum^{6}_{i = 1}dp[n-1][j-i]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
</li>
<li>
<p>n表示阶段，j表示投掷完n枚骰子之后的点数和，i表示第n枚骰子会出现的六个点数</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>**边界处理：**这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 1, 2, 3, … , 6，并且每个点数出现的次数都是 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;</span><br><span class="line">    dp[1][i] &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span> * n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="comment">#表示i个骰子投掷出s点的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>  <span class="comment">#表示一个骰子投掷出i点的次数为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment">#表示骰子的个数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i * <span class="number">6</span> + <span class="number">1</span>): <span class="comment">#表示可能会出现的点数之和</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= k + <span class="number">1</span>:</span><br><span class="line">                        dp[i][j] += dp[i - <span class="number">1</span>][j - k] <span class="comment">#当前n个骰子出现的点数之和等于前一次出现的点数之和加上这一次出现的点数</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n,n * <span class="number">6</span> + <span class="number">1</span>):  <span class="comment">#投掷n次点数出现的所有情况</span></span><br><span class="line">            res.append(dp[n][i] * <span class="number">1.0</span> / <span class="number">6</span> ** n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n^2)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h1 id="扑克牌中的顺子"><a class="markdownIt-Anchor" href="#扑克牌中的顺子"></a> 扑克牌中的顺子</h1>
<h2 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题61）：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li>数组长度为 5</li>
<li>数组的数取值为 [0, 13] .</li>
</ul>
</li>
</ul>
<h2 id="题解-27"><a class="markdownIt-Anchor" href="#题解-27"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：首先把数组排序，再统计数组中0的个数，最后统计排序之后的数组中相邻数组之间的空缺总数。如果空缺的总数小于或等于0的个数，那么这个数组就是连续的，反之则不连续。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据题意，此5张牌是顺子的充分条件如下：</p>
<ul>
<li>除大小王外，所有牌<strong>无重复</strong></li>
<li>设此5张牌中最大的牌为max，最小的牌为min（大小王除外），则需满足：max-min&lt;5</li>
</ul>
</li>
<li>
<p>思路：集合set+遍历 、 排序+遍历</p>
<ul>
<li>
<p>集合set+遍历</p>
<ul>
<li>
<p>遍历5张牌，遇到大小王（即0）直接跳过</p>
</li>
<li>
<p>判别重复牌，利用 set实现遍历判重，set的查找方法的时间复杂度为O(1)</p>
</li>
<li>
<p>获取最大牌和最小牌，借助辅助遍历ma和mi，遍历统计即可。</p>
</li>
<li>
<p>时间复杂度： O(N) = O(5) = O(1)， 其中 N为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</p>
</li>
<li>
<p>空间复杂度：O(N)=O(5)=O(1) ，用于判重的辅助 Set 使用 O(N)额外空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        repeat = set()</span><br><span class="line">        ma, mi = <span class="number">0</span>, <span class="number">14</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 跳过大小王</span></span><br><span class="line">            ma = max(ma, num) <span class="comment"># 最大牌</span></span><br><span class="line">            mi = min(mi, num) <span class="comment"># 最小牌</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> repeat: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num) <span class="comment"># 添加牌至 Set</span></span><br><span class="line">        <span class="keyword">return</span> ma - mi &lt; <span class="number">5</span> <span class="comment"># 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>排序+遍历（剑指）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        zero = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                zero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[zero] &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 O(N log N) = O(5 log 5) = O(1)， 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用O(NlogN) 时间。</li>
<li>空间复杂度 O(1) ，变量 joker 使用 O(1)大小的额外空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#圆圈中最后剩下的数字"></a> 圆圈中最后剩下的数字</h1>
<h2 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题62）：0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
</li>
</ul>
<h2 id="题解-28"><a class="markdownIt-Anchor" href="#题解-28"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：约瑟夫环问题，有以下两种解法：</p>
<ol>
<li>用环形链表模拟圆圈的经典解法，时间复杂度：O(mn)，空间复杂度：O(n)</li>
<li>分析每次被删除数字的规律并直接计算出圆圈中最后剩下的数字</li>
</ol>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/</a></li>
<li><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：根据递推公式就可以使用递归或者迭代</p>
<ul>
<li>
<p>迭代：</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            f = (m + f) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="股票的最大利润"><a class="markdownIt-Anchor" href="#股票的最大利润"></a> 股票的最大利润</h1>
<h2 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题63）:假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
</li>
</ul>
<h2 id="题解-29"><a class="markdownIt-Anchor" href="#题解-29"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：动态规划</p>
<ul>
<li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以 prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。</li>
<li><strong>转移方程</strong>：由于题目限定 “买卖该股票一次” ，因此前 i日最大利润 dp[i] 等于前 i - 1日最大利润 dp[i-1]和第 i 日卖出的最大利润中的最大值。
<ul>
<li>前<em>i</em>日最大利润=max(前(<em>i</em>−1)日最大利润,第<em>i</em>日价格−前<em>i</em>日最低价格)</li>
<li>dp[i] = max(dp[i - 1] , prices[i] - min(prices[0:i]))</li>
</ul>
</li>
<li><strong>初始状态</strong>：dp[i] = 0，首日利润为0</li>
<li><strong>返回值</strong>：dp[n-1]，其中n为dp列表长度</li>
<li><strong>效率优化</strong>：
<ul>
<li>时间复杂度降低： 前 i 日的最低价格 min(prices[0:i]) 时间复杂度为 O(i) 。而在遍历 prices时，可以借助一个变量（记为成本 cost ）每日更新最低价格。优化后的转移方程为：
<ul>
<li>dp[i] = max(dp[i - 1] , prices[i] - min(cost, prices[i]))</li>
</ul>
</li>
<li>空间复杂度降低：由于dp[i]只与dp[i-1]，pirces[i]，cost有关，因此可以用一个变量（记为profit）代表dp列表：
<ul>
<li>profit = max(profit, prices[i] - min(cost, prices[i]))</li>
</ul>
</li>
</ul>
</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">0</span> <span class="keyword">or</span> len(prices) &gt; <span class="number">10</span>**<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cost = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            cost = min(cost, price)</span><br><span class="line">            profit = max(profit, price - cost)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="求12n"><a class="markdownIt-Anchor" href="#求12n"></a> 求1+2+…+n</h1>
<h2 id="题目-30"><a class="markdownIt-Anchor" href="#题目-30"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题64）:求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= n &lt;= 10000</p>
</li>
</ul>
<h2 id="题解-30"><a class="markdownIt-Anchor" href="#题解-30"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：通常求1+2+3+…+n，除了用公式n(n+1)/2之外，无外乎循环和递归两种思路。</p>
</li>
<li>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/</a></li>
<li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归使用if判断的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    n += sumNums(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
<ul>
<li>如何替代if做判断？可以用逻辑运算符</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">        self.res += n</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：快速乘</p>
<ul>
<li>
<p>回到本题，由等差数列求和公式我们可以知道 1+2+3+…+n等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，对于除以 2 我们可以用右移操作符来模拟，那么等式变成了 n(n+1)&gt;&gt;1，剩下不符合题目要求的部分即为 n(n+1)，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 n 为 [1,10000]，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。</p>
</li>
<li>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof/solution/pythonkuai-su-jia-de-jie-fa-by-user3935a/</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_a</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.res += a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_by_recursive</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        b &amp; <span class="number">1</span> <span class="keyword">and</span> self.add_a(a)</span><br><span class="line">        b <span class="keyword">and</span> self.sum_by_recursive(a &lt;&lt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a = n</span><br><span class="line">        b = n + <span class="number">1</span></span><br><span class="line">        self.sum_by_recursive(a, b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="不用加减乘除做加法"><a class="markdownIt-Anchor" href="#不用加减乘除做加法"></a> 不用加减乘除做加法</h1>
<h2 id="题目-31"><a class="markdownIt-Anchor" href="#题目-31"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题65）：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
</li>
</ul>
<h2 id="题解-31"><a class="markdownIt-Anchor" href="#题解-31"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：：位运算</p>
<ul>
<li>python负数存储介绍：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/</a></li>
<li>二进制公式推导：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/er-jin-zhi-qiu-he-chao-xiang-xi-da-bai-10000yong-h/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>思路：</p>
<ol>
<li>第一步不考虑进位对每一位相加。0加0、1加1的结果都0，0加1、1加0的结果都是1。这和异或结果一样。</li>
<li>考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时，我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0.</li>
<li>第三步把前两个步骤的结果相加，相加的过程依然是重复前面两步，直到不产生进位为止。</li>
</ol>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x <span class="comment">#计算两个数的二进制补码</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x  <span class="comment">#计算无进位和赋给a，计算进位赋给b</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x) <span class="comment">#~是按位取反运算符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="构建乘积数组"><a class="markdownIt-Anchor" href="#构建乘积数组"></a> 构建乘积数组</h1>
<h2 id="题目-32"><a class="markdownIt-Anchor" href="#题目-32"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题66）：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li><code>a.length &lt;= 100000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-32"><a class="markdownIt-Anchor" href="#题解-32"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：列表格，根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p>
<ul>
<li>算法流程：
<ol>
<li>初始化：数组 B ，其中 B[0] = 1 ；辅助变量 tmp = 1 ；</li>
<li>计算 B[i]的 下三角 各元素的乘积，直接乘入 B[i] ；</li>
<li>计算 B[i] 的 上三角 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li>
<li>返回 B 。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * len(a), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>): </span><br><span class="line">            tmp *= a[i + <span class="number">1</span>] <span class="comment"># 上三角</span></span><br><span class="line">            b[i] *= tmp <span class="comment"># 下三角 * 上三角</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="把字符串转换成整数"><a class="markdownIt-Anchor" href="#把字符串转换成整数"></a> 把字符串转换成整数</h1>
<h2 id="题目-33"><a class="markdownIt-Anchor" href="#题目-33"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题67）:写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 </span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-33"><a class="markdownIt-Anchor" href="#题解-33"></a> 题解</h2>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/die-dai-zheng-ze-biao-da-shi-by-z1m/%EF%BC%88%E8%BF%AD%E4%BB%A3+%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/die-dai-zheng-ze-biao-da-shi-by-z1m/（迭代+正则表达式）</a></li>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-guan-j/%EF%BC%88%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF%E6%8F%8F%E8%BF%B0%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/67ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-guan-j/（面试思路描述）</a></li>
<li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/</a></li>
</ul>
</li>
</ul>
<h1 id="二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉搜索树的最近公共祖先"></a> 二叉搜索树的最近公共祖先</h1>
<h2 id="题目-34"><a class="markdownIt-Anchor" href="#题目-34"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题68I）：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
</li>
</ul>
<h2 id="题解-34"><a class="markdownIt-Anchor" href="#题解-34"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-i-er-cha-sou-suo-shu-de-zui-jin-g-7/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
</li>
<li>
<p><strong>最近公共祖先的定义</strong>： 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left和右子节点 root.right都不是 p,q的公共祖先，则称 root是 “最近的公共祖先” 。</p>
</li>
<li>
<p>根据以上定义，若 root 是 p,q的 <strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p>
<ul>
<li>p 和 q在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root的左或右子树中；</li>
<li>q = root，且 p在 root的左或右子树中；</li>
</ul>
</li>
<li>
<p>本题给定了两个重要条件：① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q与 root 的子树关系，即：</p>
<ul>
<li>若 root.val &lt; p.val，则 p在 root右子树 中；</li>
<li>若 root.val &gt; p.val，则 p 在 root 左子树 中；</li>
<li>若 root.val = p.val，则 p 和 root 指向 同一节点 。</li>
</ul>
</li>
<li>
<p>思路：迭代</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val: <span class="comment"># p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right <span class="comment"># 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val: <span class="comment"># p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left <span class="comment"># 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>优化：若可保证 p.val &lt; q.val ，则在循环中可减少判断条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p.val &gt; q.val: p, q = q, p <span class="comment"># 保证 p.val &lt; q.val</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val: <span class="comment"># p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right <span class="comment"># 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; q.val: <span class="comment"># p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left <span class="comment"># 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>思路：递归</p>
<ul>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉树的最近公共祖先"></a> 二叉树的最近公共祖先</h1>
<h2 id="题目-35"><a class="markdownIt-Anchor" href="#题目-35"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题68II）：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
</li>
</ul>
<h2 id="题解-35"><a class="markdownIt-Anchor" href="#题解-35"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/（递归）</a></li>
<li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/pythonti-jie-bu-tong-si-kao-fang-shi-ying-he-mian-/</a> (多种解法)</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q在节点 root 的异侧时，节点 root即为最近公共祖先，则向上返回 root。</li>
<li>递推解析见参考链接</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/">https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/21/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>百面机器学习-特征工程</span></div></a></div><div class="next-post pull_right"><a href="/2020/06/02/%E5%89%91%E6%8C%87offer/"><img class="next_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>剑指offer</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>