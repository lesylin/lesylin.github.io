<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>剑指offer | </title><meta name="description" content="剑指offer"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="剑指offer"><meta name="twitter:description" content="剑指offer"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="剑指offer"><meta property="og:url" content="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/"><meta property="og:site_name" content=""><meta property="og:description" content="剑指offer"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/"><link rel="prev" title="剑指offer1" href="https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中重复的数字"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 数组中重复的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二维数组中的查找"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 二维数组中的查找</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#替换空格"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 替换空格</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从尾到头打印链表"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 从尾到头打印链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#用两个栈实现队列"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 用两个栈实现队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-5"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-5"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#斐波那契数列"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 斐波那契数列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-6"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-6"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#青蛙跳台阶问题"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 青蛙跳台阶问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-7"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-7"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#旋转数组中最小的数字"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text"> 旋转数组中最小的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-8"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-8"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#剪绳子ii"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text"> 剪绳子II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-9"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-9"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二进制中1的个数"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text"> 二进制中1的个数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-10"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-10"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数值的整数次方"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text"> 数值的整数次方</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-11"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-11"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#删除链表的节点"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text"> 删除链表的节点</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-12"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-12"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#正则表达式匹配"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text"> 正则表达式匹配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-13"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-13"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#表示数值的字符串"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text"> 表示数值的字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-14"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-14"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#调整数组顺序使奇数位于偶数前面"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text"> 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-15"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-15"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#反转链表"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text"> 反转链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-16"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-16"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#树的子结构"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text"> 树的子结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-17"><span class="toc_mobile_items-number">18.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-17"><span class="toc_mobile_items-number">18.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#顺时针打印矩阵"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text"> 顺时针打印矩阵</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-18"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-18"><span class="toc_mobile_items-number">19.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#栈的压入-弹出序列"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text"> 栈的压入、弹出序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-19"><span class="toc_mobile_items-number">20.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-19"><span class="toc_mobile_items-number">20.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从上到下打印二叉树ii"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text"> 从上到下打印二叉树II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-20"><span class="toc_mobile_items-number">21.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-20"><span class="toc_mobile_items-number">21.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉搜索树的后序遍历序列"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text"> 二叉搜索树的后序遍历序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-21"><span class="toc_mobile_items-number">22.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-21"><span class="toc_mobile_items-number">22.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉树中和为某一值的路径"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text"> 二叉树中和为某一值的路径</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-22"><span class="toc_mobile_items-number">23.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-22"><span class="toc_mobile_items-number">23.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#字符串的排列"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text"> 字符串的排列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-23"><span class="toc_mobile_items-number">24.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-23"><span class="toc_mobile_items-number">24.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中出现次数超过一半的数字"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text"> 数组中出现次数超过一半的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-24"><span class="toc_mobile_items-number">25.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-24"><span class="toc_mobile_items-number">25.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#最小的k个数"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text"> 最小的k个数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-25"><span class="toc_mobile_items-number">26.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解排序"><span class="toc_mobile_items-number">26.2.</span> <span class="toc_mobile_items-text"> 题解（排序）</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中重复的数字"><span class="toc-number">2.</span> <span class="toc-text"> 数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-number">2.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二维数组中的查找"><span class="toc-number">3.</span> <span class="toc-text"> 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-2"><span class="toc-number">3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#替换空格"><span class="toc-number">4.</span> <span class="toc-text"> 替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-3"><span class="toc-number">4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-number">4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从尾到头打印链表"><span class="toc-number">5.</span> <span class="toc-text"> 从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-4"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-number">5.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用两个栈实现队列"><span class="toc-number">6.</span> <span class="toc-text"> 用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-5"><span class="toc-number">6.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-number">6.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">7.</span> <span class="toc-text"> 斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-6"><span class="toc-number">7.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-number">7.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#青蛙跳台阶问题"><span class="toc-number">8.</span> <span class="toc-text"> 青蛙跳台阶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-7"><span class="toc-number">8.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-7"><span class="toc-number">8.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#旋转数组中最小的数字"><span class="toc-number">9.</span> <span class="toc-text"> 旋转数组中最小的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-8"><span class="toc-number">9.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-8"><span class="toc-number">9.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#剪绳子ii"><span class="toc-number">10.</span> <span class="toc-text"> 剪绳子II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-9"><span class="toc-number">10.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-9"><span class="toc-number">10.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二进制中1的个数"><span class="toc-number">11.</span> <span class="toc-text"> 二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-10"><span class="toc-number">11.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-10"><span class="toc-number">11.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值的整数次方"><span class="toc-number">12.</span> <span class="toc-text"> 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-11"><span class="toc-number">12.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-11"><span class="toc-number">12.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除链表的节点"><span class="toc-number">13.</span> <span class="toc-text"> 删除链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-12"><span class="toc-number">13.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-12"><span class="toc-number">13.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正则表达式匹配"><span class="toc-number">14.</span> <span class="toc-text"> 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-13"><span class="toc-number">14.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-13"><span class="toc-number">14.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#表示数值的字符串"><span class="toc-number">15.</span> <span class="toc-text"> 表示数值的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-14"><span class="toc-number">15.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-14"><span class="toc-number">15.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调整数组顺序使奇数位于偶数前面"><span class="toc-number">16.</span> <span class="toc-text"> 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-15"><span class="toc-number">16.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-15"><span class="toc-number">16.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反转链表"><span class="toc-number">17.</span> <span class="toc-text"> 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-16"><span class="toc-number">17.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-16"><span class="toc-number">17.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树的子结构"><span class="toc-number">18.</span> <span class="toc-text"> 树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-17"><span class="toc-number">18.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-17"><span class="toc-number">18.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#顺时针打印矩阵"><span class="toc-number">19.</span> <span class="toc-text"> 顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-18"><span class="toc-number">19.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-18"><span class="toc-number">19.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈的压入-弹出序列"><span class="toc-number">20.</span> <span class="toc-text"> 栈的压入、弹出序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-19"><span class="toc-number">20.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-19"><span class="toc-number">20.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从上到下打印二叉树ii"><span class="toc-number">21.</span> <span class="toc-text"> 从上到下打印二叉树II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-20"><span class="toc-number">21.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-20"><span class="toc-number">21.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树的后序遍历序列"><span class="toc-number">22.</span> <span class="toc-text"> 二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-21"><span class="toc-number">22.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-21"><span class="toc-number">22.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-number">23.</span> <span class="toc-text"> 二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-22"><span class="toc-number">23.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-22"><span class="toc-number">23.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串的排列"><span class="toc-number">24.</span> <span class="toc-text"> 字符串的排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-23"><span class="toc-number">24.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-23"><span class="toc-number">24.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中出现次数超过一半的数字"><span class="toc-number">25.</span> <span class="toc-text"> 数组中出现次数超过一半的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-24"><span class="toc-number">25.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-24"><span class="toc-number">25.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最小的k个数"><span class="toc-number">26.</span> <span class="toc-text"> 最小的k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-25"><span class="toc-number">26.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解排序"><span class="toc-number">26.2.</span> <span class="toc-text"> 题解（排序）</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指offer</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-06-02<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-21</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">17.5k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 69分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 面试必备《剑指offer》，题解整理，方便今后自己查阅，要为接下来的秋招做准备了呀~</p>
<h1 id="数组中重复的数字"><a class="markdownIt-Anchor" href="#数组中重复的数字"></a> 数组中重复的数字</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题03)：找出数组中重复的数字。<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有多种解法，如果面试中遇到这道题，让你找出数组中重复的数字，要向面试官询问，<u><strong>是否可以使用额外空间</strong></u>？<u><strong>是否可以修改原数组</strong></u>？然后，根据要求给出解决方案。（<strong><u>本题对数组长度做了限制，如果没有限制数组长度，需要进行非空判断</u></strong>）</p>
<ol>
<li>
<p><strong>使用额外空间，不修改原数组——哈希表</strong></p>
<ul>
<li>
<p>思路：遍历数组，用哈希表记录数组中每个数字出现的情况，如果该数字没有出现在哈希表，就将其加入哈希表，如果该数字在哈希表中已经存在，就直接返回。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——sort排序</strong></p>
<ul>
<li>
<p>思路：对数组排序，这样重复的两个数字的位置就是相邻的，然后，遍历一遍数组，判断相邻位置的两个数字是否相等，相等就返回，不相等就继续遍历。</p>
</li>
<li>
<blockquote>
<p>list.sort()的原理：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">https://blog.csdn.net/yangzhongblog/article/details/8184707</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(nlogn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——原地排序</strong></p>
<ul>
<li>
<p>思路：<strong>因为数组的数字范围和数组的长度是一样的，即与数组下标一一对应（把数组视为哈希表）</strong>。因此，我们看到数字，就可以知道把这个数字放在数组的哪个位置上。这就像是我们人为编写了哈希函数，这个哈希函数的规则还特别简单，而找到重复数字就是发生了哈希冲突。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<blockquote>
<p>Python 中， a, b = c, d 操作的原理是先暂存元组 (c, d) ，然后 “按顺序” 赋值给 a 和 b 。<br>
若写为 nums[i], nums[nums[i]] = nums[nums[i]], nums[i] ，则 nums[i] 先被赋值，之后 nums[nums[i]] 指向的元素则会出错。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> 二维数组中的查找</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题04）：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn><mi mathvariant="normal">，</mi><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤n≤1000，0≤m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：如果这个n * m的数组是无序的，要查找该数组中是否存在目标整数，需要遍历完二维数组每一行或者每一列，即暴力求解法，时间复杂度是O(n*m)，空间复杂度是O(1)。仔细观察题目的二维数组，可以发现行和列的数字是按一定顺序排列的。</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后从数组中选取一个数字，分3种情况来分析查找过程。当数组中选取的数字刚好要和查找的数字相等时，就结束查找过程。如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取的位置的上边或者右边。（若当前选取位置在正中间，则在右下角或左上角可能会出现查找重叠区域）。</p>
</blockquote>
</li>
<li>
<p>思路：从数组的一个角上选取数字来和要查找的数字做比较。</p>
<ul>
<li>
<p>左上角数字：是所在列和行最小的数字（如果查找的数字大于左上角数字，情况和上述分析一样，可以往右边或者下边查找）</p>
</li>
<li>
<p>左下角数字：是所在列最大的数字，所在行最小的数字（如果查找的数字大于左下角数字，往右边查找，如果小于做左下角数字，往上边查找）</p>
</li>
<li>
<p>右上角数字：是所在列最小的数字，所在行最大的数字（如果查找的数字大于右上角数字，往下边查找，如果小于右上角数字，往左边查找）</p>
</li>
<li>
<p>右下角数字：是所在列和行最大的数字（如果查找的数字小于右下角数字，情况和上述分析一样，可以往左边或者上边查找）</p>
</li>
<li>
<p>因此，本题可以选择左下角数字或右上角数字来和查找的数字做比较。</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>特殊用例：二维数组为空，返回空</li>
<li>假设从矩阵matrix的左下角数字开始遍历（索引设为i，j），与要查找的数字做比较：（右上角同理分析）
<ul>
<li>当<code>matrix[i][j] == target</code>，返回True</li>
<li>当<code>matrix[i][j] &gt; target</code>，行索引<code>i</code>向上查找，即<code>i--</code></li>
<li>当<code>matrix[i][j] &lt; target</code>，列索引<code>j</code>向右查找，即<code>j++</code></li>
</ul>
</li>
<li>若行索引或列索引越界，则代表矩阵中无目标值，返回 False。</li>
</ul>
</li>
<li>
<blockquote>
<p>算法本质： 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n + m)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = len(matrix) - <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="替换空格"><a class="markdownIt-Anchor" href="#替换空格"></a> 替换空格</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题05）：请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>s</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ s的长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成’%’、‘2’、'0’这3个字符，因此字符串会变长。如果是在原来的字符串上做替换，那么就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上做替换，那么我们可以自己分配足够多的内存。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据上述分析，在面试的时候，要明确面试官的需求，然后，从两种方案中选择一种完成。下面是三种最优的解法：</p>
<ol>
<li>
<p>使用replace函数（新）</p>
<ul>
<li>
<blockquote>
<p>python内置的<code>replace</code>函数用来替换字符串中指定的字符。</p>
<p>replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p>
<p>replace()方法语法：<code>str.replace(old, new[, max])</code></p>
<p>参数</p>
<ul>
<li>old – 将被替换的子字符串。</li>
<li>new – 新字符串，用于替换old子字符串。</li>
<li>max – 可选字符串, 替换不超过 max 次</li>
</ul>
<p>返回值：返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环（新）</p>
<blockquote>
<ul>
<li>Python的六个标准数据类型中不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）。</li>
</ul>
</blockquote>
<ul>
<li>
<p>将字符串先转换为list，然后，遍历list，当遍历到空格，就将空格替换成’%20’，最后，将list转成str。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        l = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            <span class="keyword">if</span> l[i] == <span class="string">' '</span>:</span><br><span class="line">                l[i] = <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>双指针移动+计数（原始）</p>
<ul>
<li>
<p>首先遍历一次字符串s，统计空格数</p>
</li>
<li>
<p>假设有m个空格，我们需要填充’%20’占用的三个字符串位置，所以需要额外开辟2 * m个空间</p>
</li>
<li>
<p>将开辟出的空间链接到原字符串的后面,新的字符串命名为s_new</p>
</li>
<li>
<p>设置两个指针p1和p2,初始时p1指向原字符串s的末尾,p2指向s_new的末尾</p>
</li>
<li>
<p>p1指针向前移动,当p1指向的字符不是空格时,将p1指向的字符复制到p2指向的位置,并都向前移动一位</p>
</li>
<li>
<p>当p1指向的字符是空格时,p1向前移动一格,这时应该插入%20,所以p2向前移动三格,并在这三格中插入%,2,0</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(2m)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s_len = len(s)</span><br><span class="line">        space_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</span><br><span class="line">                space_count += <span class="number">1</span></span><br><span class="line">        s_len += <span class="number">2</span> * space_count</span><br><span class="line">        new_array = [<span class="string">' '</span>] * s_len</span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p1 <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == <span class="string">' '</span>:</span><br><span class="line">                new_array[p2] = <span class="string">'%'</span></span><br><span class="line">                new_array[p2 + <span class="number">1</span>] = <span class="string">'2'</span></span><br><span class="line">                new_array[p2 + <span class="number">2</span>] = <span class="string">'0'</span></span><br><span class="line">                p2 += <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_array[p2] = s[p1]</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_array)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题06）：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 链表长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：面试时候，需要明确**<u>是否允许在打印链表的时候修改链表的结构</u>**？如果可以修改，那么就是<u><strong>面试题24-反转链表</strong></u>，先对链表进行反转，然后输出。如果不可以修改，那肯定需要遍历链表，遍历顺序是从头到尾，输出是从尾到头，典型的“后进先出”，我们可以<u><strong>使用栈实现</strong></u>。想到栈，我们还可以想到递归，<u><strong>递归在本质上就是一个栈结构</strong></u>，即每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身。</p>
<ol>
<li>
<p><strong>修改链表结构-反转链表</strong>（具体看面试题24-反转链表）</p>
<ul>
<li>
<p>特殊用例：链表头结点指针为空，返回[]</p>
</li>
<li>
<p>双指针反转链表：</p>
</li>
<li>
<p>初始化两个指针，<code>pre == None</code>，<code>cur == head</code></p>
</li>
<li>
<p>遍历链表，用临时变量tmp记录当前结点，并将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></p>
</li>
<li>
<p>pre和cur都向链表尾部移动，直到cur为空。</p>
</li>
<li>
<p>题目要求用数组返回，因此，初始化数组<code>s = []</code>，遍历反转后的链表，依次将每个结点的值加入数组，然后返回数组s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            s.append(pre.val)</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-栈</strong>（迭代）：</p>
<ul>
<li>
<p>创建一个栈，用于存储链表结点</p>
</li>
<li>
<p>创建一个指针，初始时指向链表的头结点</p>
</li>
<li>
<p>当指针指向元素非空时，重复下列操作：</p>
<ul>
<li>将指针指向的结点压入栈内</li>
<li>将指针移到当前结点的下一个结点</li>
</ul>
</li>
<li>
<p>初始化数组<code>s=[]</code></p>
</li>
<li>
<p>当栈不为空时，重复下列操作：</p>
<ul>
<li>将栈顶结点弹出，将栈顶结点的值加入数组s</li>
</ul>
</li>
<li>
<p>返回数组s</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> []
        stack = []
        i = head
        s = []
        <span class="keyword">while</span> i:
            stack.append(i)
            i = i.next
        <span class="keyword">while</span> stack:
            s.append(stack.pop().val)
        <span class="keyword">return</span> s
&lt;!--￼<span class="number">12</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-递归</strong></p>
<ul>
<li>
<p><strong>利用递归：</strong> 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
</li>
<li>
<p><strong>递推阶段：</strong> 每次传入 <code>head.next</code> ，以 <code>head == None</code>（即走过链表尾部节点）为递归终止条件，此时返回空列表 <code>[]</code> 。</p>
</li>
<li>
<p><strong>回溯阶段：</strong> 利用 Python 语言特性，递归回溯时每次返回 <code>当前 list + 当前节点值 [head.val]</code>，即可实现节点的倒序输出</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显示用栈基于循环实现的代码鲁棒性要好一些。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> []
        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val]
&lt;!--￼<span class="number">13</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<p>例如，给出<br>
前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]</p>
<p>返回如下的二叉树：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 限制：$0 ≤ 节点个数 ≤ 5000$</span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">- 思路：根据前序遍历和中序遍历的特点，可以对前序遍历和中序遍历序列进行划分，划分出左子树、根节点、右子树的区间，然后，递归构造二叉树。</span><br><span class="line"></span><br><span class="line">  - 特殊用例：前序遍历为空或中序遍历为空或节点个数≤0，返回None（前序遍历和中序遍历不匹配）</span><br><span class="line">  - 根据前序遍历特点，前序遍历序列的第一个数字是根节点的值，即&#96;root_val &#x3D; preorder[0]&#96;</span><br><span class="line">  - 构建根节点，&#96;root &#x3D; TreeNode(root_val)&#96;</span><br><span class="line">  - 确定根节点在中序遍历的序列的索引：&#96;root_in_index &#x3D; inorder.index(root_val)&#96;</span><br><span class="line">  - 确定左子树在前序遍历序列的区间，以及在中序遍历序列的区间</span><br><span class="line">  - 确定右子树在前序遍历序列的区间，以及在中序遍历序列的区间</span><br><span class="line">  - 递归构建左子树和右子树</span><br><span class="line">  - 返回root</span><br><span class="line"></span><br><span class="line">- 时间复杂度：O(n)</span><br><span class="line"></span><br><span class="line">- 空间复杂度：O(n)</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  # Definition for a binary tree node.</span><br><span class="line">  # class TreeNode(object):</span><br><span class="line">  #     def __init__(self, x):</span><br><span class="line">  #         self.val &#x3D; x</span><br><span class="line">  #         self.left &#x3D; None</span><br><span class="line">  #         self.right &#x3D; None</span><br><span class="line">  </span><br><span class="line">  class Solution(object):</span><br><span class="line">      def buildTree(self, preorder, inorder):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type preorder: List[int]</span><br><span class="line">          :type inorder: List[int]</span><br><span class="line">          :rtype: TreeNode</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          if not preorder or not inorder:</span><br><span class="line">              return None</span><br><span class="line">          root_val &#x3D; preorder[0]</span><br><span class="line">          root &#x3D; TreeNode(root_val)</span><br><span class="line">          root_in_index &#x3D; inorder.index(root_val)</span><br><span class="line">          left_pre &#x3D; preorder[1: root_in_index + 1]</span><br><span class="line">          left_in &#x3D; inorder[: root_in_index]</span><br><span class="line">          right_pre &#x3D; preorder[root_in_index + 1:]</span><br><span class="line">          right_in &#x3D; inorder[root_in_index + 1:]</span><br><span class="line">          root.left &#x3D; self.buildTree(left_pre, left_in)</span><br><span class="line">          root.right &#x3D; self.buildTree(right_pre, right_in)</span><br><span class="line">          return root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="用两个栈实现队列"><a class="markdownIt-Anchor" href="#用两个栈实现队列"></a> 用两个栈实现队列</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题09）：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 ≤ values ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li>最多会对 appendTail、deleteHead 进行 10000 次调用</li>
</ul>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：
<ul>
<li>初始化stack1和stack2</li>
<li>插入元素：将元素插入stack1</li>
<li>删除元素：stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.stack1 = []
        self.stack2 = []


    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span>
        <span class="string">"""
        :type value: int
        :rtype: None
        """</span>
        self.stack1.append(value)


    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span>
        <span class="string">"""
        :rtype: int
        """</span>
        <span class="keyword">if</span> self.stack2:
            <span class="keyword">return</span> self.stack2.pop()
        <span class="keyword">if</span> <span class="keyword">not</span> self.stack1:
            <span class="keyword">return</span> <span class="number">-1</span>
        <span class="keyword">while</span> self.stack1:
            self.stack2.append(self.stack1.pop())
        <span class="keyword">return</span> self.stack2.pop()
&lt;!--￼<span class="number">16</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="斐波那契数列"><a class="markdownIt-Anchor" href="#斐波那契数列"></a> 斐波那契数列</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-I）：写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[ <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
<li>可以用3个变量，sum，a，b，优化上述代码，时间复杂度不变，空间复杂度降为O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h1 id="青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#青蛙跳台阶问题"></a> 青蛙跳台阶问题</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-II）：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</li>
<li>此类求 多少种可能性 的题目一般都有 递推性质 ，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n - 1)....f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间是有联系的。</li>
<li>设跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。</li>
<li>当为 1 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>种跳法；</li>
<li>当为 2 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>种跳法。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为以上两种情况之和，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> ，以上递推性质为斐波那契数列。</li>
<li>本题可转化为 求斐波那契数列第 n项的值 ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。
<ul>
<li>青蛙跳台阶问题： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(0)=1 , f(1)=1 , f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ；</li>
<li>斐波那契数列问题：$ f(0)=0 , f(1)=1 , f(2)=1$ ;</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：直接在面试题10-I 斐波那契数列的基础上，将起始数字做一个修改。</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        a = <span class="number">1</span>
        b = <span class="number">1</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):
            a, b = b, a+b
        <span class="keyword">return</span> a % <span class="number">1000000007</span>
&lt;!--￼<span class="number">22</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="旋转数组中最小的数字"><a class="markdownIt-Anchor" href="#旋转数组中最小的数字"></a> 旋转数组中最小的数字</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题11）：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<strong>输入一个递增排序的数组的一个旋转</strong>，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li><strong>Tips</strong>：<strong><u>如果面试题是要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。关于查找和排序见另一篇博客《八大排序》</u></strong></li>
</ul>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></li>
<li>参考2：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>根据题目可以发现，输入的递增排序数组，可以从中点划分成两个递增数组。左排序数组的任一元素都大于右排序数组的任一元素。</li>
<li>双指针法，初始化两个指针i，j，指向数组的头和尾，即<code>i == 0</code>， <code>j == len(numbers)</code></li>
<li><code>mid = (i + j) // 2</code>，每次二分的中点</li>
<li>当<code>numbers[mid] &gt; numbers[j]</code>，m在左边的递增数组，最小元素一定在[m+1, j]</li>
<li>当<code>numbers[mid] &lt; numbers[j]</code>，m在右边的递增数组，最小元素一定在[i,m]</li>
<li>当<code>numbers[mid] = numbers[j]</code>，无法判断m在哪，缩小区间即可[i,j-1]</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span>
        <span class="string">"""
        :type numbers: List[int]
        :rtype: int
        """</span>
        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            mid = (i + j) // <span class="number">2</span>
            <span class="keyword">if</span> numbers[mid] &gt; numbers[j]:
                i = mid + <span class="number">1</span>
            <span class="keyword">elif</span> numbers[mid] &lt; numbers[j]:
                j = mid
            <span class="keyword">else</span>:
                j -= <span class="number">1</span>
        <span class="keyword">return</span> numbers[i]
&lt;!--￼<span class="number">24</span>--&gt;
输入：board = [[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],[<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],[<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]], word = <span class="string">"ABCCED"</span>
输出：true

输入：board = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>]], word = <span class="string">"abcd"</span>
输出：false
&lt;!--￼<span class="number">25</span>--&gt;

</code></pre>
</li>
<li>
<p>牛客网对应的这个题的python解法的通过榜单的榜首的代码都会有部分case过不了，正确代码如下：</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):
            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):
                <span class="keyword">if</span> matrix[i*cols + j] == path[<span class="number">0</span>]:
                    <span class="keyword">if</span> self.dfs(list(matrix), rows, cols, path[<span class="number">1</span>:], i, j):
                        <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">return</span> <span class="literal">False</span>

    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, rows, cols, path, i, j)</span>:</span>
        <span class="keyword">if</span> <span class="keyword">not</span> path:
            <span class="keyword">return</span> <span class="literal">True</span>
        matrix[i*cols + j] = <span class="string">'-'</span>
        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):
            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> matrix[x*cols+y]==path[<span class="number">0</span>]:
                <span class="keyword">if</span> self.dfs(matrix, rows, cols, path[<span class="number">1</span>:], x, y):
                    <span class="keyword">return</span> <span class="literal">True</span>
        <span class="keyword">return</span> <span class="literal">False</span>
&lt;!--￼<span class="number">26</span>--&gt;
输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span>
输出：<span class="number">3</span>

输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span>
输出：<span class="number">1</span>
&lt;!--￼<span class="number">27</span>--&gt;

</code></pre>
</li>
<li>
<p>思路2：</p>
<ul>
<li>BFS
<ul>
<li>初始化： 将机器人初始点 (0, 0)加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：</li>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li>
<li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span>
        <span class="string">"""
        :type m: int
        :type n: int
        :type k: int
        :rtype: int
        """</span>
        queue, visited = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()
        <span class="keyword">while</span> queue:
            i, j, si, sj = queue.pop(<span class="number">0</span>)
            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:
                <span class="keyword">continue</span>
            visited.add((i, j))
            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))
            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))
        <span class="keyword">return</span> len(visited)
&lt;!--￼<span class="number">28</span>--&gt;
输入: <span class="number">2</span>
输出: <span class="number">1</span>
解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>

输入: <span class="number">10</span>
输出: <span class="number">36</span>
解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>
&lt;!--￼<span class="number">29</span>--&gt;

</code></pre>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码适合了解学习，属于找规律，数学方法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a)</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="剪绳子ii"><a class="markdownIt-Anchor" href="#剪绳子ii"></a> 剪绳子II</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14II）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：和面试题14I - 剪绳子I的解题思想是一样的，在此基础上，考虑<strong>大数越界情况下的求余</strong>问题。</p>
</li>
<li>
<blockquote>
<p>参考链接里介绍的求余方法：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
</blockquote>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span>
        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):
            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),
                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),
                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))
        <span class="keyword">return</span> dp[n % <span class="number">3</span>] % <span class="number">1000000007</span>
&lt;!--￼<span class="number">32</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二进制中1的个数"><a class="markdownIt-Anchor" href="#二进制中1的个数"></a> 二进制中1的个数</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题15）：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：（剑指offer)位运算的使用**。位运算总共只有五种运算：<strong>与、或、异或、左移、右移</strong>。与、或和异或运算的规律我们可以用下表总结：</p>
<table>
<thead>
<tr>
<th>与（&amp;）</th>
<th>0&amp;0 = 0</th>
<th>1&amp;0=0</th>
<th>0&amp;1=0</th>
<th>1&amp;1=1</th>
</tr>
</thead>
<tbody>
<tr>
<td>或（！）</td>
<td>0|0 = 0</td>
<td>1|0=1</td>
<td>0|1=0</td>
<td>1|1=1</td>
</tr>
<tr>
<td>异或（^）</td>
<td>0^0 = 0</td>
<td>1^0=1</td>
<td>0^1=1</td>
<td>1^1=0</td>
</tr>
</tbody>
</table>
<ul>
<li>左移运算符m&lt;&lt;n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。比如：
<ul>
<li>00001010&lt;&lt;2 = 00101000</li>
<li>10001010&lt;&lt;3=01010000</li>
</ul>
</li>
<li>右移运算符m&gt;&gt;n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。
<ul>
<li>00001010&gt;&gt;2=00000010</li>
<li>10001010&gt;&gt;3=11110001</li>
</ul>
</li>
<li><strong>除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。</strong></li>
<li>面试时候可以按照基本思路到下面代码思路进行描述：
<ul>
<li>先判断整数二进制表示中最右边一位是不是1，只需要把整数与1做位与运算，是1就右移1位，直到整个整数为0（如果是有符号数，也就是如果输入负数，这样会产生死循环。</li>
<li>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多次这样的操作。
<ul>
<li>例如，二进制数1100，它的第二位是从最右边数起的一个1。减去1后，第二位变成0，而前面的1保持不变，因此得到结果1011，然后再把1100与1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)，n为整数二进制1的个数</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span>
        <span class="string">"""
        :type n: int
        :rtype: int
        """</span>
        res = <span class="number">0</span>
        <span class="keyword">while</span> n:
            res += <span class="number">1</span>
            n &amp;= n - <span class="number">1</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">34</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数值的整数次方"><a class="markdownIt-Anchor" href="#数值的整数次方"></a> 数值的整数次方</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题16）：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，<strong>同时不需要考虑大数问题。</strong></p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2^-2 &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</li>
</ul>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<blockquote>
<ul>
<li>（剑指offer)：用一条语句判断<strong>一个整数是不是2的整数次方</strong>。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位是都是0。根据二进制中1的个数分析思路，判断一个整数是不是2的整数次方，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。因此，解决这个问题可以分为两步：
<ul>
<li>第一步：求这两个数的异或</li>
<li>第二步：统计异或结果中1的位数</li>
</ul>
</li>
<li>本题思路参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></li>
</ul>
</li>
<li><strong>计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。</strong>
<ul>
<li>python比较两个float类型的数据是否相等：<a href="https://blog.csdn.net/weixin_34227447/article/details/88713033" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34227447/article/details/88713033</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制问题都可以用这个思路解决。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>考虑输入指数是负数和零的情况。</li>
<li>考虑特殊用例：0的0次方，可以输出0或1</li>
<li><strong>细节</strong>：判断两个double或float类型数值是否相等。位运算代替乘除法以及求余运算。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码可以通过leetcode，但是通过上述分析，我们可以知道，x是double类型，不能直接写 x == 0，因此可以定义一个equal函数进行判断（<code>return abs(num1 - num2) &lt;= 0.0000001</code>)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span>
        <span class="string">"""
        :type x: float
        :type n: int
        :rtype: float
        """</span>
        <span class="keyword">if</span> x == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="number">0</span>
        <span class="keyword">if</span> n &lt; <span class="number">0</span>:
            x = <span class="number">1</span> / x
            n = -n
        res = <span class="number">1</span>
        <span class="keyword">while</span> n:
            <span class="keyword">if</span> n &amp; <span class="number">1</span>:
                res *= x
            x *= x
            n &gt;&gt;= <span class="number">1</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">36</span>--&gt;
输入: n = <span class="number">1</span>
输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]
&lt;!--￼<span class="number">37</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="删除链表的节点"><a class="markdownIt-Anchor" href="#删除链表的节点"></a> 删除链表的节点</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题18）：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>**注意：**此题对比原题有改动</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有两种思路.</p>
<ul>
<li>第一个是得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code>（数据输入类型是整型val）</li>
<li>第二个是把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除（剑指offer思路，数据输入类型是链表ListNode）</li>
</ul>
</li>
<li>
<p>思路1：得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code></p>
<ul>
<li>初始化双指针，pre指向head，cur指向head.next</li>
<li>当head为空时，返回head</li>
<li>当head是要删除的结点，返回head.next</li>
<li>遍历链表，当cur指向的结点是要删除的结点时，pre.next = cur.next，直到链表遍历完</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，n是链表长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """</span>
        pre = head
        cur = head.next
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head
        <span class="keyword">if</span> head.val == val:
            <span class="keyword">return</span> head.next
        <span class="keyword">while</span> cur:
            <span class="keyword">if</span> cur.val == val:
                pre.next = cur.next
            pre = pre.next
            cur = cur.next
        <span class="keyword">return</span> head
&lt;!--￼<span class="number">39</span>--&gt;

</code></pre>
</li>
<li>
<p>思路2：把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除。</p>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/</a></li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题19）：请实现一个函数用来匹配包含 <code>'.'</code> 和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</p>
</li>
<li>
<p><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>'*'</code>。</p>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></li>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</a></li>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：回溯法+动态规划</p>
</li>
<li>
<p>思路1：回溯</p>
</li>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中T和P分别表示匹配串和模式串的长度。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span>
        <span class="string">"""
        :type s: str
        :type p: str
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> p: 
            <span class="keyword">return</span> <span class="keyword">not</span> s
        <span class="comment"># 第一个字母是否匹配</span>
        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> {s[<span class="number">0</span>],<span class="string">'.'</span>})
        <span class="comment"># 如果 p 第二个字母是 *</span>
        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:
            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \
            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)
        <span class="keyword">else</span>:
            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])
&lt;!--￼<span class="number">41</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="表示数值的字符串"><a class="markdownIt-Anchor" href="#表示数值的字符串"></a> 表示数值的字符串</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题20）：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 除去两端空格</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 检查字符合法性</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"0987654321+-e."</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有e的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 检查e的个数</span></span><br><span class="line">            <span class="keyword">if</span> s.count(<span class="string">'e'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 划分，并检查左右子串是否为空</span></span><br><span class="line">            p = s.index(<span class="string">'e'</span>)</span><br><span class="line">            ls = s[:p]</span><br><span class="line">            rs = s[p+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> len(ls)==<span class="number">0</span> <span class="keyword">or</span> len(rs)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串+-</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串小数点个数</span></span><br><span class="line">            <span class="keyword">if</span> ls.count(<span class="string">'.'</span>)&gt;<span class="number">1</span> <span class="keyword">or</span> rs.count(<span class="string">'.'</span>)&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = ls.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查小数点左或右有没有数字</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = ls.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> ls[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(ls) <span class="keyword">and</span> ls[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 没e的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(s)&lt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = s.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = s.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> s[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(s) <span class="keyword">and</span> s[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#调整数组顺序使奇数位于偶数前面"></a> 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题21）：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>位运算比求余效率高</strong>。在《剑指offer》分析中，双指针方法适合初级程序员，高级一点的写法，应该把整个函数解耦成两部分，一是判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作，这样无论是奇数在偶数前面的数组划分，还是能被3整除的数划分就可以直接求解了，提高代码重用性。</p>
</li>
<li>
<p>思路：双指针</p>
<ul>
<li>初始化双指针，<code>i = 0</code>，<code>j = len(nums) - 1</code></li>
<li>遍历数组，指针i从左向右找偶数，指针j从右向左找奇数</li>
<li>将偶数nums[i]和奇数nums[j]交换</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> i &lt; j:
            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:
                i += <span class="number">1</span>
            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:
                j -= <span class="number">1</span>
            nums[i], nums[j] = nums[j], nums[i]
        <span class="keyword">return</span> nums
&lt;!--￼<span class="number">44</span>--&gt;

</code></pre>
</li>
<li>
<p>高级一点写法</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) == <span class="number">0</span>:
            <span class="keyword">return</span> []
        pBegin = <span class="number">0</span>
        pEnd = len(nums) - <span class="number">1</span>
        <span class="keyword">while</span> pBegin &lt; pEnd:
            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> <span class="keyword">not</span> self.isEven(nums[pBegin]):
                pBegin += <span class="number">1</span>
            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> self.isEven(nums[pEnd]):
                pEnd -= <span class="number">1</span>
            nums[pBegin], nums[pEnd] = nums[pEnd], nums[pBegin]
        <span class="keyword">return</span> nums
    <span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(self, n)</span>:</span>
        <span class="keyword">return</span> n &amp; <span class="number">1</span> == <span class="number">0</span>
&lt;!--￼<span class="number">45</span>--&gt;
给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span>
返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span>
&lt;!--￼<span class="number">46</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题24）：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有三种解法求解，双指针（最优）、辅助栈、递归。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/</a></p>
</blockquote>
</li>
<li>
<p>思路1：双指针</p>
<ul>
<li>定义3个指针，tmp，pre，cur，分别指向当前遍历结点、它的前一个结点和后一个结点</li>
<li>遍历链表，将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head:
            <span class="keyword">return</span> head
        pre = <span class="literal">None</span>
        cur = head
        <span class="keyword">while</span> cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        <span class="keyword">return</span> pre
&lt;!--￼<span class="number">48</span>--&gt;

</code></pre>
</li>
<li>
<p>思路3：递归</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for singly-linked list.</span>
<span class="comment"># class ListNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.next = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span>
        <span class="string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span>
        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:
            <span class="keyword">return</span> head
        <span class="comment"># 这里的cur就是最后一个节点</span>
        cur = self.reverseList(head.next)
        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span>
				<span class="comment"># 而head是4，head的下一个是5，下下一个是空</span>
				<span class="comment"># 所以head.next.next 就是5-&gt;4</span>
        head.next.next = head
        <span class="comment"># 防止链表循环，需要将head.next设置为空</span>
        head.next = <span class="literal">None</span>
        <span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span>
        <span class="keyword">return</span> cur
&lt;!--￼<span class="number">49</span>--&gt;
输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>
输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>
&lt;!--￼<span class="number">50</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="树的子结构"><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题26）：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> </span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line"> </span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+包含判断+递归</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>第一步：在树A种找到和B的根节点的值一样的结点R（实质：树的遍历）</li>
<li>第二步：判断树A中以R为根节点的子树是不是包含和树B一样的结构</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)，M和N分别为两棵树的节点数</p>
</li>
<li>
<p>空间复杂度：O(M)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A, B)</span>:</span>
        <span class="string">"""
        :type A: TreeNode
        :type B: TreeNode
        :rtype: bool
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> (A <span class="keyword">and</span> B):
            <span class="keyword">return</span> <span class="literal">False</span>
        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, B)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> B:
                <span class="keyword">return</span> <span class="literal">True</span>
            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:
                <span class="keyword">return</span> <span class="literal">False</span>
            <span class="keyword">return</span> dfs(A.left, B.left) <span class="keyword">and</span> dfs(A.right, B.right)
        <span class="keyword">return</span> dfs(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)
&lt;!--￼<span class="number">52</span>--&gt;
例如输入：

     <span class="number">4</span>
   /   \
  <span class="number">2</span>     <span class="number">7</span>
 / \   / \
<span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span>

镜像输出：

     <span class="number">4</span>
   /   \
  <span class="number">7</span>     <span class="number">2</span>
 / \   / \
<span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span>

示例 <span class="number">1</span>：
输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]
输出：[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]
&lt;!--￼<span class="number">53</span>--&gt;

</code></pre>
</li>
<li>
<p>辅助栈：</p>
<ul>
<li>利用栈（或队列）遍历树的所有节点node ，并交换每个node的左 / 右子节点。</li>
<li>算法流程：
<ul>
<li>特例处理：当root为空，返回root</li>
<li>初始化：栈，并加入根节点</li>
<li>循环交换：当栈stack为空时跳出
<ul>
<li>出栈：记为node</li>
<li>添加子结点：将node的左右子结点入栈</li>
<li>交换，交换node的左右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> root
        stack = [root]
        <span class="keyword">while</span> stack:
            node = stack.pop()
            <span class="keyword">if</span> node.left:
                stack.append(node.left)
            <span class="keyword">if</span> node.right:
                stack.append(node.right)
            node.left, node.right = node.right, node.left
        <span class="keyword">return</span> root
&lt;!--￼<span class="number">54</span>--&gt;
例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">2</span>
 / \ / \
<span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span>

但是下面这个 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>] 则不是镜像对称的:

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">2</span>
   \   \
   <span class="number">3</span>    <span class="number">3</span>

示例 <span class="number">1</span>：
输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]
输出：true

示例 <span class="number">2</span>：
输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">3</span>]
输出：false
&lt;!--￼<span class="number">55</span>--&gt;

</code></pre>
</li>
<li>
<p>思路：队列</p>
<ul>
<li>特例处理：如果root为空，返回True</li>
<li>初始化：队列，并顺序加入root的左右结点</li>
<li>循环判断：当队列为空时跳出
<ul>
<li>出队列：依次记为left和right</li>
<li>如果left和right都为空，说明穿过叶子节点，继续执行</li>
<li>如果left或right其中一个为空，说明不对称，返回False</li>
<li>如果left和right的值不相等，说明不对称，返回False</li>
<li>入队：（成对加入）
<ul>
<li>加入left的左节点和righ的右节点</li>
<li>加入left的右节点和right的左节</li>
</ul>
</li>
</ul>
</li>
<li>返回True</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root.left, root.right]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            left = queue.pop(<span class="number">0</span>)</span><br><span class="line">            right = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">and</span> right) <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(left.left)</span><br><span class="line">            queue.append(right.right)</span><br><span class="line">            queue.append(left.right)</span><br><span class="line">            queue.append(right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="顺时针打印矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵"></a> 顺时针打印矩阵</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题29）：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制</p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<ul>
<li>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</a></li>
<li>剑指offer：
<ul>
<li>当我们遇到一个复杂问题的时候，可以用图形来帮助我们思考。由于是以外圈到内圈的顺序依次打印，我们可以把矩阵想象成若干个圈，可以用一个循环来打印矩阵，每一次打印矩阵中的一个圈。</li>
<li>分析循环结束的条件。假设这个矩阵的行数是rows，列数是columns。打印第一圈的左上角的坐标是(1,1)，第二圈的左上角的坐标是(2,2)，以此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。</li>
<li>对一个5 * 5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2)。我们发现5 &gt; 2 * 2。对于一个6 * 6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为(2,2)。我们发现6 &gt; 2 * 2依然成立。于是我们可以得出，让循环继续的条件是columns &gt; startX * 2并且 rows &gt; startX * 2。</li>
<li>考虑如何打印一圈的功能。我们可以把打印一圈分为4步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或一列。不过值得注意的是，最后一圈有可能退化成只有一行，只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要4步。</li>
<li>分析打印时每一步的前提条件。第一步总是需要的，因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始起始行号至少大2，同时终止列号大于起始列号。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(MN）,M和N分别为矩阵的行列</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span>
        <span class="string">"""
        :type matrix: List[List[int]]
        :rtype: List[int]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> matrix:
            <span class="keyword">return</span> []
        l, r, t, b, res = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, len(matrix) - <span class="number">1</span>, []
        <span class="keyword">while</span> <span class="literal">True</span>:
            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):
                res.append(matrix[t][i]) <span class="comment"># left to right</span>
            t += <span class="number">1</span>
            <span class="keyword">if</span> t &gt; b:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>):
                res.append(matrix[i][r]) <span class="comment"># top to bottom</span>
            r -= <span class="number">1</span>
            <span class="keyword">if</span> l &gt; r:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):
                res.append(matrix[b][i]) <span class="comment"># right to left</span>
            b -= <span class="number">1</span>
            <span class="keyword">if</span> t &gt; b:
                <span class="keyword">break</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>):
                res.append(matrix[i][l]) <span class="comment"># bottom to top</span>
            l += <span class="number">1</span>
            <span class="keyword">if</span> l &gt; r:
                <span class="keyword">break</span>
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">58</span>--&gt;
MinStack minStack = new MinStack();
minStack.push(<span class="number">-2</span>);
minStack.push(<span class="number">0</span>);
minStack.push(<span class="number">-3</span>);
minStack.min();   --&gt; 返回 <span class="number">-3.</span>
minStack.pop();
minStack.top();      --&gt; 返回 <span class="number">0.</span>
minStack.min();   --&gt; 返回 <span class="number">-2.</span>
&lt;!--￼<span class="number">59</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#栈的压入-弹出序列"></a> 栈的压入、弹出序列</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题31）：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列</li>
</ul>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：辅助栈</p>
<ul>
<li>面试时，需要确定一个序列和弹出序列的长度是否一致，序列中数字是否有重复。</li>
</ul>
</li>
<li>
<p>思路：判断一个序列是不是栈的弹出序列的规律。如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<ul>
<li>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span>
        <span class="string">"""
        :type pushed: List[int]
        :type popped: List[int]
        :rtype: bool
        """</span>
        stack, i = [], <span class="number">0</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:
            stack.append(num) <span class="comment"># num 入栈</span>
            <span class="keyword">while</span> stack <span class="keyword">and</span> i &lt; len(popped)<span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[i]: <span class="comment"># 循环判断与出栈</span>
                stack.pop()
                i += <span class="number">1</span>
        <span class="keyword">return</span> <span class="keyword">not</span> stack
&lt;!--￼<span class="number">61</span>--&gt;
例如:
给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],

    <span class="number">3</span>
   / \
  <span class="number">9</span>  <span class="number">20</span>
    /  \
   <span class="number">15</span>   <span class="number">7</span>
   
返回：
[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]
&lt;!--￼<span class="number">62</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="从上到下打印二叉树ii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树ii"></a> 从上到下打印二叉树II</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题32II）：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>算法流程：</p>
<ul>
<li>特例处理：当前结点为空，则返回列表[]</li>
<li>初始化： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；
<ul>
<li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li>
<li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；
<ul>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ul>
</li>
<li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :rtype: List[List[int]]
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> root:
            <span class="keyword">return</span> []
        queue = collections.deque()
        queue.append(root)
        res = []
        <span class="keyword">while</span> queue:
            tmp = []
            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):
                node = queue.popleft()
                tmp.append(node.val)
                <span class="keyword">if</span> node.left:
                    queue.append(node.left)
                <span class="keyword">if</span> node.right:
                    queue.append(node.right)
            res.append(tmp)
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">64</span>--&gt;
例如:
给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],

    <span class="number">3</span>
   / \
  <span class="number">9</span>  <span class="number">20</span>
    /  \
   <span class="number">15</span>   <span class="number">7</span>
   
返回其层次遍历结果：

[
  [<span class="number">3</span>],
  [<span class="number">20</span>,<span class="number">9</span>],
  [<span class="number">15</span>,<span class="number">7</span>]
]
&lt;!--￼<span class="number">65</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题33）：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例1： </span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：数组长度 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>后序遍历定义：<code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li>二叉搜索树定义： 左子树中所有节点的值 &lt;根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
</li>
<li>
<blockquote>
<ul>
<li>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p>
</li>
<li>
<p>剑指offer：</p>
<ul>
<li><strong>相关题目</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和本题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根节点的值</li>
<li><strong>举一反三</strong>：如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归分治：根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p>
<ul>
<li>递归解析：
<ul>
<li><strong>终止条件：</strong> 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i≥j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，说明此子树结点数量≤1，无需判别正确性，因此直接返回true。</li>
<li>递推工作：
<ul>
<li>划分左右子树：遍历后序遍历[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时可划分出左子树区间[i,m-1]，右子树区间[m,j-1]，根节点索引j。</li>
<li><strong>判断是否为二叉搜索树：</strong>
<ul>
<li>左子树区间[i,m-1]内的所有结点都应小于postorder[j]。而上一步划分左右子树的步骤，已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间[m,j-1]内的所有结点都应大于postorder[j]。实现方式为遍历，当遇到小于等于postorder[j]的结点则跳出，否则可通过p=j判断是否为二叉搜索树。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> &amp;&amp;连接
<ul>
<li>p = j：判断此树是否正确</li>
<li>recur(i, m-1)：判断此树的左子树是否正确</li>
<li>recur(m, j - 1)：判断此树的右子树是否正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span>
        <span class="string">"""
        :type postorder: List[int]
        :rtype: bool
        """</span>
        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span>
            <span class="keyword">if</span> i &gt;= j:
                <span class="keyword">return</span> <span class="literal">True</span>
            p = i
            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:
                p += <span class="number">1</span>
            m = p
            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:
                p += <span class="number">1</span>
            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j <span class="number">-1</span>)
        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)
&lt;!--￼<span class="number">67</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题34）：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点的值得和刚好等于输入的整数，则当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父节点。因此我们在函数退出之前要再路径上删除当前结点并减去当前结点的值，以确保返回父节点时路径刚好是从根节点到父节点的路径。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+路径记录</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>pathSum(root, sum)</code> 函数：</strong>
<ul>
<li><strong>初始化：</strong> 结果列表 <code>res</code> ，路径列表 <code>path</code> 。</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li><strong><code>recur(root, tar) 函数：</code></strong>
<ul>
<li><strong>递推参数：</strong> 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</li>
<li><strong>终止条件：</strong> 若节点 <code>root</code> 为空，则直接返回。</li>
<li><strong>递推工作</strong>
<ul>
<li>路径更新： 将当前节点值 <code>root.val</code> 加入路径 <code>path</code> ；</li>
<li>目标值更新： <code>tar = tar - root.val</code>（即目标值 <code>tar</code> 从 <code>sum</code> 减至 00 ）；</li>
<li>路径记录： 当 ① <code>root</code> 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 <code>path</code> 加入 <code>res</code> 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop()</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>值得注意的是</strong>，记录路径时若直接执行 <code>res.append(path)</code> ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。正确做法：<code>res.append(list(path))</code> ，相当于复制了一个 path 并加入到 res 。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># Definition for a binary tree node.</span>
<span class="comment"># class TreeNode(object):</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>

<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span>
        <span class="string">"""
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """</span>
        res, path = [], []
        
        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, tar)</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> root:
                <span class="keyword">return</span> 
            path.append(root.val)
            tar -= root.val
            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:
                res.append(list(path))
            recur(root.left, tar)
            recur(root.right, tar)
            path.pop()
        recur(root, sum)
        <span class="keyword">return</span> res
&lt;!--￼<span class="number">68</span>--&gt;
输入：head = [[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]
输出：[[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]

输入：head = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]
输出：[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]

输入：head = [[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]
输出：[[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]

输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
&lt;!--￼<span class="number">69</span>--&gt;

- 优化迭代

  - 不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个链表结点的旁边拷贝，比如 A-&gt;B-&gt;C 变成 A-&gt;A<span class="string">'-&gt;B-&gt;B'</span>-&gt;C-&gt;C<span class="string">'，然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A'</span>-&gt;B<span class="string">'-&gt;C'</span>，最后返回 A<span class="string">'-&gt;B'</span>-&gt;C<span class="string">'。

  - 时间复杂度：O(N)

  - 空间复杂度：O(1)

  - ```python
    """
    # Definition for a Node.
    class Node:
        def __init__(self, x, next=None, random=None):
            self.val = int(x)
            self.next = next
            self.random = random
    """
    class Solution(object):
        def copyRandomList(self, head):
            """
            :type head: Node
            :rtype: Node
            """
            if not head:
                return head
            cur = head
            while cur:
                new_node = Node(cur.val,None,None)   # 克隆新结点
                new_node.next = cur.next
                cur.next = new_node   # 克隆新结点在cur 后面
                cur = new_node.next   # 移动到下一个要克隆的点
            cur = head
    
            while cur:  # 链接random
                cur.next.random = cur.random.next if cur.random else None
                cur = cur.next.next
    
            cur_old_list = head # 将两个链表分开
            cur_new_list = head.next
            new_head = head.next
            while cur_old_list:
                cur_old_list.next = cur_old_list.next.next
                cur_new_list.next = cur_new_list.next.next if cur_new_list.next else None
                cur_old_list = cur_old_list.next
                cur_new_list = cur_new_list.next
            return new_head
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 二叉搜索树与双向链表</span><br><span class="line"></span><br><span class="line">## 题目</span><br><span class="line"></span><br><span class="line">- 难度：中等</span><br><span class="line"></span><br><span class="line">- 题目（leetcode-面试题36）：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</span><br><span class="line"></span><br><span class="line">  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</span><br><span class="line"></span><br><span class="line">  特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br><span class="line"></span><br><span class="line">## 题解</span><br><span class="line"></span><br><span class="line">- **Tips**：中序遍历</span><br><span class="line"></span><br><span class="line">- &gt; 参考：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof&#x2F;solution&#x2F;mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5&#x2F;</span><br><span class="line"></span><br><span class="line">- 思想：</span><br><span class="line"></span><br><span class="line">  - 本文解法基于性质：二叉搜索树的中序遍历为 **递增序列** 。</span><br><span class="line">  - 将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</span><br><span class="line">    - **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点；</span><br><span class="line">    - **双向链表**：在构建相邻节点（设前驱节点pre，当前结点cur）关系时，应该满足&#96;pre.right &#x3D; cur&#96;，&#96;cur.left &#x3D; pre&#96;</span><br><span class="line">    - **循环链表**： 设链表头节点 head 和尾节点 tail，则应构建 &#96;head.left &#x3D; tail&#96;和 &#96;tail.right &#x3D; head。&#96;</span><br><span class="line"></span><br><span class="line">- 算法流程：</span><br><span class="line"></span><br><span class="line">  - **&#96;dfs(cur):&#96;** 递归法中序遍历；</span><br><span class="line">    - **终止条件：** 当节点 cur为空，代表越过叶节点，直接返回；</span><br><span class="line">    - 递归左子树，即 &#96;dfs(cur.left)&#96; ；</span><br><span class="line">    - **构建链表：**</span><br><span class="line">      - **当 pre为空时：** 代表正在访问链表头节点，记为 head 。</span><br><span class="line">      - **当 pre 不为空时**： 修改双向节点引用，即 pre.right &#x3D; cur， cur.left &#x3D; pre。</span><br><span class="line">      - **保存cur**：更新pre &#x3D; cur，即节点cur是后继节点的pre</span><br><span class="line">    - 递归右子树，即&#96;dfs(cur.left)&#96;</span><br><span class="line">  - **&#96;treeToDoublyList(root)：&#96;**</span><br><span class="line">    - **特例处理：** 若节点 root 为空，则直接返回；</span><br><span class="line">    - **初始化**： 空节点 pre ；</span><br><span class="line">    - **转化为双向链表**： 调用 &#96;dfs(root)&#96; ；</span><br><span class="line">    - 构建循环链表： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head和 pre 的双向节点引用即可。</span><br><span class="line">    - 返回值： 返回链表的头节点 head 即可。</span><br><span class="line"></span><br><span class="line">- 时间复杂度：O(N)</span><br><span class="line"></span><br><span class="line">- 空间复杂度：O(N)</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # Definition for a Node.</span><br><span class="line">  class Node(object):</span><br><span class="line">      def __init__(self, val, left&#x3D;None, right&#x3D;None):</span><br><span class="line">          self.val &#x3D; val</span><br><span class="line">          self.left &#x3D; left</span><br><span class="line">          self.right &#x3D; right</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  class Solution(object):</span><br><span class="line">      def treeToDoublyList(self, root):</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          :type root: Node</span><br><span class="line">          :rtype: Node</span><br><span class="line">          &quot;&quot;&quot;</span><br><span class="line">          def dfs(cur):</span><br><span class="line">              if not cur:</span><br><span class="line">                  return</span><br><span class="line">              dfs(cur.left) # 递归左子树</span><br><span class="line">              if self.pre: # 修改节点引用</span><br><span class="line">                  self.pre.right, cur.left &#x3D; cur, self.pre</span><br><span class="line">              else: # 记录头节点</span><br><span class="line">                  self.head &#x3D; cur</span><br><span class="line">              self.pre &#x3D; cur # 保存 cur</span><br><span class="line">              dfs(cur.right) # 递归右子树</span><br><span class="line">          </span><br><span class="line">          if not root:</span><br><span class="line">              return</span><br><span class="line">          self.pre &#x3D; None</span><br><span class="line">          dfs(root)</span><br><span class="line">          self.head.left, self.pre.right &#x3D; self.pre, self.head</span><br><span class="line">          return self.head</span><br></pre></td></tr></table></figure>

</span></code></pre>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># 牛客网解答</span>
<span class="comment"># -*- coding:utf-8 -*-</span>
<span class="comment"># class TreeNode:</span>
<span class="comment">#     def __init__(self, x):</span>
<span class="comment">#         self.val = x</span>
<span class="comment">#         self.left = None</span>
<span class="comment">#         self.right = None</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span>
        <span class="comment"># write code here</span>
        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:
            <span class="keyword">return</span> pRootOfTree
        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree.left <span class="keyword">and</span> <span class="keyword">not</span> pRootOfTree.right:
            <span class="keyword">return</span> pRootOfTree
        <span class="comment"># 处理左子树</span>
        self.Convert(pRootOfTree.left)
        left=pRootOfTree.left
 
        <span class="comment"># 连接根与左子树最大结点</span>
        <span class="keyword">if</span> left:
            <span class="keyword">while</span>(left.right):
                left=left.right
            pRootOfTree.left,left.right=left,pRootOfTree
 
        <span class="comment"># 处理右子树</span>
        self.Convert(pRootOfTree.right)
        right=pRootOfTree.right
 
        <span class="comment"># 连接根与右子树最小结点</span>
        <span class="keyword">if</span> right:
            <span class="keyword">while</span>(right.left):
                right=right.left
            pRootOfTree.right,right.left=right,pRootOfTree
             
        <span class="keyword">while</span>(pRootOfTree.left):
            pRootOfTree=pRootOfTree.left
        <span class="keyword">return</span> pRootOfTree
&lt;!--￼<span class="number">71</span>--&gt;
你可以将以下二叉树：

    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">3</span>
     / \
    <span class="number">4</span>   <span class="number">5</span>

序列化为 <span class="string">"[1,2,3,null,null,4,5]"</span>
&lt;!--￼<span class="number">72</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="字符串的排列"><a class="markdownIt-Anchor" href="#字符串的排列"></a> 字符串的排列</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题38）：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= s 的长度 &lt;= 8</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>求所有可能出现在第一个位置的字符,即把第一个字符和后面所有的字符进行交换</li>
<li>固定第一个字符，求后面所有字符的排列，这时候，可以把后面的所有字符分为两部分，后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N!)</p>
</li>
<li>
<p>空间复杂度：O(N^2)</p>
</li>
<li>
<pre class="highlight"><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span>
        <span class="string">"""
        :type s: str
        :rtype: List[str]
        """</span>
        n = len(s)
        <span class="keyword">if</span> n == <span class="number">1</span>:
            <span class="keyword">return</span> [s]
        <span class="keyword">else</span>:
            res = []
            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
                ch = s[i] <span class="comment">#取出s中每一个字符</span>
                dic = s[:i] + s[i + <span class="number">1</span> :]
                <span class="keyword">for</span> x <span class="keyword">in</span> self.permutation(dic):
                    res.append(ch + x) <span class="comment">#将ch 和子问题的解依次组合</span>
        <span class="keyword">return</span> list(set(res))
&lt;!--￼<span class="number">74</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#数组中出现次数超过一半的数字"></a> 数组中出现次数超过一半的数字</h1>
<h2 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题39）：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-24"><a class="markdownIt-Anchor" href="#题解-24"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，要注意以下问题：</p>
<ul>
<li>是否可以修改数组？</li>
<li>特例考虑，数组为空，或数组中不存在元素出现的次数超过数组长度一半</li>
</ul>
</li>
<li>
<p>思路：有三种思路</p>
<ul>
<li>第一种思路，对数组排序，数组n/2位置就是所求的数字。
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
<li>第二种思路，哈希表，遍历一遍数组，记录每个元素出现的次数，返回次数超过数组长度一半的数字
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>第三种思路，<strong>投票法</strong>，数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减一。如果次数为零，我们需要保存下一个数字，并把次数设置为1。由于我们要找的数字出现的次数比其他所有数字出现的次数和要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment">#投票法</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span>
        <span class="string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="keyword">if</span> <span class="keyword">not</span> nums:
            <span class="keyword">return</span>
        vote = <span class="number">0</span>
        count = <span class="number">0</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> nums:
            <span class="keyword">if</span> vote == <span class="number">0</span>:
                x = num
            vote += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span>
        <span class="keyword">for</span> num <span class="keyword">in</span> nums:
            <span class="keyword">if</span> num == x:
                count += <span class="number">1</span>
        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>
&lt;!--￼<span class="number">76</span>--&gt;

</code></pre>
</li>
</ul>
<h1 id="最小的k个数"><a class="markdownIt-Anchor" href="#最小的k个数"></a> 最小的k个数</h1>
<h2 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题40）：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解排序"><a class="markdownIt-Anchor" href="#题解排序"></a> 题解（排序）</h2>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/">https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2020/06/13/%E5%89%91%E6%8C%87offer1/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>剑指offer1</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>