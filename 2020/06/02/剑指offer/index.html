<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>剑指offer | </title><meta name="description" content="剑指offer"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="剑指offer"><meta name="twitter:description" content="剑指offer"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="剑指offer"><meta property="og:url" content="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/"><meta property="og:site_name" content=""><meta property="og:description" content="剑指offer"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/"><link rel="prev" title="剑指offer1" href="https://lesylin.com/2020/06/13/%E5%89%91%E6%8C%87offer1/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中重复的数字"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 数组中重复的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二维数组中的查找"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 二维数组中的查找</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#替换空格"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 替换空格</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从尾到头打印链表"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 从尾到头打印链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#重建二叉树"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 重建二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-5"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-5"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#用两个栈实现队列"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 用两个栈实现队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-6"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-6"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#用两个队列实现栈"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 用两个队列实现栈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-7"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#斐波那契数列"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text"> 斐波那契数列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-7"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-8"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#青蛙跳台阶问题"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text"> 青蛙跳台阶问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-8"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-9"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#旋转数组中最小的数字"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text"> 旋转数组中最小的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-9"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-10"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#矩阵中的路径"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text"> 矩阵中的路径</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-10"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-11"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#机器人的运动范围"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text"> 机器人的运动范围</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-11"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-12"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#剪绳子i"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text"> 剪绳子I</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-12"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-13"><span class="toc_mobile_items-number">14.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#剪绳子ii"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text"> 剪绳子II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-13"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-14"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二进制中1的个数"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text"> 二进制中1的个数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-14"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-15"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数值的整数次方"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text"> 数值的整数次方</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-15"><span class="toc_mobile_items-number">17.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-16"><span class="toc_mobile_items-number">17.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#打印从1到最大的n位数"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text"> 打印从1到最大的n位数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-16"><span class="toc_mobile_items-number">18.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-17"><span class="toc_mobile_items-number">18.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#删除链表的节点"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text"> 删除链表的节点</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-17"><span class="toc_mobile_items-number">19.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-18"><span class="toc_mobile_items-number">19.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#正则表达式匹配"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text"> 正则表达式匹配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-18"><span class="toc_mobile_items-number">20.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-19"><span class="toc_mobile_items-number">20.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#表示数值的字符串"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text"> 表示数值的字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-19"><span class="toc_mobile_items-number">21.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-20"><span class="toc_mobile_items-number">21.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#调整数组顺序使奇数位于偶数前面"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text"> 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-20"><span class="toc_mobile_items-number">22.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-21"><span class="toc_mobile_items-number">22.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#链表中倒数第k个结点"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text"> 链表中倒数第k个结点</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-21"><span class="toc_mobile_items-number">23.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-22"><span class="toc_mobile_items-number">23.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#反转链表"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text"> 反转链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-22"><span class="toc_mobile_items-number">24.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-23"><span class="toc_mobile_items-number">24.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#合并两个排序链表"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text"> 合并两个排序链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-23"><span class="toc_mobile_items-number">25.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-24"><span class="toc_mobile_items-number">25.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#树的子结构"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text"> 树的子结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-24"><span class="toc_mobile_items-number">26.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-25"><span class="toc_mobile_items-number">26.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉树的镜像"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text"> 二叉树的镜像</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-25"><span class="toc_mobile_items-number">27.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-26"><span class="toc_mobile_items-number">27.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#对称的二叉树"><span class="toc_mobile_items-number">28.</span> <span class="toc_mobile_items-text"> 对称的二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-26"><span class="toc_mobile_items-number">28.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-27"><span class="toc_mobile_items-number">28.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#顺时针打印矩阵"><span class="toc_mobile_items-number">29.</span> <span class="toc_mobile_items-text"> 顺时针打印矩阵</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-27"><span class="toc_mobile_items-number">29.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-28"><span class="toc_mobile_items-number">29.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#包含min函数的栈"><span class="toc_mobile_items-number">30.</span> <span class="toc_mobile_items-text"> 包含min函数的栈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-28"><span class="toc_mobile_items-number">30.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-29"><span class="toc_mobile_items-number">30.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#栈的压入-弹出序列"><span class="toc_mobile_items-number">31.</span> <span class="toc_mobile_items-text"> 栈的压入、弹出序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-29"><span class="toc_mobile_items-number">31.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-30"><span class="toc_mobile_items-number">31.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从上到下打印二叉树"><span class="toc_mobile_items-number">32.</span> <span class="toc_mobile_items-text"> 从上到下打印二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-30"><span class="toc_mobile_items-number">32.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-31"><span class="toc_mobile_items-number">32.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从上到下打印二叉树ii"><span class="toc_mobile_items-number">33.</span> <span class="toc_mobile_items-text"> 从上到下打印二叉树II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-31"><span class="toc_mobile_items-number">33.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-32"><span class="toc_mobile_items-number">33.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#从上到下打印二叉树iii"><span class="toc_mobile_items-number">34.</span> <span class="toc_mobile_items-text"> 从上到下打印二叉树III</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-32"><span class="toc_mobile_items-number">34.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-33"><span class="toc_mobile_items-number">34.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉搜索树的后序遍历序列"><span class="toc_mobile_items-number">35.</span> <span class="toc_mobile_items-text"> 二叉搜索树的后序遍历序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-33"><span class="toc_mobile_items-number">35.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-34"><span class="toc_mobile_items-number">35.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉树中和为某一值的路径"><span class="toc_mobile_items-number">36.</span> <span class="toc_mobile_items-text"> 二叉树中和为某一值的路径</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-34"><span class="toc_mobile_items-number">36.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-35"><span class="toc_mobile_items-number">36.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#复杂链表的复制"><span class="toc_mobile_items-number">37.</span> <span class="toc_mobile_items-text"> 复杂链表的复制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-35"><span class="toc_mobile_items-number">37.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-36"><span class="toc_mobile_items-number">37.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二叉搜索树与双向链表"><span class="toc_mobile_items-number">38.</span> <span class="toc_mobile_items-text"> 二叉搜索树与双向链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-36"><span class="toc_mobile_items-number">38.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-37"><span class="toc_mobile_items-number">38.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#序列化二叉树"><span class="toc_mobile_items-number">39.</span> <span class="toc_mobile_items-text"> 序列化二叉树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-37"><span class="toc_mobile_items-number">39.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-38"><span class="toc_mobile_items-number">39.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#字符串的排列"><span class="toc_mobile_items-number">40.</span> <span class="toc_mobile_items-text"> 字符串的排列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-38"><span class="toc_mobile_items-number">40.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-39"><span class="toc_mobile_items-number">40.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数组中出现次数超过一半的数字"><span class="toc_mobile_items-number">41.</span> <span class="toc_mobile_items-text"> 数组中出现次数超过一半的数字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-39"><span class="toc_mobile_items-number">41.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-40"><span class="toc_mobile_items-number">41.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#最小的k个数"><span class="toc_mobile_items-number">42.</span> <span class="toc_mobile_items-text"> 最小的k个数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-40"><span class="toc_mobile_items-number">42.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解排序"><span class="toc_mobile_items-number">42.2.</span> <span class="toc_mobile_items-text"> 题解（排序）</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中重复的数字"><span class="toc-number">2.</span> <span class="toc-text"> 数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">2.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-number">2.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二维数组中的查找"><span class="toc-number">3.</span> <span class="toc-text"> 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-2"><span class="toc-number">3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-number">3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#替换空格"><span class="toc-number">4.</span> <span class="toc-text"> 替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-3"><span class="toc-number">4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-number">4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从尾到头打印链表"><span class="toc-number">5.</span> <span class="toc-text"> 从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-4"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-number">5.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重建二叉树"><span class="toc-number">6.</span> <span class="toc-text"> 重建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-5"><span class="toc-number">6.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-number">6.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用两个栈实现队列"><span class="toc-number">7.</span> <span class="toc-text"> 用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-6"><span class="toc-number">7.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-number">7.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用两个队列实现栈"><span class="toc-number">8.</span> <span class="toc-text"> 用两个队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-7"><span class="toc-number">8.1.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">9.</span> <span class="toc-text"> 斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-7"><span class="toc-number">9.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-8"><span class="toc-number">9.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#青蛙跳台阶问题"><span class="toc-number">10.</span> <span class="toc-text"> 青蛙跳台阶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-8"><span class="toc-number">10.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-9"><span class="toc-number">10.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#旋转数组中最小的数字"><span class="toc-number">11.</span> <span class="toc-text"> 旋转数组中最小的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-9"><span class="toc-number">11.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-10"><span class="toc-number">11.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#矩阵中的路径"><span class="toc-number">12.</span> <span class="toc-text"> 矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-10"><span class="toc-number">12.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-11"><span class="toc-number">12.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#机器人的运动范围"><span class="toc-number">13.</span> <span class="toc-text"> 机器人的运动范围</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-11"><span class="toc-number">13.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-12"><span class="toc-number">13.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#剪绳子i"><span class="toc-number">14.</span> <span class="toc-text"> 剪绳子I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-12"><span class="toc-number">14.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-13"><span class="toc-number">14.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#剪绳子ii"><span class="toc-number">15.</span> <span class="toc-text"> 剪绳子II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-13"><span class="toc-number">15.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-14"><span class="toc-number">15.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二进制中1的个数"><span class="toc-number">16.</span> <span class="toc-text"> 二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-14"><span class="toc-number">16.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-15"><span class="toc-number">16.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值的整数次方"><span class="toc-number">17.</span> <span class="toc-text"> 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-15"><span class="toc-number">17.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-16"><span class="toc-number">17.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#打印从1到最大的n位数"><span class="toc-number">18.</span> <span class="toc-text"> 打印从1到最大的n位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-16"><span class="toc-number">18.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-17"><span class="toc-number">18.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除链表的节点"><span class="toc-number">19.</span> <span class="toc-text"> 删除链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-17"><span class="toc-number">19.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-18"><span class="toc-number">19.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正则表达式匹配"><span class="toc-number">20.</span> <span class="toc-text"> 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-18"><span class="toc-number">20.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-19"><span class="toc-number">20.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#表示数值的字符串"><span class="toc-number">21.</span> <span class="toc-text"> 表示数值的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-19"><span class="toc-number">21.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-20"><span class="toc-number">21.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#调整数组顺序使奇数位于偶数前面"><span class="toc-number">22.</span> <span class="toc-text"> 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-20"><span class="toc-number">22.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-21"><span class="toc-number">22.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表中倒数第k个结点"><span class="toc-number">23.</span> <span class="toc-text"> 链表中倒数第k个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-21"><span class="toc-number">23.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-22"><span class="toc-number">23.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反转链表"><span class="toc-number">24.</span> <span class="toc-text"> 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-22"><span class="toc-number">24.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-23"><span class="toc-number">24.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合并两个排序链表"><span class="toc-number">25.</span> <span class="toc-text"> 合并两个排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-23"><span class="toc-number">25.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-24"><span class="toc-number">25.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树的子结构"><span class="toc-number">26.</span> <span class="toc-text"> 树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-24"><span class="toc-number">26.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-25"><span class="toc-number">26.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树的镜像"><span class="toc-number">27.</span> <span class="toc-text"> 二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-25"><span class="toc-number">27.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-26"><span class="toc-number">27.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对称的二叉树"><span class="toc-number">28.</span> <span class="toc-text"> 对称的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-26"><span class="toc-number">28.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-27"><span class="toc-number">28.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#顺时针打印矩阵"><span class="toc-number">29.</span> <span class="toc-text"> 顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-27"><span class="toc-number">29.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-28"><span class="toc-number">29.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#包含min函数的栈"><span class="toc-number">30.</span> <span class="toc-text"> 包含min函数的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-28"><span class="toc-number">30.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-29"><span class="toc-number">30.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈的压入-弹出序列"><span class="toc-number">31.</span> <span class="toc-text"> 栈的压入、弹出序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-29"><span class="toc-number">31.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-30"><span class="toc-number">31.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从上到下打印二叉树"><span class="toc-number">32.</span> <span class="toc-text"> 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-30"><span class="toc-number">32.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-31"><span class="toc-number">32.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从上到下打印二叉树ii"><span class="toc-number">33.</span> <span class="toc-text"> 从上到下打印二叉树II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-31"><span class="toc-number">33.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-32"><span class="toc-number">33.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从上到下打印二叉树iii"><span class="toc-number">34.</span> <span class="toc-text"> 从上到下打印二叉树III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-32"><span class="toc-number">34.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-33"><span class="toc-number">34.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树的后序遍历序列"><span class="toc-number">35.</span> <span class="toc-text"> 二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-33"><span class="toc-number">35.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-34"><span class="toc-number">35.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-number">36.</span> <span class="toc-text"> 二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-34"><span class="toc-number">36.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-35"><span class="toc-number">36.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复杂链表的复制"><span class="toc-number">37.</span> <span class="toc-text"> 复杂链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-35"><span class="toc-number">37.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-36"><span class="toc-number">37.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树与双向链表"><span class="toc-number">38.</span> <span class="toc-text"> 二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-36"><span class="toc-number">38.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-37"><span class="toc-number">38.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化二叉树"><span class="toc-number">39.</span> <span class="toc-text"> 序列化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-37"><span class="toc-number">39.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-38"><span class="toc-number">39.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串的排列"><span class="toc-number">40.</span> <span class="toc-text"> 字符串的排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-38"><span class="toc-number">40.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-39"><span class="toc-number">40.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组中出现次数超过一半的数字"><span class="toc-number">41.</span> <span class="toc-text"> 数组中出现次数超过一半的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-39"><span class="toc-number">41.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-40"><span class="toc-number">41.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最小的k个数"><span class="toc-number">42.</span> <span class="toc-text"> 最小的k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-40"><span class="toc-number">42.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解排序"><span class="toc-number">42.2.</span> <span class="toc-text"> 题解（排序）</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">剑指offer</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-06-02<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-24</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">24.9k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 99分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 面试必备《剑指offer》，题解整理，方便今后自己查阅，要为接下来的秋招做准备了呀~</p>
<h1 id="数组中重复的数字"><a class="markdownIt-Anchor" href="#数组中重复的数字"></a> 数组中重复的数字</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题03)：找出数组中重复的数字。<strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有多种解法，如果面试中遇到这道题，让你找出数组中重复的数字，要向面试官询问，<u><strong>是否可以使用额外空间</strong></u>？<u><strong>是否可以修改原数组</strong></u>？然后，根据要求给出解决方案。（<strong><u>本题对数组长度做了限制，如果没有限制数组长度，需要进行非空判断</u></strong>）</p>
<ol>
<li>
<p><strong>使用额外空间，不修改原数组——哈希表</strong></p>
<ul>
<li>
<p>思路：遍历数组，用哈希表记录数组中每个数字出现的情况，如果该数字没有出现在哈希表，就将其加入哈希表，如果该数字在哈希表中已经存在，就直接返回。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——sort排序</strong></p>
<ul>
<li>
<p>思路：对数组排序，这样重复的两个数字的位置就是相邻的，然后，遍历一遍数组，判断相邻位置的两个数字是否相等，相等就返回，不相等就继续遍历。</p>
</li>
<li>
<blockquote>
<p>list.sort()的原理：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">https://blog.csdn.net/yangzhongblog/article/details/8184707</a></p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(nlogn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不使用额外空间，修改原数组——原地排序</strong></p>
<ul>
<li>
<p>思路：<strong>因为数组的数字范围和数组的长度是一样的，即与数组下标一一对应（把数组视为哈希表）</strong>。因此，我们看到数字，就可以知道把这个数字放在数组的哪个位置上。这就像是我们人为编写了哈希函数，这个哈希函数的规则还特别简单，而找到重复数字就是发生了哈希冲突。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<blockquote>
<p>Python 中， a, b = c, d 操作的原理是先暂存元组 (c, d) ，然后 “按顺序” 赋值给 a 和 b 。<br>
若写为 nums[i], nums[nums[i]] = nums[nums[i]], nums[i] ，则 nums[i] 先被赋值，之后 nums[nums[i]] 指向的元素则会出错。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> 二维数组中的查找</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题04）：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn><mi mathvariant="normal">，</mi><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0≤n≤1000，0≤m≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：如果这个n * m的数组是无序的，要查找该数组中是否存在目标整数，需要遍历完二维数组每一行或者每一列，即暴力求解法，时间复杂度是O(n*m)，空间复杂度是O(1)。仔细观察题目的二维数组，可以发现行和列的数字是按一定顺序排列的。</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后从数组中选取一个数字，分3种情况来分析查找过程。当数组中选取的数字刚好要和查找的数字相等时，就结束查找过程。如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取的位置的上边或者右边。（若当前选取位置在正中间，则在右下角或左上角可能会出现查找重叠区域）。</p>
</blockquote>
</li>
<li>
<p>思路：从数组的一个角上选取数字来和要查找的数字做比较。</p>
<ul>
<li>
<p>左上角数字：是所在列和行最小的数字（如果查找的数字大于左上角数字，情况和上述分析一样，可以往右边或者下边查找）</p>
</li>
<li>
<p>左下角数字：是所在列最大的数字，所在行最小的数字（如果查找的数字大于左下角数字，往右边查找，如果小于做左下角数字，往上边查找）</p>
</li>
<li>
<p>右上角数字：是所在列最小的数字，所在行最大的数字（如果查找的数字大于右上角数字，往下边查找，如果小于右上角数字，往左边查找）</p>
</li>
<li>
<p>右下角数字：是所在列和行最大的数字（如果查找的数字小于右下角数字，情况和上述分析一样，可以往左边或者上边查找）</p>
</li>
<li>
<p>因此，本题可以选择左下角数字或右上角数字来和查找的数字做比较。</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li>特殊用例：二维数组为空，返回空</li>
<li>假设从矩阵matrix的左下角数字开始遍历（索引设为i，j），与要查找的数字做比较：（右上角同理分析）
<ul>
<li>当<code>matrix[i][j] == target</code>，返回True</li>
<li>当<code>matrix[i][j] &gt; target</code>，行索引<code>i</code>向上查找，即<code>i--</code></li>
<li>当<code>matrix[i][j] &lt; target</code>，列索引<code>j</code>向右查找，即<code>j++</code></li>
</ul>
</li>
<li>若行索引或列索引越界，则代表矩阵中无目标值，返回 False。</li>
</ul>
</li>
<li>
<blockquote>
<p>算法本质： 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n + m)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = len(matrix) - <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="替换空格"><a class="markdownIt-Anchor" href="#替换空格"></a> 替换空格</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题05）：请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>s</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ s的长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成’%’、‘2’、'0’这3个字符，因此字符串会变长。如果是在原来的字符串上做替换，那么就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上做替换，那么我们可以自己分配足够多的内存。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：根据上述分析，在面试的时候，要明确面试官的需求，然后，从两种方案中选择一种完成。下面是三种最优的解法：</p>
<ol>
<li>
<p>使用replace函数（新）</p>
<ul>
<li>
<blockquote>
<p>python内置的<code>replace</code>函数用来替换字符串中指定的字符。</p>
<p>replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p>
<p>replace()方法语法：<code>str.replace(old, new[, max])</code></p>
<p>参数</p>
<ul>
<li>old – 将被替换的子字符串。</li>
<li>new – 新字符串，用于替换old子字符串。</li>
<li>max – 可选字符串, 替换不超过 max 次</li>
</ul>
<p>返回值：返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环（新）</p>
<blockquote>
<ul>
<li>Python的六个标准数据类型中不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）。</li>
</ul>
</blockquote>
<ul>
<li>
<p>将字符串先转换为list，然后，遍历list，当遍历到空格，就将空格替换成’%20’，最后，将list转成str。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        l = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            <span class="keyword">if</span> l[i] == <span class="string">' '</span>:</span><br><span class="line">                l[i] = <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>双指针移动+计数（原始）</p>
<ul>
<li>
<p>首先遍历一次字符串s，统计空格数</p>
</li>
<li>
<p>假设有m个空格，我们需要填充’%20’占用的三个字符串位置，所以需要额外开辟2 * m个空间</p>
</li>
<li>
<p>将开辟出的空间链接到原字符串的后面,新的字符串命名为s_new</p>
</li>
<li>
<p>设置两个指针p1和p2,初始时p1指向原字符串s的末尾,p2指向s_new的末尾</p>
</li>
<li>
<p>p1指针向前移动,当p1指向的字符不是空格时,将p1指向的字符复制到p2指向的位置,并都向前移动一位</p>
</li>
<li>
<p>当p1指向的字符是空格时,p1向前移动一格,这时应该插入%20,所以p2向前移动三格,并在这三格中插入%,2,0</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(2m)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s_len = len(s)</span><br><span class="line">        space_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</span><br><span class="line">                space_count += <span class="number">1</span></span><br><span class="line">        s_len += <span class="number">2</span> * space_count</span><br><span class="line">        new_array = [<span class="string">' '</span>] * s_len</span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p1 <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == <span class="string">' '</span>:</span><br><span class="line">                new_array[p2] = <span class="string">'%'</span></span><br><span class="line">                new_array[p2 + <span class="number">1</span>] = <span class="string">'2'</span></span><br><span class="line">                new_array[p2 + <span class="number">2</span>] = <span class="string">'0'</span></span><br><span class="line">                p2 += <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_array[p2] = s[p1]</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_array)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题06）：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 链表长度 ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：面试时候，需要明确**<u>是否允许在打印链表的时候修改链表的结构</u>**？如果可以修改，那么就是<u><strong>面试题24-反转链表</strong></u>，先对链表进行反转，然后输出。如果不可以修改，那肯定需要遍历链表，遍历顺序是从头到尾，输出是从尾到头，典型的“后进先出”，我们可以<u><strong>使用栈实现</strong></u>。想到栈，我们还可以想到递归，<u><strong>递归在本质上就是一个栈结构</strong></u>，即每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身。</p>
<ol>
<li>
<p><strong>修改链表结构-反转链表</strong>（具体看面试题24-反转链表）</p>
<ul>
<li>
<p>特殊用例：链表头结点指针为空，返回[]</p>
</li>
<li>
<p>双指针反转链表：</p>
</li>
<li>
<p>初始化两个指针，<code>pre == None</code>，<code>cur == head</code></p>
</li>
<li>
<p>遍历链表，用临时变量tmp记录当前结点，并将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></p>
</li>
<li>
<p>pre和cur都向链表尾部移动，直到cur为空。</p>
</li>
<li>
<p>题目要求用数组返回，因此，初始化数组<code>s = []</code>，遍历反转后的链表，依次将每个结点的值加入数组，然后返回数组s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            s.append(pre.val)</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-栈</strong>（迭代）：</p>
<ul>
<li>
<p>创建一个栈，用于存储链表结点</p>
</li>
<li>
<p>创建一个指针，初始时指向链表的头结点</p>
</li>
<li>
<p>当指针指向元素非空时，重复下列操作：</p>
<ul>
<li>将指针指向的结点压入栈内</li>
<li>将指针移到当前结点的下一个结点</li>
</ul>
</li>
<li>
<p>初始化数组<code>s=[]</code></p>
</li>
<li>
<p>当栈不为空时，重复下列操作：</p>
<ul>
<li>将栈顶结点弹出，将栈顶结点的值加入数组s</li>
</ul>
</li>
<li>
<p>返回数组s</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        i = head</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            stack.append(i)</span><br><span class="line">            i = i.next</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            s.append(stack.pop().val)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>python可以对上面的代码优化，不需要再创建一个数组s，可以直接利用切片，直接输出倒序列表stack</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        i = head</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            stack.append(i.val)</span><br><span class="line">            i = i.next</span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>不修改链表结构-递归</strong></p>
<ul>
<li>
<p><strong>利用递归：</strong> 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。</p>
</li>
<li>
<p><strong>递推阶段：</strong> 每次传入 <code>head.next</code> ，以 <code>head == None</code>（即走过链表尾部节点）为递归终止条件，此时返回空列表 <code>[]</code> 。</p>
</li>
<li>
<p><strong>回溯阶段：</strong> 利用 Python 语言特性，递归回溯时每次返回 <code>当前 list + 当前节点值 [head.val]</code>，即可实现节点的倒序输出</p>
</li>
<li>
<blockquote>
<p>（《剑指offer》分析）：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显示用栈基于循环实现的代码鲁棒性要好一些。</p>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="重建二叉树"><a class="markdownIt-Anchor" href="#重建二叉树"></a> 重建二叉树</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题07）：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给出</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0 ≤ 节点个数 ≤ 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>
<p>思路：根据前序遍历和中序遍历的特点，可以对前序遍历和中序遍历序列进行划分，划分出左子树、根节点、右子树的区间，然后，递归构造二叉树。</p>
<ul>
<li>特殊用例：前序遍历为空或中序遍历为空或节点个数≤0，返回None（前序遍历和中序遍历不匹配）</li>
<li>根据前序遍历特点，前序遍历序列的第一个数字是根节点的值，即<code>root_val = preorder[0]</code></li>
<li>构建根节点，<code>root = TreeNode(root_val)</code></li>
<li>确定根节点在中序遍历的序列的索引：<code>root_in_index = inorder.index(root_val)</code></li>
<li>确定左子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>确定右子树在前序遍历序列的区间，以及在中序遍历序列的区间</li>
<li>递归构建左子树和右子树</li>
<li>返回root</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        root_in_index = inorder.index(root_val)</span><br><span class="line">        left_pre = preorder[<span class="number">1</span>: root_in_index + <span class="number">1</span>]</span><br><span class="line">        left_in = inorder[: root_in_index]</span><br><span class="line">        right_pre = preorder[root_in_index + <span class="number">1</span>:]</span><br><span class="line">        right_in = inorder[root_in_index + <span class="number">1</span>:]</span><br><span class="line">        root.left = self.buildTree(left_pre, left_in)</span><br><span class="line">        root.right = self.buildTree(right_pre, right_in)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="用两个栈实现队列"><a class="markdownIt-Anchor" href="#用两个栈实现队列"></a> 用两个栈实现队列</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题09）：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 ≤ values ≤ 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li>最多会对 appendTail、deleteHead 进行 10000 次调用</li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<blockquote>
<ul>
<li>（《剑指offer》分析）：
<ul>
<li>初始化stack1和stack2</li>
<li>插入元素：将元素插入stack1</li>
<li>删除元素：stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack1:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack1:</span><br><span class="line">            self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure>
<h1 id="用两个队列实现栈"><a class="markdownIt-Anchor" href="#用两个队列实现栈"></a> 用两个队列实现栈</h1>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：pop(0)是pop第一个元素，pop()是pop最后一个元素，时间效率上pop最后一个元素效率高。pop用于stack，可带参数，popleft用于collections中，不可带参数。（都是pop出来且在原数据删除）</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>初始化两个队列，q1和q2</li>
<li>进栈：元素队列q1</li>
<li>出栈：当队列q1只有一个元素，直接出队，否则，把q1的元素出队并入队q2，直到q1中只有一个元素，再直接出队。为了下一次继续操作，互换q1和q2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.q1 = []</span><br><span class="line">        self.q2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.q1.append(val)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.q1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> len(self.q1) != <span class="number">1</span>:</span><br><span class="line">            self.q2.append(self.q1.pop(<span class="number">0</span>))</span><br><span class="line">        self.q1, self.q2 = self.q2, self.q1</span><br><span class="line">        <span class="keyword">return</span> self.q2.pop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    l = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">        s.push(l[i])</span><br><span class="line">    print(l)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">        print(s.pop(), <span class="string">','</span>, end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="斐波那契数列"><a class="markdownIt-Anchor" href="#斐波那契数列"></a> 斐波那契数列</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-I）：写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[ <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
<li>可以用3个变量，sum，a，b，优化上述代码，时间复杂度不变，空间复杂度降为O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a,b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h1 id="青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#青蛙跳台阶问题"></a> 青蛙跳台阶问题</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题10-II）：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 ≤ n ≤ 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</li>
<li>此类求 多少种可能性 的题目一般都有 递推性质 ，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n - 1)....f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间是有联系的。</li>
<li>设跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。</li>
<li>当为 1 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>种跳法；</li>
<li>当为 2 级台阶： 剩 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个台阶，此情况共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>种跳法。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为以上两种情况之和，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> ，以上递推性质为斐波那契数列。</li>
<li>本题可转化为 求斐波那契数列第 n项的值 ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。
<ul>
<li>青蛙跳台阶问题： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(0)=1 , f(1)=1 , f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ；</li>
<li>斐波那契数列问题：$ f(0)=0 , f(1)=1 , f(2)=1$ ;</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：直接在面试题10-I 斐波那契数列的基础上，将起始数字做一个修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        one = <span class="number">1</span></span><br><span class="line">        two = <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            res = one + two</span><br><span class="line">            one = two</span><br><span class="line">            two = res</span><br><span class="line">        m = max(n, res)</span><br><span class="line">        <span class="keyword">return</span> m % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="旋转数组中最小的数字"><a class="markdownIt-Anchor" href="#旋转数组中最小的数字"></a> 旋转数组中最小的数字</h1>
<h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题11）：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<strong>输入一个递增排序的数组的一个旋转</strong>，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2>
<ul>
<li><strong>Tips</strong>：<strong><u>如果面试题是要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。关于查找和排序见另一篇博客《八大排序》</u></strong></li>
</ul>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></li>
<li>参考2：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/er-fen-jian-zhi-si-xiang-fen-zhi-si-xiang-by-liwei/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：</p>
<ul>
<li>根据题目可以发现，输入的递增排序数组，可以从中点划分成两个递增数组。左排序数组的任一元素都大于右排序数组的任一元素。</li>
<li>双指针法，初始化两个指针i，j，指向数组的头和尾，即<code>i == 0</code>， <code>j == len(numbers)</code></li>
<li><code>mid = (i + j) // 2</code>，每次二分的中点</li>
<li>当<code>numbers[mid] &gt; numbers[j]</code>，m在左边的递增数组，最小元素一定在[m+1, j]</li>
<li>当<code>numbers[mid] &lt; numbers[j]</code>，m在右边的递增数组，最小元素一定在[i,m]</li>
<li>当<code>numbers[mid] = numbers[j]</code>，无法判断m在哪，缩小区间即可[i,j-1]</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            mid = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &gt; numbers[j]:</span><br><span class="line">                i = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; numbers[j]:</span><br><span class="line">                j = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="矩阵中的路径"><a class="markdownIt-Anchor" href="#矩阵中的路径"></a> 矩阵中的路径</h1>
<h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题12）：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,“<strong>b</strong>”,“c”,“e”],<br>
[“s”,“<strong>f</strong>”,“<strong>c</strong>”,“s”],<br>
[“a”,“d”,“<strong>e</strong>”,“e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1 &lt;= board.length &lt;= 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1 &lt;= board[i].length &lt;= 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2>
<blockquote>
<ul>
<li>参考https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：DFS+剪枝</p>
<ul>
<li>递归参数：当前元素在矩阵<code>board</code>中行列索引<code>i</code>和<code>j</code>，当前目标字符在<code>word</code>中的索引<code>k</code>。</li>
<li>终止条件：
<ul>
<li>返回false：①行或列索引越界或②当前矩阵元素与目标字符不同或③当前矩阵元素已访问过（③可合并至②）。</li>
<li>返回true：字符串<code>word</code>已全部匹配，即<code>k == len(word) - 1</code>。</li>
</ul>
</li>
<li>递推工作：
<ul>
<li>标记当前矩阵元素：将<code>board[i][j]</code>值暂存于变量<code>tmp</code>，并修改为字符<code>'/'</code>，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格：朝当前元素的上、下、左、右四个方向开启下层递归，使用或连接（代表只需一条可行路径），并记录结果至<code>res</code>。</li>
<li>还原当前矩阵元素：将<code>tmp</code>暂存值还原至<code>board[i][j]</code>元素。</li>
</ul>
</li>
<li>回溯返回值：返回<code>res</code>，代表是否搜索到目标字符串。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)</p>
</li>
<li>
<p>空间复杂度：O(K)</p>
</li>
<li>
<p>M,N 分别为矩阵行列大小， K<em>K</em> 为字符串 <code>word</code> 长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="comment"># 如果路径出界或者矩阵中的值不是word的首字母，返回False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">"/"</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j <span class="number">-1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网对应的这个题的python解法的通过榜单的榜首的代码都会有部分case过不了，正确代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i*cols + j] == path[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(list(matrix), rows, cols, path[<span class="number">1</span>:], i, j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, rows, cols, path, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        matrix[i*cols + j] = <span class="string">'-'</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> ((i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> matrix[x*cols+y]==path[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> self.dfs(matrix, rows, cols, path[<span class="number">1</span>:], x, y):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="机器人的运动范围"><a class="markdownIt-Anchor" href="#机器人的运动范围"></a> 机器人的运动范围</h1>
<h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题13）：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 &lt;= n,m &lt;= 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">0 &lt;= k &lt;= 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>类似矩阵搜索问题，通常可以采用深度优先搜索（DFS）或广度优先搜索（BFS）。 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。BFS 实现： 通常利用队列实现广度优先遍历。</li>
<li>python的set()：<a href="https://www.runoob.com/python3/python3-set.html%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%88set%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E7%9A%84%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%EF%BC%8C%E5%B0%86%E5%85%83%E7%B4%A0s%E5%8A%A0%E5%85%A5%E9%9B%86%E5%90%88%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E5%B7%B2%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E8%BF%9B%E8%A1%8C%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%9B%86%E5%90%88%E5%BF%85%E9%A1%BB%E7%94%A8" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-set.html，集合（set）是一个无序的不重复元素序列，将元素s加入集合，如果元素已存在，则不进行任何操作。注意：创建一个空集合必须用</a> <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</li>
</ul>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/</a></p>
</blockquote>
</li>
<li>
<p>思路1：</p>
<ul>
<li>DFS
<ul>
<li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li>
<li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li>
<li>递推工作：
<ul>
<li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li>
<li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li>
</ul>
</li>
</ul>
</li>
<li>时间复杂度：O(MN)，[MN为矩阵行列大小]</li>
<li>空间复杂度：O(MN)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, si, sj)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj) + dfs(i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj <span class="number">-8</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：</p>
<ul>
<li>BFS
<ul>
<li>初始化： 将机器人初始点 (0, 0)加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：</li>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li>
<li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue, visited = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j, si, sj = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add((i, j))</span><br><span class="line">            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))</span><br><span class="line">            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="剪绳子i"><a class="markdownIt-Anchor" href="#剪绳子i"></a> 剪绳子I</h1>
<h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14-I）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>58</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/</a>
<ul>
<li>写的很详细</li>
<li>面试时建议从方法三开始描述，再提出下面的优化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>思路</strong>：<strong>状态转移方程</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>j</mi><mo separator="true">,</mo><mi>j</mi><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中dp[i]表示维持原状态不剪、(i-j) * j表示从j处剪，剪下来的部分就是i-j，i-j不再剪了，j * dp[i-j]表示从j处剪，剪下来的部分是i-j，i-j继续剪。</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)，仅用了有限长数组</p>
</li>
<li>
<p>下面代码更适合面试时使用，即动态规划思路</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
<li>下面代码适合了解学习，属于找规律，数学方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a)</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="剪绳子ii"><a class="markdownIt-Anchor" href="#剪绳子ii"></a> 剪绳子II</h1>
<h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题14II）：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">2 &lt;= n &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：和面试题14I - 剪绳子I的解题思想是一样的，在此基础上，考虑<strong>大数越界情况下的求余</strong>问题。</p>
</li>
<li>
<blockquote>
<p>参考链接里介绍的求余方法：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b = n // <span class="number">3</span>, n % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">elif</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span> % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">3</span>, a) * <span class="number">2</span> % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二进制中1的个数"><a class="markdownIt-Anchor" href="#二进制中1的个数"></a> 二进制中1的个数</h1>
<h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题15）：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2>
<ul>
<li>
<blockquote>
<p><strong>Tips</strong>：（剑指offer)位运算的使用**。位运算总共只有五种运算：<strong>与、或、异或、左移、右移</strong>。与、或和异或运算的规律我们可以用下表总结：</p>
<table>
<thead>
<tr>
<th>与（&amp;）</th>
<th>0&amp;0 = 0</th>
<th>1&amp;0=0</th>
<th>0&amp;1=0</th>
<th>1&amp;1=1</th>
</tr>
</thead>
<tbody>
<tr>
<td>或（！）</td>
<td>0|0 = 0</td>
<td>1|0=1</td>
<td>0|1=0</td>
<td>1|1=1</td>
</tr>
<tr>
<td>异或（^）</td>
<td>0^0 = 0</td>
<td>1^0=1</td>
<td>0^1=1</td>
<td>1^1=0</td>
</tr>
</tbody>
</table>
<ul>
<li>左移运算符m&lt;&lt;n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。比如：
<ul>
<li>00001010&lt;&lt;2 = 00101000</li>
<li>10001010&lt;&lt;3=01010000</li>
</ul>
</li>
<li>右移运算符m&gt;&gt;n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。
<ul>
<li>00001010&gt;&gt;2=00000010</li>
<li>10001010&gt;&gt;3=11110001</li>
</ul>
</li>
<li><strong>除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。</strong></li>
<li>面试时候可以按照基本思路到下面代码思路进行描述：
<ul>
<li>先判断整数二进制表示中最右边一位是不是1，只需要把整数与1做位与运算，是1就右移1位，直到整个整数为0（如果是有符号数，也就是如果输入负数，这样会产生死循环。</li>
<li>把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多次这样的操作。
<ul>
<li>例如，二进制数1100，它的第二位是从最右边数起的一个1。减去1后，第二位变成0，而前面的1保持不变，因此得到结果1011，然后再把1100与1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。</li>
</ul>
</li>
</ul>
</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/</a></li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(n)，n为整数二进制1的个数</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一行写法</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum(n &gt;&gt; i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">32</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数值的整数次方"><a class="markdownIt-Anchor" href="#数值的整数次方"></a> 数值的整数次方</h1>
<h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题16）：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，<strong>同时不需要考虑大数问题。</strong></p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2^-2 &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</li>
</ul>
</li>
</ul>
<h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2>
<blockquote>
<ul>
<li>（剑指offer)：用一条语句判断<strong>一个整数是不是2的整数次方</strong>。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位是都是0。根据二进制中1的个数分析思路，判断一个整数是不是2的整数次方，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。因此，解决这个问题可以分为两步：
<ul>
<li>第一步：求这两个数的异或</li>
<li>第二步：统计异或结果中1的位数</li>
</ul>
</li>
<li>本题思路参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/di-gui-xie-fa-fen-zhi-si-xiang-yu-fei-di-gui-xie-f/</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></li>
</ul>
</li>
<li><strong>计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。</strong>
<ul>
<li>python比较两个float类型的数据是否相等：<a href="https://blog.csdn.net/weixin_34227447/article/details/88713033" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34227447/article/details/88713033</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制问题都可以用这个思路解决。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>考虑输入指数是负数和零的情况。</li>
<li>考虑特殊用例：0的0次方，可以输出0或1</li>
<li><strong>细节</strong>：判断两个double或float类型数值是否相等。位运算代替乘除法以及求余运算。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(logn)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>下面代码可以通过leetcode，但是通过上述分析，我们可以知道，x是double类型，不能直接写 x == 0，因此可以定义一个equal函数进行判断（<code>return abs(num1 - num2) &lt;= 0.0000001</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#打印从1到最大的n位数"></a> 打印从1到最大的n位数</h1>
<h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题17）：输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>说明：</p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
</li>
</ul>
<h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>
<blockquote>
<ul>
<li>
<p>（剑指offer）分析：<strong>大数问题</strong>。如果题目要求的是任意大的数字，那么这个题目就是一个大数问题，需要特殊的数据结构来表示数字，比如<strong>用字符串或者数组来表示大的数字，以确保不会溢出</strong>。</p>
</li>
<li>
<p>3种错误处理的方法的优缺点：</p>
<ul>
<li>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>返回值</td>
<td>和系统API一致</td>
<td>不能方便地使用计算结果</td>
</tr>
<tr>
<td>全局变量</td>
<td>能够方便地使用计算结果</td>
<td>用户可能会忘记检查全局变量</td>
</tr>
<tr>
<td>异常</td>
<td>可以为不同的出错原因定义不同异常类型，逻辑清晰明了</td>
<td>有些语言不支持异常，抛出异常时对性能有负面影</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="https://blog.csdn.net/chocolate_chuqi/article/details/81700551" target="_blank" rel="noopener">https://blog.csdn.net/chocolate_chuqi/article/details/81700551</a></li>
<li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/quan-pai-lie-di-gui-suan-fa-pythonshi-xian-by-flyi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/quan-pai-lie-di-gui-suan-fa-pythonshi-xian-by-flyi/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：全排列递归求解</p>
<ul>
<li>从左边第一个非0位开始输出；</li>
<li>要考虑0这个特殊值，否则答案会包括0 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = [] <span class="comment"># 用来保存结果</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        number = [<span class="string">"0"</span>]*n</span><br><span class="line">        number[<span class="number">-1</span>] = <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[<span class="number">0</span>] = chr(ord(<span class="string">"0"</span>)+i) <span class="comment"># ord 是将一个字符转换成 ASCII 码，chr 是将一个 ASCII 码转换成一个数字</span></span><br><span class="line">            self.Print1ToMaxOfDigitsRecursively(number, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.result[<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print1ToMaxOfDigitsRecursively</span><span class="params">(self, number, length, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span>:</span><br><span class="line">            self.PrintNumberNormal(number)</span><br><span class="line">            self.result.append(int(<span class="string">""</span>.join(number)))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            number[index+<span class="number">1</span>] = chr(ord(<span class="string">"0"</span>)+i)</span><br><span class="line">            self.Print1ToMaxOfDigitsRecursively(number, length, index+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintNumberNormal</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        number = int(<span class="string">""</span>.join(number))</span><br><span class="line">        <span class="keyword">if</span> number != <span class="number">0</span>:</span><br><span class="line">            print(number)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="删除链表的节点"><a class="markdownIt-Anchor" href="#删除链表的节点"></a> 删除链表的节点</h1>
<h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题18）：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>**注意：**此题对比原题有改动</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
</li>
</ul>
<h2 id="题解-18"><a class="markdownIt-Anchor" href="#题解-18"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有两种思路.</p>
<ul>
<li>第一个是得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code>（数据输入类型是整型val）</li>
<li>第二个是把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除（剑指offer思路，数据输入类型是链表ListNode）</li>
</ul>
</li>
<li>
<p>思路1：得到需要删除结点的前面一个结点，然后执行<code>pre.next = cur.next</code></p>
<ul>
<li>初始化双指针，pre指向head，cur指向head.next</li>
<li>当head为空时，返回head</li>
<li>当head是要删除的结点，返回head.next</li>
<li>遍历链表，当cur指向的结点是要删除的结点时，pre.next = cur.next，直到链表遍历完</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)，n是链表长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre = head</span><br><span class="line">        cur = head.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单指针写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.next.val == val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：把需要删除结点的下一个结点的内容复制到需要删除的结点上，再把下一个结点删除。</p>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/cong-on-dao-o1-by-ml-zimingmeng/</a></li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h1>
<h2 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题19）：请实现一个函数用来匹配包含 <code>'.'</code> 和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</p>
</li>
<li>
<p><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>'*'</code>。</p>
</li>
</ul>
<h2 id="题解-19"><a class="markdownIt-Anchor" href="#题解-19"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：
<ul>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></li>
<li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</a></li>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode/</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：回溯法+动态规划</p>
</li>
<li>
<p>思路1：回溯</p>
</li>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，其中T和P分别表示匹配串和模式串的长度。</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo><msup><mn>2</mn><mi>T</mi></msup><mo>+</mo><msup><mn>2</mn><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((T+P)2^T+2^{p/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字母是否匹配</span></span><br><span class="line">        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">        <span class="comment"># 如果 p 第二个字母是 *</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：动态规划-自顶向下</p>
</li>
<li>
<p>时间复杂度：O(TP)</p>
</li>
<li>
<p>空间复杂度：O(TP)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> j == len(p):</span><br><span class="line">                    ans = i == len(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first_match = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;</span><br><span class="line">                    <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(p) <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                        ans = dp(i, j+<span class="number">2</span>) <span class="keyword">or</span> first_match <span class="keyword">and</span> dp(i+<span class="number">1</span>, j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans = first_match <span class="keyword">and</span> dp(i+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                memo[i, j] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[i, j]</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="表示数值的字符串"><a class="markdownIt-Anchor" href="#表示数值的字符串"></a> 表示数值的字符串</h1>
<h2 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题20）：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</li>
</ul>
<h2 id="题解-20"><a class="markdownIt-Anchor" href="#题解-20"></a> 题解</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 除去两端空格</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 检查字符合法性</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"0987654321+-e."</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 有e的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 检查e的个数</span></span><br><span class="line">            <span class="keyword">if</span> s.count(<span class="string">'e'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 划分，并检查左右子串是否为空</span></span><br><span class="line">            p = s.index(<span class="string">'e'</span>)</span><br><span class="line">            ls = s[:p]</span><br><span class="line">            rs = s[p+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> len(ls)==<span class="number">0</span> <span class="keyword">or</span> len(rs)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串+-</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> ls <span class="keyword">and</span> (ls[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(ls)&lt;<span class="number">2</span>)) <span class="keyword">or</span> ls.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> rs <span class="keyword">and</span> (rs[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(rs)&lt;<span class="number">2</span>)) <span class="keyword">or</span> rs.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左右字串小数点个数</span></span><br><span class="line">            <span class="keyword">if</span> ls.count(<span class="string">'.'</span>)&gt;<span class="number">1</span> <span class="keyword">or</span> rs.count(<span class="string">'.'</span>)&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = ls.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查小数点左或右有没有数字</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = ls.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> ls[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(ls) <span class="keyword">and</span> ls[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 没e的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(s)&lt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'+'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'+'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> <span class="keyword">in</span> s <span class="keyword">and</span> (s[<span class="number">0</span>]!=<span class="string">'-'</span> <span class="keyword">or</span> len(s)&lt;<span class="number">2</span>)) <span class="keyword">or</span> s.count(<span class="string">'-'</span>)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dc = s.count(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">if</span> dc&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> dc==<span class="number">1</span>:</span><br><span class="line">                p = s.index(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ((p<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> s[p<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>) <span class="keyword">or</span> (p+<span class="number">1</span>&lt;len(s) <span class="keyword">and</span> s[p+<span class="number">1</span>] <span class="keyword">in</span> <span class="string">'0987654321'</span>)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#调整数组顺序使奇数位于偶数前面"></a> 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题21）：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解-21"><a class="markdownIt-Anchor" href="#题解-21"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：<strong>位运算比求余效率高</strong>。在《剑指offer》分析中，双指针方法适合初级程序员，高级一点的写法，应该把整个函数解耦成两部分，一是判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作，这样无论是奇数在偶数前面的数组划分，还是能被3整除的数划分就可以直接求解了，提高代码重用性。</p>
</li>
<li>
<p>思路：双指针</p>
<ul>
<li>初始化双指针，<code>i = 0</code>，<code>j = len(nums) - 1</code></li>
<li>遍历数组，指针i从左向右找偶数，指针j从右向左找奇数</li>
<li>将偶数nums[i]和奇数nums[j]交换</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>] + [n <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>高级一点写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pBegin = <span class="number">0</span></span><br><span class="line">        pEnd = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> <span class="keyword">not</span> self.isEven(nums[pBegin]):</span><br><span class="line">                pBegin += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pBegin &lt; pEnd <span class="keyword">and</span> self.isEven(nums[pEnd]):</span><br><span class="line">                pEnd -= <span class="number">1</span></span><br><span class="line">            nums[pBegin], nums[pEnd] = nums[pEnd], nums[pBegin]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n &amp; <span class="number">1</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="链表中倒数第k个结点"><a class="markdownIt-Anchor" href="#链表中倒数第k个结点"></a> 链表中倒数第k个结点</h1>
<h2 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题22）：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-22"><a class="markdownIt-Anchor" href="#题解-22"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这类找链表结点的题，通常可以用<strong>双指针</strong>法解决，如链表中点，链表是否有环等。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>定义两个指针，pre和cur</li>
<li>第一个指针cur从链表的头指针开始遍历向前走k-1，第二个指针pre保持不动</li>
<li>从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当cur指针到达链表的为尾结点时，pre正好是倒数第k个结点。</li>
<li>这里要注意三个点：head为空、链表结点数少于k、k为0。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre = head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题24）：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
</li>
</ul>
<h2 id="题解-23"><a class="markdownIt-Anchor" href="#题解-23"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：这道题有三种解法求解，双指针（最优）、辅助栈、递归。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/</a></p>
</blockquote>
</li>
<li>
<p>思路1：双指针</p>
<ul>
<li>定义3个指针，tmp，pre，cur，分别指向当前遍历结点、它的前一个结点和后一个结点</li>
<li>遍历链表，将当前结点的下一个结点指向当前结点的前一个结点，即<code>cur.next = pre</code></li>
</ul>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：辅助栈，遍历链表，将链表结点依次入栈，然后依次出栈，即实现反转链表</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        h = stack.pop()</span><br><span class="line">        p = h</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            h.next = stack.pop()</span><br><span class="line">            h = h.next</span><br><span class="line">        h.next = <span class="literal">None</span> <span class="comment">#防止链表循环</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路3：递归</p>
</li>
<li>
<p>时间复杂度：O(n)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 这里的cur就是最后一个节点</span></span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">				<span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">				<span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">        head.next.next = head</span><br><span class="line">        <span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="合并两个排序链表"><a class="markdownIt-Anchor" href="#合并两个排序链表"></a> 合并两个排序链表</h1>
<h2 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题25）：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 链表长度 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">链</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-24"><a class="markdownIt-Anchor" href="#题解-24"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>初始化：
<ul>
<li>伪头结点new_head，结点cur指向new_head</li>
<li>双指针，p1和p2，分别指向两个链表的头结点</li>
</ul>
</li>
<li>循环合并：当p1或p2为空跳出
<ul>
<li>当<code>p1.val &lt; p2.val</code>时，cur的后继结点指向l1，且l1向前一步</li>
<li>当<code>p1.val &gt; p2.val</code>时，cur的后继结点指向l2，且l2向前一步</li>
<li>结点cur向前一步，即<code>cur = cur.next</code></li>
</ul>
</li>
<li>合并剩余尾部：跳出时有两种情况，即p1为空或p2为空
<ul>
<li>若p1不等于null，将p1剩余结点添加至cur后</li>
<li>否则，将p2剩余结点添加至cur后</li>
</ul>
</li>
<li>返回new_head.next</li>
</ul>
</li>
<li>
<p>时间复杂度：O(M+N)，M，N分别为两个链表的长度</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = new_head</span><br><span class="line">        p1 = l1</span><br><span class="line">        p2 = l2</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                cur.next = p1</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = p2</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = p1 <span class="keyword">if</span> p1 <span class="keyword">else</span> p2</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="树的子结构"><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h1>
<h2 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题26）：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"> </span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line"> </span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-25"><a class="markdownIt-Anchor" href="#题解-25"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+包含判断+递归</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</a></p>
</blockquote>
</li>
<li>
<p>思路：</p>
<ul>
<li>第一步：在树A种找到和B的根节点的值一样的结点R（实质：树的遍历）</li>
<li>第二步：判断树A中以R为根节点的子树是不是包含和树B一样的结构</li>
</ul>
</li>
<li>
<p>时间复杂度：O(MN)，M和N分别为两棵树的节点数</p>
</li>
<li>
<p>空间复杂度：O(M)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: TreeNode</span></span><br><span class="line"><span class="string">        :type B: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (A <span class="keyword">and</span> B):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> dfs(A.left, B.left) <span class="keyword">and</span> dfs(A.right, B.right)</span><br><span class="line">        <span class="keyword">return</span> dfs(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树的镜像"><a class="markdownIt-Anchor" href="#二叉树的镜像"></a> 二叉树的镜像</h1>
<h2 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题27）：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">镜像输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-26"><a class="markdownIt-Anchor" href="#题解-26"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：求树的镜像的过程其实就是在遍历树的同时交换非叶结点的左右子结点。（递归 or 辅助栈）</p>
</li>
<li>
<p>思路：前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子节点的左右子结点之后，就得到了树的镜像。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/</a></p>
</blockquote>
</li>
<li>
<p>递归法</p>
<ul>
<li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li>
<li>递归解析：
<ul>
<li>递归终止条件：当节点root为空的时候，返回null</li>
<li>递推工作：
<ul>
<li>初始化结点tmp，用于暂存root的左子结点</li>
<li>开启递归右子结点，并将返回值给root的左子结点</li>
<li>开启递归左子结点，并将返回值给root的右子结点</li>
</ul>
</li>
<li>返回当前结点root</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>辅助栈：</p>
<ul>
<li>利用栈（或队列）遍历树的所有节点node ，并交换每个node的左 / 右子节点。</li>
<li>算法流程：
<ul>
<li>特例处理：当root为空，返回root</li>
<li>初始化：栈，并加入根节点</li>
<li>循环交换：当栈stack为空时跳出
<ul>
<li>出栈：记为node</li>
<li>添加子结点：将node的左右子结点入栈</li>
<li>交换，交换node的左右子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="对称的二叉树"><a class="markdownIt-Anchor" href="#对称的二叉树"></a> 对称的二叉树</h1>
<h2 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题28）：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= 节点个数 &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
</li>
</ul>
<h2 id="题解-27"><a class="markdownIt-Anchor" href="#题解-27"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：递归 or 队列</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/</a></p>
<ul>
<li>对称二叉树的定义：对于树中 <strong>任意两个对称节点</strong> L和 R ，一定有：
<ul>
<li>L.val = R.val：即此两对称结点值相等</li>
<li>L.left.val = R.right.val：即L的左子结点和R的右子结点对称</li>
<li>L.right.val = R.left.val：即L的右子结点和R的左子结点对称</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归</p>
<ul>
<li>算法流程：
<ul>
<li><strong><code>isSymmetric(root)</code> ：</strong>
<ul>
<li>特例处理：若根节点为空，则直接返回root</li>
<li>返回值：<code>recur(root.left,root.right)</code></li>
</ul>
</li>
<li><strong><code>recur(L, R)</code> ：</strong>
<ul>
<li>终止条件:
<ul>
<li>当L和R同时越过叶结点，此树从顶至底的结点都对称，因此返回True</li>
<li>当L和R中只有一个越过叶结点，此树不对称，因此返回False</li>
<li>当节点L的值≠节点R的值，此树不对称，因此返回False</li>
</ul>
</li>
<li>递推工作：
<ul>
<li>判断两节点 L.left和 R.right是否对称，即 <code>recur(L.left, R.right)</code></li>
<li>判断两节点 L.right和 R.left是否对称，即 <code>recur(L.right, R.left)</code></li>
</ul>
</li>
<li><strong>返回值：</strong> 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(L, R)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (L <span class="keyword">or</span> R):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (L <span class="keyword">and</span> R) <span class="keyword">or</span> L.val != R.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> recur(L.left, R.right) <span class="keyword">and</span> recur(L.right, R.left)</span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路：队列</p>
<ul>
<li>特例处理：如果root为空，返回True</li>
<li>初始化：队列，并顺序加入root的左右结点</li>
<li>循环判断：当队列为空时跳出
<ul>
<li>出队列：依次记为left和right</li>
<li>如果left和right都为空，说明穿过叶子节点，继续执行</li>
<li>如果left或right其中一个为空，说明不对称，返回False</li>
<li>如果left和right的值不相等，说明不对称，返回False</li>
<li>入队：（成对加入）
<ul>
<li>加入left的左节点和righ的右节点</li>
<li>加入left的右节点和right的左节</li>
</ul>
</li>
</ul>
</li>
<li>返回True</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root.left, root.right]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            left = queue.pop(<span class="number">0</span>)</span><br><span class="line">            right = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(left <span class="keyword">and</span> right) <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(left.left)</span><br><span class="line">            queue.append(right.right)</span><br><span class="line">            queue.append(left.right)</span><br><span class="line">            queue.append(right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="顺时针打印矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵"></a> 顺时针打印矩阵</h1>
<h2 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题29）：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制</p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="题解-28"><a class="markdownIt-Anchor" href="#题解-28"></a> 题解</h2>
<ul>
<li>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</a></li>
<li>剑指offer：
<ul>
<li>当我们遇到一个复杂问题的时候，可以用图形来帮助我们思考。由于是以外圈到内圈的顺序依次打印，我们可以把矩阵想象成若干个圈，可以用一个循环来打印矩阵，每一次打印矩阵中的一个圈。</li>
<li>分析循环结束的条件。假设这个矩阵的行数是rows，列数是columns。打印第一圈的左上角的坐标是(1,1)，第二圈的左上角的坐标是(2,2)，以此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。</li>
<li>对一个5 * 5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2)。我们发现5 &gt; 2 * 2。对于一个6 * 6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为(2,2)。我们发现6 &gt; 2 * 2依然成立。于是我们可以得出，让循环继续的条件是columns &gt; startX * 2并且 rows &gt; startX * 2。</li>
<li>考虑如何打印一圈的功能。我们可以把打印一圈分为4步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或一列。不过值得注意的是，最后一圈有可能退化成只有一行，只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要4步。</li>
<li>分析打印时每一步的前提条件。第一步总是需要的，因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始起始行号至少大2，同时终止列号大于起始列号。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>时间复杂度：O(MN）,M和N分别为矩阵的行列</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        l, r, t, b, res = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, len(matrix) - <span class="number">1</span>, []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[t][i]) <span class="comment"># left to right</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][r]) <span class="comment"># top to bottom</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[b][i]) <span class="comment"># right to left</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][l]) <span class="comment"># bottom to top</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="包含min函数的栈"><a class="markdownIt-Anchor" href="#包含min函数的栈"></a> 包含min函数的栈</h1>
<h2 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题30）：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：各函数的调用总次数不超过 20000 次</p>
</li>
</ul>
<h2 id="题解-29"><a class="markdownIt-Anchor" href="#题解-29"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，我们可以举例模拟压栈和弹出的几个数字，分析每次操作之后数据栈、辅助栈和最小值各是什么。让面试官更好地理解我们的思路。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</a></p>
</blockquote>
</li>
<li>
<p>思路：数据栈A压入数据，辅助栈B压入每次的最小元素（之前最小的元素和新压入栈的元素两者的较小值）</p>
<ul>
<li>eg：首先往空的数据栈A里压入数字3，显然现在3是最小值，我们也把这个最小值压入辅助栈B。接下来往数据栈A里压入数字4，由于4大于之前的最小值3，因此仍然往辅助栈B里压入3。第三步继续往数据栈A里压入数字2，由于数字2小于之前的最小值3，因此我们把最小值更新为2，并把2压入辅助栈B。同样压入数字1时，也要更新最小值，并把新的最小值1压入辅助栈B。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(1)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.B = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        y = self.A.pop()</span><br><span class="line">        <span class="keyword">if</span> y == self.B[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#栈的压入-弹出序列"></a> 栈的压入、弹出序列</h1>
<h2 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题31）：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列</li>
</ul>
</li>
</ul>
<h2 id="题解-30"><a class="markdownIt-Anchor" href="#题解-30"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：辅助栈</p>
<ul>
<li>面试时，需要确定一个序列和弹出序列的长度是否一致，序列中数字是否有重复。</li>
</ul>
</li>
<li>
<p>思路：判断一个序列是不是栈的弹出序列的规律。如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<ul>
<li>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(num) <span class="comment"># num 入栈</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> i &lt; len(popped)<span class="keyword">and</span> stack[<span class="number">-1</span>] == popped[i]: <span class="comment"># 循环判断与出栈</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树"><a class="markdownIt-Anchor" href="#从上到下打印二叉树"></a> 从上到下打印二叉树</h1>
<h2 id="题目-30"><a class="markdownIt-Anchor" href="#题目-30"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题32I）：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-31"><a class="markdownIt-Anchor" href="#题解-31"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>队列</li>
<li>Python 中使用 collections 中的双端队列 deque() ，其 popleft() 方法可达到 O(1)， 时间复杂度；列表 list 的 pop(0) 方法时间复杂度为 O(N) 。</li>
<li>BFS通常借助队列</li>
</ul>
</li>
<li>
<blockquote>
<p>剑指offer：</p>
<ul>
<li><strong>扩展</strong>：如何广度优先遍历一个有向图？这同样也可以基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度优先遍历二叉树</li>
<li><strong>举一反三</strong>：不管是广度优先遍历一个有向图还是一棵树，都要用到队列。第一步我们把起始起点（对树而言是根结点）放入队列。接下来每一次从队列的头部取出一个结点，遍历这个结点之后把它能到达的结点（对树而言是子结点）都依次放入队列。我们重复这个遍历过程，直到队列中的结点全部被遍历为止。</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都被打印出来为止。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树ii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树ii"></a> 从上到下打印二叉树II</h1>
<h2 id="题目-31"><a class="markdownIt-Anchor" href="#题目-31"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题32II）：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-32"><a class="markdownIt-Anchor" href="#题解-32"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>算法流程：</p>
<ul>
<li>特例处理：当前结点为空，则返回列表[]</li>
<li>初始化： 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；
<ul>
<li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li>
<li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；
<ul>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ul>
</li>
<li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li>
</ul>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="从上到下打印二叉树iii"><a class="markdownIt-Anchor" href="#从上到下打印二叉树iii"></a> 从上到下打印二叉树III</h1>
<h2 id="题目-32"><a class="markdownIt-Anchor" href="#题目-32"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题32III）：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：节点总数 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-33"><a class="markdownIt-Anchor" href="#题解-33"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p>思路：之型打印二叉树，奇数层从左到右打印，偶数层从右到左打印，因此可以在面试题32II的基础上，判断层数是否是偶数层，如果是的话，把当前结点加在tmp头部，否则，加在尾部。或者，可以将偶数层的tmp结果倒序。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(tmp[::<span class="number">-1</span>] <span class="keyword">if</span> len(res) % <span class="number">2</span> <span class="keyword">else</span> tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h1>
<h2 id="题目-33"><a class="markdownIt-Anchor" href="#题目-33"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题33）：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例1： </span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：数组长度 &lt;= 1000</p>
</li>
</ul>
<h2 id="题解-34"><a class="markdownIt-Anchor" href="#题解-34"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：</p>
<ul>
<li>后序遍历定义：<code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li>二叉搜索树定义： 左子树中所有节点的值 &lt;根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
</li>
<li>
<blockquote>
<ul>
<li>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p>
</li>
<li>
<p>剑指offer：</p>
<ul>
<li><strong>相关题目</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和本题的后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根节点的值</li>
<li><strong>举一反三</strong>：如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>思路：递归分治：根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p>
<ul>
<li>递归解析：
<ul>
<li><strong>终止条件：</strong> 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i≥j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，说明此子树结点数量≤1，无需判别正确性，因此直接返回true。</li>
<li>递推工作：
<ul>
<li>划分左右子树：遍历后序遍历[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时可划分出左子树区间[i,m-1]，右子树区间[m,j-1]，根节点索引j。</li>
<li><strong>判断是否为二叉搜索树：</strong>
<ul>
<li>左子树区间[i,m-1]内的所有结点都应小于postorder[j]。而上一步划分左右子树的步骤，已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间[m,j-1]内的所有结点都应大于postorder[j]。实现方式为遍历，当遇到小于等于postorder[j]的结点则跳出，否则可通过p=j判断是否为二叉搜索树。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> &amp;&amp;连接
<ul>
<li>p = j：判断此树是否正确</li>
<li>recur(i, m-1)：判断此树的左子树是否正确</li>
<li>recur(m, j - 1)：判断此树的右子树是否正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N^2)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            m = p</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>思路2：单调辅助栈</p>
<ul>
<li>借助一个单调栈 stack存储值递增的节点；</li>
<li>每当遇到值递减的节点 r_i，则通过出栈来更新节点 r_i 的父节点 root ；</li>
<li>每轮判断 r_i和 root的值关系：
<ul>
<li>若 r_i &gt; root则说明不满足二叉搜索树定义，直接返回 false 。</li>
<li>若 r_i &lt; root则说明满足二叉搜索树定义，则继续遍历。</li>
</ul>
</li>
<li>算法流程：
<ul>
<li><strong>初始化：</strong> 单调栈 stack，父节点值 root = +∞ （初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；</li>
<li>倒序遍历 postorder：记每个节点为 r_i；
<ul>
<li><strong>判断：</strong> 若 r_i&gt;root，说明此后序遍历序列不满足二叉搜索树定义，直接返回 false；</li>
<li>更新父节点root，当栈不为空，且r_i &lt; stack.pop()时，循环执行出栈，并将出栈结点赋给root</li>
<li>入栈：将当前结点r_i入栈</li>
</ul>
</li>
<li>遍历完成，则说明满足二叉搜索树定义，返回true</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, root = [], float(<span class="string">"inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span>(stack <span class="keyword">and</span> postorder[i] &lt; stack[<span class="number">-1</span>]):</span><br><span class="line">                root = stack.pop()</span><br><span class="line">            stack.append(postorder[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h1>
<h2 id="题目-34"><a class="markdownIt-Anchor" href="#题目-34"></a> 题目</h2>
<ul>
<li>难度：中等</li>
<li>题目（leetcode-面试题34）：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</li>
</ul>
<h2 id="题解-35"><a class="markdownIt-Anchor" href="#题解-35"></a> 题解</h2>
<blockquote>
<ul>
<li>剑指offer：当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点的值得和刚好等于输入的整数，则当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父节点。因此我们在函数退出之前要再路径上删除当前结点并减去当前结点的值，以确保返回父节点时路径刚好是从根节点到父节点的路径。</li>
<li>参考：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：先序遍历+路径记录</p>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>pathSum(root, sum)</code> 函数：</strong>
<ul>
<li><strong>初始化：</strong> 结果列表 <code>res</code> ，路径列表 <code>path</code> 。</li>
<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>
</ul>
</li>
<li><strong><code>recur(root, tar) 函数：</code></strong>
<ul>
<li><strong>递推参数：</strong> 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</li>
<li><strong>终止条件：</strong> 若节点 <code>root</code> 为空，则直接返回。</li>
<li><strong>递推工作</strong>
<ul>
<li>路径更新： 将当前节点值 <code>root.val</code> 加入路径 <code>path</code> ；</li>
<li>目标值更新： <code>tar = tar - root.val</code>（即目标值 <code>tar</code> 从 <code>sum</code> 减至 00 ）；</li>
<li>路径记录： 当 ① <code>root</code> 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 <code>path</code> 加入 <code>res</code> 。</li>
<li>先序遍历： 递归左 / 右子节点。</li>
<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop()</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>值得注意的是</strong>，记录路径时若直接执行 <code>res.append(path)</code> ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。正确做法：<code>res.append(list(path))</code> ，相当于复制了一个 path 并加入到 res 。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res, path = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, tar)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">            recur(root.left, tar)</span><br><span class="line">            recur(root.right, tar)</span><br><span class="line">            path.pop()</span><br><span class="line">        recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="复杂链表的复制"><a class="markdownIt-Anchor" href="#复杂链表的复制"></a> 复杂链表的复制</h1>
<h2 id="题目-35"><a class="markdownIt-Anchor" href="#题目-35"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题35：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
</li>
</ul>
<h2 id="题解-36"><a class="markdownIt-Anchor" href="#题解-36"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：在这里，复制的意思是指 <strong>深拷贝</strong>（Deep Copy），类似我们常用的“复制粘贴”，事实上，与此对应的还有 浅拷贝，它们的区别是：</p>
<ul>
<li><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</strong>。</li>
<li><strong>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</strong>。</li>
</ul>
</li>
<li>
<p>思路：这里考虑深度优先搜索和优化迭代两种方法</p>
<ul>
<li>
<p>深度优先搜索（DFS）</p>
<ul>
<li>
<p>从头结点head开始拷贝</p>
</li>
<li>
<p>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</p>
</li>
<li>
<p>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</p>
</li>
<li>
<p>使用递归拷贝所有的 <code>next</code> 结点，再递归拷贝所有的 <code>random</code> 结点。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited  = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line"></span><br><span class="line">            <span class="comment">#创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>优化迭代</p>
<ul>
<li>
<p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个链表结点的旁边拷贝，比如 A-&gt;B-&gt;C 变成 A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，然后将拷贝的结点分离出来变成 A-&gt;B-&gt;C和A’-&gt;B’-&gt;C’，最后返回 A’-&gt;B’-&gt;C’。</p>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            new_node = Node(cur.val,<span class="literal">None</span>,<span class="literal">None</span>)   <span class="comment"># 克隆新结点</span></span><br><span class="line">            new_node.next = cur.next</span><br><span class="line">            cur.next = new_node   <span class="comment"># 克隆新结点在cur 后面</span></span><br><span class="line">            cur = new_node.next   <span class="comment"># 移动到下一个要克隆的点</span></span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 链接random</span></span><br><span class="line">            cur.next.random = cur.random.next <span class="keyword">if</span> cur.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        cur_old_list = head <span class="comment"># 将两个链表分开</span></span><br><span class="line">        cur_new_list = head.next</span><br><span class="line">        new_head = head.next</span><br><span class="line">        <span class="keyword">while</span> cur_old_list:</span><br><span class="line">            cur_old_list.next = cur_old_list.next.next</span><br><span class="line">            cur_new_list.next = cur_new_list.next.next <span class="keyword">if</span> cur_new_list.next <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            cur_old_list = cur_old_list.next</span><br><span class="line">            cur_new_list = cur_new_list.next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#二叉搜索树与双向链表"></a> 二叉搜索树与双向链表</h1>
<h2 id="题目-36"><a class="markdownIt-Anchor" href="#题目-36"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题36）：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
</li>
</ul>
<h2 id="题解-37"><a class="markdownIt-Anchor" href="#题解-37"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：中序遍历</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</a></p>
</blockquote>
</li>
<li>
<p>思想：</p>
<ul>
<li>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</li>
<li>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：
<ul>
<li><strong>排序链表：</strong> 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点；</li>
<li><strong>双向链表</strong>：在构建相邻节点（设前驱节点pre，当前结点cur）关系时，应该满足<code>pre.right = cur</code>，<code>cur.left = pre</code></li>
<li><strong>循环链表</strong>： 设链表头节点 head 和尾节点 tail，则应构建 <code>head.left = tail</code>和 <code>tail.right = head。</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>算法流程：</p>
<ul>
<li><strong><code>dfs(cur):</code></strong> 递归法中序遍历；
<ul>
<li><strong>终止条件：</strong> 当节点 cur为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 <code>dfs(cur.left)</code> ；</li>
<li><strong>构建链表：</strong>
<ul>
<li><strong>当 pre为空时：</strong> 代表正在访问链表头节点，记为 head 。</li>
<li><strong>当 pre 不为空时</strong>： 修改双向节点引用，即 pre.right = cur， cur.left = pre。</li>
<li><strong>保存cur</strong>：更新pre = cur，即节点cur是后继节点的pre</li>
</ul>
</li>
<li>递归右子树，即<code>dfs(cur.left)</code></li>
</ul>
</li>
<li><strong><code>treeToDoublyList(root)：</code></strong>
<ul>
<li><strong>特例处理：</strong> 若节点 root 为空，则直接返回；</li>
<li><strong>初始化</strong>： 空节点 pre ；</li>
<li><strong>转化为双向链表</strong>： 调用 <code>dfs(root)</code> ；</li>
<li>构建循环链表： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head和 pre 的双向节点引用即可。</li>
<li>返回值： 返回链表的头节点 head 即可。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N)</p>
</li>
<li>
<p>空间复杂度：O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left) <span class="comment"># 递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> self.pre: <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 记录头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存 cur</span></span><br><span class="line">            dfs(cur.right) <span class="comment"># 递归右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 牛客网解答</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree.left <span class="keyword">and</span> <span class="keyword">not</span> pRootOfTree.right:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        <span class="comment"># 处理左子树</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        left=pRootOfTree.left</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 连接根与左子树最大结点</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">while</span>(left.right):</span><br><span class="line">                left=left.right</span><br><span class="line">            pRootOfTree.left,left.right=left,pRootOfTree</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 处理右子树</span></span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        right=pRootOfTree.right</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 连接根与右子树最小结点</span></span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">while</span>(right.left):</span><br><span class="line">                right=right.left</span><br><span class="line">            pRootOfTree.right,right.left=right,pRootOfTree</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree.left):</span><br><span class="line">            pRootOfTree=pRootOfTree.left</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="序列化二叉树"><a class="markdownIt-Anchor" href="#序列化二叉树"></a> 序列化二叉树</h1>
<h2 id="题目-37"><a class="markdownIt-Anchor" href="#题目-37"></a> 题目</h2>
<ul>
<li>
<p>难度：困难</p>
</li>
<li>
<p>题目（leetcode-面试题37）：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-38"><a class="markdownIt-Anchor" href="#题解-38"></a> 题解</h2>
<blockquote>
<ul>
<li>参考：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/</a></li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>Tips</strong>：层序遍历 + BFS</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>序列化：借助队列，对二叉树做层序遍历，并将越过叶节点的 null也打印出来。
<ul>
<li>特例处理：若root为空，直接返回空列表</li>
<li>初始化：队列queue（包含根节点root）；序列化列表res</li>
<li>层序遍历：当queue为空时跳出：
<ul>
<li>节点出队，记为node</li>
<li>若node不为空，① 打印字符串 node.val，② 将左、右子节点加入 queue ；</li>
<li>否则（若 node为空）：打印字符串 <code>&quot;null&quot;</code></li>
</ul>
</li>
<li><strong>返回值：</strong> 拼接列表（用 <code>','</code> 隔开，首尾添加中括号）。</li>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
</li>
<li>反序列化：利用队列按层构建二叉树，借助一个指针 i指向节点 node的左、右子节点，每构建一个 node 的左、右子节点，指针 i就向右移动 1 位。
<ul>
<li>特例处理：若data为空，直接返回null</li>
<li>初始化： 序列化列表 vals（先去掉首尾中括号，再用逗号隔开），指针 i = 1，根节点 root（值为 vals[0] ），队列 queue（包含 root）；</li>
<li>按层构建：当queue为空时跳出：
<ul>
<li>节点出队，记为node</li>
<li>构建 node 的左子节点：node.left的值为 vals[i]，并将 node.left入队；</li>
<li>执行 i+=1 ；</li>
<li>构建 node 的右子节点：node.right的值为 vals[i] ，并将 node.right入队；</li>
<li>执行 i+=1 ；</li>
</ul>
</li>
<li>返回值： 返回根节点 root 即可</li>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">"null"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="string">','</span>.join(res) + <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>]))</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(int(vals[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="字符串的排列"><a class="markdownIt-Anchor" href="#字符串的排列"></a> 字符串的排列</h1>
<h2 id="题目-38"><a class="markdownIt-Anchor" href="#题目-38"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目（leetcode-面试题38）：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= s 的长度 &lt;= 8</p>
</li>
</ul>
<h2 id="题解-39"><a class="markdownIt-Anchor" href="#题解-39"></a> 题解</h2>
<ul>
<li>
<p>思路：</p>
<ul>
<li>求所有可能出现在第一个位置的字符,即把第一个字符和后面所有的字符进行交换</li>
<li>固定第一个字符，求后面所有字符的排列，这时候，可以把后面的所有字符分为两部分，后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。</li>
</ul>
</li>
<li>
<p>时间复杂度：O(N!)</p>
</li>
<li>
<p>空间复杂度：O(N^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [s]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ch = s[i] <span class="comment">#取出s中每一个字符</span></span><br><span class="line">                dic = s[:i] + s[i + <span class="number">1</span> :]</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> self.permutation(dic):</span><br><span class="line">                    res.append(ch + x) <span class="comment">#将ch 和子问题的解依次组合</span></span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>牛客网</p>
<ul>
<li>输入一个字符串,<strong>按字典序打印</strong>出该字符串中字符的所有排列。</li>
<li>输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = len(ss)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [ss]</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ch = ss[i]</span><br><span class="line">            tmp = ss[:i] + ss[i + <span class="number">1</span> :]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self.Permutation(tmp):</span><br><span class="line">                res.append(ch + x)</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(res)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#数组中出现次数超过一半的数字"></a> 数组中出现次数超过一半的数字</h1>
<h2 id="题目-39"><a class="markdownIt-Anchor" href="#题目-39"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题39）：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：1 &lt;= 数组长度 &lt;= 50000</p>
</li>
</ul>
<h2 id="题解-40"><a class="markdownIt-Anchor" href="#题解-40"></a> 题解</h2>
<ul>
<li>
<p><strong>Tips</strong>：面试时，要注意以下问题：</p>
<ul>
<li>是否可以修改数组？</li>
<li>特例考虑，数组为空，或数组中不存在元素出现的次数超过数组长度一半</li>
</ul>
</li>
<li>
<p>思路：有三种思路</p>
<ul>
<li>第一种思路，对数组排序，数组n/2位置就是所求的数字。
<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
<li>第二种思路，哈希表，遍历一遍数组，记录每个元素出现的次数，返回次数超过数组长度一半的数字
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li>第三种思路，<strong>投票法</strong>，数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减一。如果次数为零，我们需要保存下一个数字，并把次数设置为1。由于我们要找的数字出现的次数比其他所有数字出现的次数和要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#投票法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        vote = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote == <span class="number">0</span>:</span><br><span class="line">                x = num</span><br><span class="line">            vote += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#哈希表</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                dic[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dic[num] &gt; len(numbers) // <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="最小的k个数"><a class="markdownIt-Anchor" href="#最小的k个数"></a> 最小的k个数</h1>
<h2 id="题目-40"><a class="markdownIt-Anchor" href="#题目-40"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目（leetcode-面试题40）：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>限制：</p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
</li>
</ul>
<h2 id="题解排序"><a class="markdownIt-Anchor" href="#题解排序"></a> 题解（排序）</h2>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/">https://lesylin.com/2020/06/02/%E5%89%91%E6%8C%87offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2020/06/13/%E5%89%91%E6%8C%87offer1/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>剑指offer1</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>