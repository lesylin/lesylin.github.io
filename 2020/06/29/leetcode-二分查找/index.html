<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>leetcode-二分查找 | </title><meta name="description" content="leetcode-二分查找"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="leetcode-二分查找"><meta name="twitter:description" content="leetcode-二分查找"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="leetcode-二分查找"><meta property="og:url" content="https://lesylin.com/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><meta property="og:site_name" content=""><meta property="og:description" content="leetcode-二分查找"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><link rel="prev" title="leetcode-分治" href="https://lesylin.com/2020/07/03/leetcode-%E5%88%86%E6%B2%BB/"><link rel="next" title="leetcode-贪心" href="https://lesylin.com/2020/06/27/leetcode-%E8%B4%AA%E5%BF%83/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二分查找"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 二分查找</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#原理"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#局限性"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text"> 局限性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二分查找依赖数组结构"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text"> 二分查找依赖数组结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二分查找针对的是有序数据"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text"> 二分查找针对的是有序数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据量太小不适合二分查找"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text"> 数据量太小不适合二分查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据量太大不适合二分查找"><span class="toc_mobile_items-number">2.2.4.</span> <span class="toc_mobile_items-text"> 数据量太大不适合二分查找</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码模板"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text"> 代码模板</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中间值计算"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text"> 中间值计算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#未成功查找的返回值"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text"> 未成功查找的返回值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#循环"><span class="toc_mobile_items-number">2.3.3.</span> <span class="toc_mobile_items-text"> 循环</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#递归"><span class="toc_mobile_items-number">2.3.4.</span> <span class="toc_mobile_items-text"> 递归</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#变形"><span class="toc_mobile_items-number">2.3.5.</span> <span class="toc_mobile_items-text"> 变形</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#查找第一个等于给定值的元素"><span class="toc_mobile_items-number">2.3.5.1.</span> <span class="toc_mobile_items-text"> 查找第一个等于给定值的元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#查到第一个大于给定值的元素"><span class="toc_mobile_items-number">2.3.5.2.</span> <span class="toc_mobile_items-text"> 查到第一个大于给定值的元素</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#69-x的平方根"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 69-x的平方根</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#744-寻找比目标字母大的最小字母"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 744-寻找比目标字母大的最小字母</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#540-有序数组中的单一元素"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 540-有序数组中的单一元素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#278-第一个错误的版本"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 278-第一个错误的版本</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#153-寻找旋转排序数组中的最小值"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 153. 寻找旋转排序数组中的最小值</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-5"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-5"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 34-在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-6"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-6"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二分查找"><span class="toc-number">2.</span> <span class="toc-text"> 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">2.1.</span> <span class="toc-text"> 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局限性"><span class="toc-number">2.2.</span> <span class="toc-text"> 局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二分查找依赖数组结构"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 二分查找依赖数组结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二分查找针对的是有序数据"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 二分查找针对的是有序数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据量太小不适合二分查找"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 数据量太小不适合二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据量太大不适合二分查找"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 数据量太大不适合二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码模板"><span class="toc-number">2.3.</span> <span class="toc-text"> 代码模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中间值计算"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 中间值计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未成功查找的返回值"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 未成功查找的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变形"><span class="toc-number">2.3.5.</span> <span class="toc-text"> 变形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查找第一个等于给定值的元素"><span class="toc-number">2.3.5.1.</span> <span class="toc-text"> 查找第一个等于给定值的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查到第一个大于给定值的元素"><span class="toc-number">2.3.5.2.</span> <span class="toc-text"> 查到第一个大于给定值的元素</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-x的平方根"><span class="toc-number">3.</span> <span class="toc-text"> 69-x的平方根</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-number">3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#744-寻找比目标字母大的最小字母"><span class="toc-number">4.</span> <span class="toc-text"> 744-寻找比目标字母大的最小字母</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-2"><span class="toc-number">4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-number">4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#540-有序数组中的单一元素"><span class="toc-number">5.</span> <span class="toc-text"> 540-有序数组中的单一元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-3"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-number">5.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#278-第一个错误的版本"><span class="toc-number">6.</span> <span class="toc-text"> 278-第一个错误的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-4"><span class="toc-number">6.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-number">6.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#153-寻找旋转排序数组中的最小值"><span class="toc-number">7.</span> <span class="toc-text"> 153. 寻找旋转排序数组中的最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-5"><span class="toc-number">7.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-number">7.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="toc-number">8.</span> <span class="toc-text"> 34-在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-6"><span class="toc-number">8.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-number">8.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">leetcode-二分查找</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-06-29<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-02</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">5.8k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 22分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p> 回顾一下二分查找算法，并完成leetcode二分查找的经典题。</p>
<ul>
<li>69-x的平方根</li>
<li>744-寻找比目标字母大的最小字母</li>
<li>540-有序数组中的单一元素</li>
<li>278-第一个错误的版本</li>
<li>153-寻找旋转排序数组中的最小值</li>
<li>34-在排序数组中查找元素的第一个和最后一个位置</li>
</ul>
<h1 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h1>
<blockquote>
<p>参考：</p>
<p><a href="https://juejin.im/post/5d510f76f265da039a287a30%EF%BC%88%E4%B8%8B%E8%BF%B0%E4%BA%8C%E5%88%86%E5%86%85%E5%AE%B9%E5%87%BA%E5%A4%84%EF%BC%89" target="_blank" rel="noopener">https://juejin.im/post/5d510f76f265da039a287a30（下述二分内容出处）</a></p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/%EF%BC%88leetcode%E5%A4%A7%E4%BD%AC%E5%AF%B9%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/（leetcode大佬对二分查找的详细分析）</a></p>
</blockquote>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p> 二分查找（Binary Search）算法，也叫折半查找算法。二分查找的思想非常简单，有点类似分治的思想。二分查找针对的是一个<strong>有序的数据集合</strong>，每次都通过跟<strong>区间的中间元素</strong>对比，将待查找的<strong>区间缩小</strong>为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p>
<ul>
<li>时间复杂度：O(logn)</li>
<li>比很多O(1)的速度都要快，因为O(1)可能标示一个非常大的数值，如O(1000)。
<ul>
<li>有序数据：[1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59]，查找37</li>
<li>二分查找需要3步</li>
<li>顺序遍历需要11步。</li>
</ul>
</li>
</ul>
<h2 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h2>
<h3 id="二分查找依赖数组结构"><a class="markdownIt-Anchor" href="#二分查找依赖数组结构"></a> 二分查找依赖数组结构</h3>
<p> 二分查找需要利用下标随机访问元素，如果我们想使用链表等其他数据结构则无法实现二分查找。</p>
<h3 id="二分查找针对的是有序数据"><a class="markdownIt-Anchor" href="#二分查找针对的是有序数据"></a> 二分查找针对的是有序数据</h3>
<p> 二分查找需要的数据必须是有序的。如果数据没有序，我们需要先排序，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
<p> 但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p>
<p> 所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p>
<h3 id="数据量太小不适合二分查找"><a class="markdownIt-Anchor" href="#数据量太小不适合二分查找"></a> 数据量太小不适合二分查找</h3>
<p> 如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多，只有数据量比较大的时候，二分查找的优势才会比较明显。</p>
<h3 id="数据量太大不适合二分查找"><a class="markdownIt-Anchor" href="#数据量太大不适合二分查找"></a> 数据量太大不适合二分查找</h3>
<p> 二分查找底层依赖的是数组，数组需要的是一段连续的存储空间，所以我们的数据比较大时，比如1GB，这时候可能不太适合使用二分查找，因为我们的内存都是离散的，可能电脑没有这么多的内存。</p>
<h2 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h2>
<h3 id="中间值计算"><a class="markdownIt-Anchor" href="#中间值计算"></a> 中间值计算</h3>
<p> 二分查找的代码实现起来比较简单，需要说明的地方是中间值的计算，中间值得计算有两种方式，</p>
<ul>
<li>
<p>方式一：<code>int mid = (low +high) &gt;&gt; 1</code></p>
</li>
<li>
<p><strong>方式二</strong>：<code>int mid = low + ((high - low) &gt;&gt; 1)</code>。</p>
</li>
</ul>
<p> 方式一存在溢出的风险，当<code>low</code>和<code>high</code>比较大时，有可能会导致<code>mid</code>的值错误，从而使程序出错。方式二则可以保证生成的<code>mid</code>一定大于<code>low</code>，小于<code>high</code>。</p>
<h3 id="未成功查找的返回值"><a class="markdownIt-Anchor" href="#未成功查找的返回值"></a> 未成功查找的返回值</h3>
<p> 循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 arr 中的正确位置</li>
</ul>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:  <span class="comment">#循环条件</span></span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)  <span class="comment">#获取中间位置，数字的索引（序列前提是有序的）</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:  <span class="comment">#如果查询数字刚好为中间值，返回该值得索引</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target: <span class="comment">#如果查询数字比中间数字大，那就去二分后的右边找</span></span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment">#如果查询数字比中间数字小，那就去二分后的左边找</span></span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>                   <span class="comment">#如果循环结束，左边大于了右边，代表没有找到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">11</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &lt; target:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">11</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="变形"><a class="markdownIt-Anchor" href="#变形"></a> 变形</h3>
<h4 id="查找第一个等于给定值的元素"><a class="markdownIt-Anchor" href="#查找第一个等于给定值的元素"></a> 查找第一个等于给定值的元素</h4>
<p> 比如我们给定数组<code>1,2,3,4,4,4,5,6,7,7,8,9</code>，我们需要查找第一个等于<code>4</code>的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &lt; target:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#判断当前是第一个元素或者前一个元素不等于要查找的值，则返回下标，如果前一个元素也等于要查找的值，则继续往前查找。</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] != target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'输入要查找的第一个数：'</span>))</span><br><span class="line">    res = binarySearch(arr,<span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>其他的都差不多，主要的区别是在<code>nums[mid]==value</code>时候，因为我们要查找的是第一个等于给定值的元素，所以我们需要判断<code>mid</code>的前一个元素等不等于给定值，如果前一个元素也等于给定值，则需要继续往左边查找。</li>
<li><strong>查找最后一个等于给定值的元素</strong>，判断<code>mid == len(arr) - 1 or arr[mid + 1] != target</code>是否满足，满足返回<code>mid</code>，否则 <code>l = mid + 1</code></li>
</ul>
<h4 id="查到第一个大于给定值的元素"><a class="markdownIt-Anchor" href="#查到第一个大于给定值的元素"></a> 查到第一个大于给定值的元素</h4>
<p> 比如我们给定数组<code>1,2,3,4,4,4,5,6,7,7,8,9,15,26,34,45</code>，我们随便输入一个值，这个值可以是数组里面的值，也不可不在数组里面，查找出第一个比给定值大的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr, l, r, target)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            <span class="comment">#判断当前是第一个元素或者前一个元素不等于要查找的值，则返回下标，如果前一个元素也等于要查找的值，则继续往前查找。</span></span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arr[mid - <span class="number">1</span>] &lt;= target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>        </span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">26</span>,<span class="number">34</span>,<span class="number">45</span>]</span><br><span class="line">print(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    target = int(input(<span class="string">'查找第一个大于输入的数：'</span>))</span><br><span class="line">    res = binarySearch(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, target)</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'未找到！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'找到！'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>我们需要判断当<code>nums[mid] &gt; value</code>时，<code>nums[mid-1]</code>是否小于或者等于给定值，如果是则<code>mid</code>就是第一个大于给定值的元素，如果不是这继续往左边查找。</li>
<li>查找最后一个大于给定值的元素，直接返回数组最后一个元素就好了。</li>
</ul>
<h1 id="69-x的平方根"><a class="markdownIt-Anchor" href="#69-x的平方根"></a> 69-x的平方根</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>
<p>思路：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>平方根的整数部分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>满足：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k^2 ≤ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>值。因此我们可以对 k 进行二分查找，从而得到答案。</p>
<ul>
<li>下界：l == 0</li>
<li>上界：r == x</li>
</ul>
</li>
<li>
<p>本题三种解法的时间复杂度：袖珍计算器算法 &lt; 牛顿法 &lt; 二分查找法</p>
</li>
<li>
<blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/%EF%BC%88%E7%89%9B%E9%A1%BF%E6%B3%95%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/（牛顿法）</a></li>
<li><a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/%EF%BC%88%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E8%A2%96%E7%8F%8D%E8%AE%A1%E7%AE%97%E5%99%A8%E7%AE%97%E6%B3%95%E3%80%81%E7%89%9B%E9%A1%BF%E6%B3%95%EF%BC%89" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/（官方题解：二分查找、袖珍计算器算法、牛顿法）</a></li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span>  <span class="comment">#下界</span></span><br><span class="line">        r = x  <span class="comment">#上界</span></span><br><span class="line">        ans = <span class="number">-1</span>  <span class="comment">#返回结果初始化为-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:   <span class="comment">#x的平方根的整数部分ans满足mid * mid &lt;= x的最大mid值</span></span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span>      <span class="comment">#满足mid * mid &lt;= x的最大mid值，右移寻找最大mid值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span>       </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：O(logn)，即为二分查找需要的次数。</p>
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p><strong>思路</strong>：</p>
<ul>
<li>首先随便猜一个近似值 x，然后不断令 x 等于 x和 a/x 的平均数，迭代个六七次后 x 的值就已经相当精确了。</li>
<li>每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定，此时的结果已经足够我们得到答案了。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 ϵ，其中ϵ 一般可以取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
</li>
<li>
<p><strong>原理</strong>：不断用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的切线来逼近方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2-a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的根。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>a</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">a</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>实际上就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2-a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的一个正实根，这个函数的导数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>。也就是说，函数上任意一点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>处的切线斜率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>。那么，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">x-f(x)/2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mord mathdefault">x</span></span></span></span>就是一个比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>更接近的近似值。代入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f(x)=x^2-a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-(x^2-a)/(2x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(x-a/x)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。同样的方法可以用在其它的近似值计算中。</p>
</li>
<li>
<p><strong>Q</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x-f(x)/(2x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>怎么得到的？</p>
<ul>
<li>在评论区看到一个解答：设切线与x轴的交点横座标是a, 那么 斜率*(x-a) = f(x) - 0，代入斜率=2x，就得到a的表达式了。</li>
<li><strong>官方题解比较详细，建议查看</strong>：<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/</a></li>
</ul>
</li>
</ul>
<p><img alt="牛顿法" data-src="/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E7%89%9B%E9%A1%BF%E6%B3%95.jpg" class="lazyload"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#牛顿法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        a, x0 = float(x), float(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            xi = <span class="number">0.5</span> * (x0 + a / x0)</span><br><span class="line">            <span class="keyword">if</span> abs(x0 - xi) &lt; <span class="number">1e-7</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x0 = xi</span><br><span class="line">        <span class="keyword">return</span> int(x0)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)，此方法是二次收敛的，相较于二分查找更快。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="744-寻找比目标字母大的最小字母"><a class="markdownIt-Anchor" href="#744-寻找比目标字母大的最小字母"></a> 744-寻找比目标字母大的最小字母</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：给你一个<strong>排序后</strong>的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<ul>
<li>如果目标字母 <code>target = 'z'</code> 并且字符列表为 <code>letters = ['a', 'b']</code>，则答案返回 <code>'a'</code></li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;a&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;c&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;d&quot;</span><br><span class="line">输出: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;g&quot;</span><br><span class="line">输出: &quot;j&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;j&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;k&quot;</span><br><span class="line">输出: &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>letters</code>长度范围在<code>[2, 10000]</code>区间内。</li>
<li><code>letters</code> 仅由小写字母组成，最少包含两个不同的字母。</li>
<li>目标字母<code>target</code> 是一个小写字母。</li>
</ul>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>思路：类似查找第一个大于给定值的元素，不同之处是：
<ol>
<li>返回的不是下标，是元素</li>
<li>不需要判断所求元素的位置，换句话说，假设数组中重复字母为所求，我们不需要关注重复数组的第几个元素是我们需要的，因为都满足题意，直接返回就行了，所以不需要判断是否满足<code>mid == 0 or letters[mid - 1] != target</code>。</li>
<li>若查找不到，返回的不是-1，而是数组第一个值，即letters[0]</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span><span class="params">(self, letters, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type letters: List[str]</span></span><br><span class="line"><span class="string">        :type target: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(letters) - <span class="number">1</span></span><br><span class="line">        ans = letters[<span class="number">0</span>]  <span class="comment">#初始化返回结果ans = letters[0]</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> letters[mid] &gt; target:  <span class="comment">#若letters[mid] &gt; target，符合题目要求</span></span><br><span class="line">                ans = letters[mid]     <span class="comment">#将letters[mid]复制给ans</span></span><br><span class="line">                r = mid - <span class="number">1</span>            <span class="comment">#查找满足letters[mid] &gt; target的最小值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="540-有序数组中的单一元素"><a class="markdownIt-Anchor" href="#540-有序数组中的单一元素"></a> 540-有序数组中的单一元素</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个只包含整数的<strong>有序数组</strong>，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：您的方案应该在 <strong>O(log n)时间复杂度和 O(1)空间复杂度</strong>中运行。</p>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<ul>
<li>有序数组 + 时间复杂度O(logn) +空间复杂度O(1)，就要联想到二分查找~</li>
<li>分析：
<ul>
<li>每个元素都会出现两次，唯有一个数只会出现一次。因此，数组的<strong>长度是奇数</strong>，单个的数字只会出现在<strong>下标为偶数</strong>的位置。</li>
<li>因此可以延伸出以下两种思路：
<ol>
<li><strong>满足题意下，数组长度是奇数即存在单个数字</strong>。根据数组的长度去判断每次查找的区间：计算mid，判断nums[mid]前面或者后面是否有重复的数字，假设nums[mid]前面的数字与nums[mid]相等，看nums[0:mid-2]和nums[mid+1:]两个区间的长度，下一次移动的方向就往区间长度是奇数的方向移动。如果nums[mid]前面和后面的数字都与nums[mid]不等，说明nums[mid]即为所求。直到l和r指向同一个数，那么这个数即为所求。</li>
<li><strong>满足题意下，单个出现数字的下标是偶数</strong>。对偶数索引做二分查找，计算mid，保证mid每次都是偶数，判断nums[mid]和后一个数是否相等，如果相等，nums[mid]就不是单一元素，且单个元素在nums[mid]之后；如果不相等，单个元素则可能就说nums[mid]或在nums[mid]之前。当l==r，搜索空间剩一个元素，那即为所求。</li>
</ol>
</li>
</ul>
</li>
<li>个人认为<strong>思路1</strong>在面试时候会<strong>更好解释</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid - <span class="number">1</span>]:  <span class="comment">#判断nums[mid]与前一个数是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (mid - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#判断mid左侧区间长度</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == nums[mid + <span class="number">1</span>]:  <span class="comment">#判断nums[mid]与后一个数是否相等</span></span><br><span class="line">                <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#判断mid左侧区间长度</span></span><br><span class="line">                    l = mid + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#思路2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span>:  <span class="comment">#保证mid始终是偶数</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid + <span class="number">1</span>]:  <span class="comment">#如果nums[mid]==nums[mid+1]，单个数在nums[mid]右侧</span></span><br><span class="line">                l = mid + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid   <span class="comment">#否则，单个数是nums[mid]或nums[mid]左侧</span></span><br><span class="line">        <span class="keyword">return</span> nums[l]    <span class="comment">#l == r时找到</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log(n/2)) = O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="278-第一个错误的版本"><a class="markdownIt-Anchor" href="#278-第一个错误的版本"></a> 278-第一个错误的版本</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：简单</p>
</li>
<li>
<p>题目：你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>
<p>分析：版本号<code>n</code>取值范围<code>[1,2,...,n]</code>，找到第一个出错的版本。第一个出错版本的特点是，其前一个版本为<code>false</code>，自身显示为<code>true</code>。</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>计算<code>mid</code></li>
<li>判断<code>mid</code>是否为<code>true</code>，如果是<code>true</code>，判断<code>mid-1</code>是否为<code>false</code>，如果是<code>false</code>，返回<code>mid</code>，如果<code>mid-1</code>是<code>true</code>，说明第一个错误版本在<code>mid</code>左侧。</li>
<li>如果<code>mid</code>是<code>false</code>，判断<code>mid+1</code>是否为<code>true</code>，如果是<code>true</code>，返回<code>mid+1</code>，如果<code>mid + 1</code>是<code>false</code>，说明第一个错误版本在<code>mid</code>右侧。</li>
</ul>
</li>
<li>
<blockquote>
<p>语法知识点：Python中<code>is</code>和<code>==</code>的区别</p>
<ul>
<li><a href="https://juejin.im/entry/5a3b62446fb9a0451f311b5c" target="_blank" rel="noopener">https://juejin.im/entry/5a3b62446fb9a0451f311b5c</a></li>
<li>在ython中一切都是对象</li>
<li>Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。对象之间比较是否相等可以用==，也可以用is。</li>
<li>is和==都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。(is是内存地址，==是值)
<ul>
<li><strong>is比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</strong></li>
<li><strong>==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。</strong></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">1</span></span><br><span class="line">        r = n</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> isBadVersion(mid - <span class="number">1</span>) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> isBadVersion(mid + <span class="number">1</span>) <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153. 寻找旋转排序数组中的最小值</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：假设按照<strong>升序排序</strong>的数组在<strong>预先未知的某个点</strong>上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。你可以假设数组中不存在重复元素。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>分析：升序排序数组，旋转，从旋转点可以将数组切分为左右两部分，左右部分依旧是升序。因此，可以转化为寻找旋转点，旋转点下一个数就是最小值。
<ul>
<li><strong>旋转点特点</strong>：
<ul>
<li>旋转点左侧元素 &gt; 数组第一个元素</li>
<li>旋转点右侧元素 &lt;数组第一个元素</li>
</ul>
</li>
<li><strong>两种情况</strong>：
<ul>
<li>最小值在数组中：数组的第一个元素会大于数组的最后一个元素</li>
<li>最小值在数组头：数组的第一个元素会小于数组的最后一个元素</li>
</ul>
</li>
<li><strong>区间判断</strong>：
<ul>
<li>计算mid</li>
<li>如果nums[mid] &gt; 数组第一个元素，说明最小值在mid右侧</li>
<li>如果nums[mid] &lt; 数组第一个元素，说明最小值在mid左侧</li>
</ul>
</li>
<li><strong>确定最小值</strong>：找到旋转点后下一个数就是最小值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[r] &gt; nums[l] <span class="keyword">or</span> len(nums) == <span class="number">1</span>:  <span class="comment">#未旋转或数组长度等于1时，返回数组第一个数字</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:  <span class="comment">#nums[mid]是旋转点，返回下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nums[mid - <span class="number">1</span>] &gt; nums[mid]:  <span class="comment">#nums[mid - 1]是旋转点，返回下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[<span class="number">0</span>]:        <span class="comment">#nums[mid]大于数组第一个元素，最小值在mid右侧</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                          <span class="comment">#否则在mid左侧</span></span><br><span class="line">                r = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a> 34-在排序数组中查找元素的第一个和最后一个位置</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>分析：本题和查找第一个等于给定值的元素思路一样。</li>
<li>思路：
<ul>
<li>初始化list保存返回结果</li>
<li>先查找第一个等于给定值的元素，将下标加入list</li>
<li>再查找最后一个等于给定值的元素，将下标加入list</li>
</ul>
</li>
<li>算法：
<ul>
<li>计算mid</li>
<li>如果nums[mid] &gt; target，说明在mid左侧</li>
<li>如果nums[mid] &lt; target，说明在mid右侧</li>
<li>如果nums[mid] == target，判断当前是第一个元素或者前一个元素不等于要查找的值，则将下标加入list，如果前一个元素也等于要查找的值，则r = mid - 1</li>
<li>如果nums[mid] == target，判断当前是最后一个元素或后一个元素不等于要查找的值，则将下标加入list，否则l = mid + 1</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        res.append(self.firstNum(nums,target))</span><br><span class="line">        res.append(self.lastNum(nums,target))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstNum</span><span class="params">(self, nums, target)</span>:</span>  <span class="comment">#查找第一个元素</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid] != nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastNum</span><span class="params">(self, nums, target)</span>:</span>   <span class="comment">#查找最后一个元素</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">if</span> mid == len(nums) - <span class="number">1</span> <span class="keyword">or</span> nums[mid] != nums[mid + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">https://lesylin.com/2020/06/29/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/03/leetcode-%E5%88%86%E6%B2%BB/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>leetcode-分治</span></div></a></div><div class="next-post pull_right"><a href="/2020/06/27/leetcode-%E8%B4%AA%E5%BF%83/"><img class="next_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>leetcode-贪心</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>