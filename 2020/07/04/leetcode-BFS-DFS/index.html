<!DOCTYPE html><html lang="zh- CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>leetcode-BFS&amp;DFS | </title><meta name="description" content="leetcode-BFS&amp;DFS"><meta name="keywords" content=""><meta name="author" content="Lesy"><meta name="copyright" content="Lesy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="leetcode-BFS&amp;DFS"><meta name="twitter:description" content="leetcode-BFS&amp;DFS"><meta name="twitter:image" content="https://lesylin.com/img/yourname2.png"><meta property="og:type" content="article"><meta property="og:title" content="leetcode-BFS&amp;DFS"><meta property="og:url" content="https://lesylin.com/2020/07/04/leetcode-BFS-DFS/"><meta property="og:site_name" content=""><meta property="og:description" content="leetcode-BFS&amp;DFS"><meta property="og:image" content="https://lesylin.com/img/yourname2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://lesylin.com/2020/07/04/leetcode-BFS-DFS/"><link rel="prev" title="leetcode-回溯" href="https://lesylin.com/2020/07/07/leetcode-%E5%9B%9E%E6%BA%AF/"><link rel="next" title="leetcode-分治" href="https://lesylin.com/2020/07/03/leetcode-%E5%88%86%E6%B2%BB/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?47f06b57b516b1634a526bebcef61cbb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154938944-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://lesylin.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '不支持复制'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"开启繁体中文","cht_to_chs":"开启简体中文","day_to_night":"开启夜间模式","night_to_day":"关闭夜间模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/"></a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/WechatIMG10.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 分享</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#bfs"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> BFS</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#思想"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 思想</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单向bfs终点未知"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text"> 单向BFS（终点未知）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#模板"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text"> 模板</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#双向bfs终点已知"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text"> 双向BFS（终点已知）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#模板-2"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text"> 模板</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1091-二进制矩阵中的最短路径"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 1091-二进制矩阵中的最短路径</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#279-完全平方数"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 279-完全平方数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-2"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-2"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#127-单词接龙"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 127-单词接龙</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-3"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-3"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#dfs"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> DFS</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#思想-2"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 思想</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#695-岛屿最大面积"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 695-岛屿最大面积</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-4"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-4"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#200-岛屿数量"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 200-岛屿数量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-5"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-5"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#547-朋友圈"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text"> 547-朋友圈</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-6"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-6"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#130-被围绕的区域"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text"> 130-被围绕的区域</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-7"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-7"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#417-太平洋大西洋水流问题"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text"> 417-太平洋大西洋水流问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目-8"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text"> 题目</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题解-8"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text"> 题解</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">已阅读</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bfs"><span class="toc-number">2.</span> <span class="toc-text"> BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思想"><span class="toc-number">2.1.</span> <span class="toc-text"> 思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单向bfs终点未知"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 单向BFS（终点未知）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向bfs终点已知"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 双向BFS（终点已知）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板-2"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1091-二进制矩阵中的最短路径"><span class="toc-number">3.</span> <span class="toc-text"> 1091-二进制矩阵中的最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">3.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解"><span class="toc-number">3.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#279-完全平方数"><span class="toc-number">4.</span> <span class="toc-text"> 279-完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-2"><span class="toc-number">4.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-2"><span class="toc-number">4.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#127-单词接龙"><span class="toc-number">5.</span> <span class="toc-text"> 127-单词接龙</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-3"><span class="toc-number">5.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-3"><span class="toc-number">5.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dfs"><span class="toc-number">6.</span> <span class="toc-text"> DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思想-2"><span class="toc-number">6.1.</span> <span class="toc-text"> 思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#695-岛屿最大面积"><span class="toc-number">7.</span> <span class="toc-text"> 695-岛屿最大面积</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-4"><span class="toc-number">7.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-4"><span class="toc-number">7.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#200-岛屿数量"><span class="toc-number">8.</span> <span class="toc-text"> 200-岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-5"><span class="toc-number">8.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-5"><span class="toc-number">8.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#547-朋友圈"><span class="toc-number">9.</span> <span class="toc-text"> 547-朋友圈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-6"><span class="toc-number">9.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-6"><span class="toc-number">9.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#130-被围绕的区域"><span class="toc-number">10.</span> <span class="toc-text"> 130-被围绕的区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-7"><span class="toc-number">10.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-7"><span class="toc-number">10.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#417-太平洋大西洋水流问题"><span class="toc-number">11.</span> <span class="toc-text"> 417-太平洋大西洋水流问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-8"><span class="toc-number">11.1.</span> <span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解-8"><span class="toc-number">11.2.</span> <span class="toc-text"> 题解</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/yourname2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">leetcode-BFS&amp;DFS</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 创建于 2020-07-04<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-06</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数统计: </span><span class="word-count">5.7k字</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读需约: 22分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">      </script><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>回顾BFS和DFS算法后，完成BFS和DFS算法在leetcode的经典题。</p>
<ul>
<li>BFS
<ul>
<li>1091-二进制矩阵中的最短路径</li>
<li>279-完全平方数</li>
<li>127-单词接龙</li>
</ul>
</li>
<li>DFS
<ul>
<li>695-岛屿的最大面积</li>
<li>200-岛屿数量</li>
<li>547-朋友圈</li>
<li>130-被围绕的区域</li>
<li>417-太平洋大西洋水流问题</li>
</ul>
</li>
</ul>
<h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1>
<h2 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h2>
<h3 id="单向bfs终点未知"><a class="markdownIt-Anchor" href="#单向bfs终点未知"></a> 单向BFS（终点未知）</h3>
<p> 广度优先搜索就是把一些问题抽象成一个图，然后一层一层进行遍历，每层遍历都是以上一层遍历的结果为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次遍历。</p>
<ul>
<li><strong>本质</strong>：<strong>就是让你在一幅「图」中找到从起点</strong> <strong><code>start</code></strong> <strong>到终点</strong> <strong><code>target</code></strong> <strong>的最近距离</strong>。（图是无权图，无权图是指从一个节点到另一个节点的代价都记为 1。）</li>
<li>我们写 BFS 算法都是用**「队列」**这种数据结构，<strong>每次将一个节点周围的所有节点加入队列</strong>。</li>
</ul>
<p> 在程序实现BFS时需要考虑以下问题：</p>
<ul>
<li><strong>队列：用来存储每一轮遍历得到的节点；</strong></li>
<li><strong>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</strong></li>
</ul>
<h3 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/bham/p/11746312.html" target="_blank" rel="noopener">https://www.cnblogs.com/bham/p/11746312.html</a></p>
</blockquote>
<h3 id="双向bfs终点已知"><a class="markdownIt-Anchor" href="#双向bfs终点已知"></a> 双向BFS（终点已知）</h3>
<p> 单向BFS是从起点不断遍历，直到遇到终点。双向BFS则是，从起点和终点不断遍历，直到遇到相交点。和单向BFS不同之处在于，使用的数据结构不再是队列，而是使用哈希表快速判断两个集合是否有想相交点。</p>
<h3 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dBFS</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    front = []</span><br><span class="line">    back = []</span><br><span class="line">    front.append(start)</span><br><span class="line">    back.append(end)</span><br><span class="line">    <span class="keyword">while</span> front <span class="keyword">and</span> back:</span><br><span class="line">        nodes = set()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> front:</span><br><span class="line">            visited.add(node) <span class="comment">#加入访问</span></span><br><span class="line">            process(node) <span class="comment"># 处理当前node</span></span><br><span class="line">            nodes.append(generate_related_nodes(node)) <span class="comment">#获取子节点</span></span><br><span class="line">        front = nodes</span><br><span class="line">        <span class="comment"># 从较小的set开始</span></span><br><span class="line">        <span class="keyword">if</span> len(back) &lt; len(front):</span><br><span class="line">            front, back = back, front</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么从较小的set开始？
<ul>
<li>因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</li>
</ul>
</li>
</ul>
<h1 id="1091-二进制矩阵中的最短路径"><a class="markdownIt-Anchor" href="#1091-二进制矩阵中的最短路径"></a> 1091-二进制矩阵中的最短路径</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>
<p>难度：中等：</p>
</li>
<li>
<p>题目：在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。一条从左上角到右下角、长度为 <code>k</code> 的畅通路径，由满足下述条件的单元格 <code>C_1, C_2, ..., C_k</code> 组成：</p>
<ul>
<li>相邻单元格 <code>C_i</code> 和 <code>C_{i+1}</code> 在八个方向之一上连通（此时，<code>C_i</code> 和 <code>C_{i+1}</code> 不同且共享边或角）</li>
<li><code>C_1</code> 位于 <code>(0, 0)</code>（即，值为 <code>grid[0][0]</code>）</li>
<li><code>C_k</code> 位于 <code>(N-1, N-1)</code>（即，值为 <code>grid[N-1][N-1]</code>）</li>
<li>如果 <code>C_i</code> 位于 <code>(r, c)</code>，则 <code>grid[r][c]</code> 为空（即，<code>grid[r][c] == 0</code>）</li>
</ul>
<p>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[0,1],[1,0]]</span><br><span class="line"></span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[0,0,0],[1,1,0],[1,1,0]]</span><br><span class="line"></span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提示：</p>
<ul>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<ul>
<li>从左上角到右下角的最短畅通路径长度，即从左上角到右下角状态为0的最短路径。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单向BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        res = <span class="number">1</span> </span><br><span class="line">        path = deque()</span><br><span class="line">        <span class="comment">#先压入起点</span></span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>]) </span><br><span class="line">        <span class="comment">#BFS模板</span></span><br><span class="line">        <span class="keyword">while</span> path: </span><br><span class="line">          	<span class="comment">#对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(path)): </span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment">#下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  </span><br><span class="line">                      	<span class="comment">#如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="comment">#扩展的点超出边界，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若扩展的点为阻塞，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若扩展的点已经访问过，则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">-1</span>:  </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#若为通畅点</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>: </span><br><span class="line">                      	<span class="comment">#当前层次下已经访问该点</span></span><br><span class="line">                        grid[new_x][new_y] = <span class="number">-1</span></span><br><span class="line">                        <span class="comment">#将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">                        path.append([new_x, new_y])  </span><br><span class="line">            res += <span class="number">1</span>  <span class="comment">#对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#双向BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        direcitons = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">1</span>)]</span><br><span class="line">        front,end = set([(<span class="number">0</span>,<span class="number">0</span>)]),set([(n<span class="number">-1</span>,n<span class="number">-1</span>)])</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> front <span class="keyword">and</span> end:</span><br><span class="line">            <span class="keyword">if</span> len(front) &gt; len(end):</span><br><span class="line">                <span class="comment"># 两端走, 哪边的值少走哪边, front也就是当前队列</span></span><br><span class="line">                front,end = end,front</span><br><span class="line">            next_queue = set() <span class="comment"># 下一个队列</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(front)):</span><br><span class="line">                i,j= front.pop()</span><br><span class="line">                <span class="keyword">for</span> dx,dy <span class="keyword">in</span> direcitons:</span><br><span class="line">                    x,y = i+dx, j+dy</span><br><span class="line">                    <span class="keyword">if</span> (x,y) <span class="keyword">in</span> end:</span><br><span class="line">                        <span class="comment">#结果坐标在尾队列，结束</span></span><br><span class="line">                        <span class="keyword">return</span> count +<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 已经走过则 赋值为 1, 好马不吃回头草</span></span><br><span class="line">                        grid[x][y] = <span class="number">1</span></span><br><span class="line">                        next_queue.add((x,y))</span><br><span class="line">            front = next_queue</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>单向BFS和双向BFS，从大O时间复杂度上看是一样的，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点。<strong>掌握BFS就可以了~</strong></li>
<li>时间复杂度：O(n)，因为每个元素遍历了一次，n为元素的个数</li>
<li>空间复杂度：O(k)，k为过程中队列的最大元素个数。</li>
</ul>
<h1 id="279-完全平方数"><a class="markdownIt-Anchor" href="#279-完全平方数"></a> 279-完全平方数</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<ul>
<li>
<p>分析：若干个完全平方数之和等于n，且个数最少。因此，我们查找的完全平方数的大小区间是[1，n)。</p>
</li>
<li>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化完全平方数列表</span></span><br><span class="line">        square_nums = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始化返回结果</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化队列遍历保存每一次差值</span></span><br><span class="line">        queue = [n]</span><br><span class="line">        <span class="comment">#BFS遍历</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            next_queue = []   <span class="comment">#next_queue = set()</span></span><br><span class="line">            <span class="keyword">for</span> remainder <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">for</span> square_num <span class="keyword">in</span> square_nums:  </span><br><span class="line">                    <span class="keyword">if</span> remainder == square_num:</span><br><span class="line">                        <span class="keyword">return</span> count  </span><br><span class="line">                    <span class="keyword">elif</span> remainder &lt; square_num:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        next_queue.append(remainder - square_num)  <span class="comment">#next_queue.add(remainder - square_num)</span></span><br><span class="line">            queue = next_queue</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：在典型的 BFS 算法中，queue 变量通常是数组或列表类型。这里可以使用 set 类型，以消除同一级别中的剩余项的冗余。事实证明，这个小技巧甚至可以增加 5 倍的运行加速。</li>
<li>set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</li>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mfrac><mi>h</mi><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{\frac{h}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22902em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.97902em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <code>h</code> 是 N 元树的高度。</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><msup><mo stretchy="false">)</mo><mi>h</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((\sqrt{n})^h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这也是在 <code>h</code> 级可以出现的最大节点数。可以看到，虽然我们保留了一个完全平方数列表，但是空间的主要消耗是队列变量，它跟踪给定 N 元树级别上要访问的剩余节点。</li>
</ul>
<h1 id="127-单词接龙"><a class="markdownIt-Anchor" href="#127-单词接龙"></a> 127-单词接龙</h1>
<h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ul>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ul>
</li>
<li>
<p>说明：</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2>
<blockquote>
<ul>
<li>题解参考：<a href="https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/</a></li>
</ul>
</blockquote>
<ul>
<li>Python的<code>defaultdict</code>：
<ul>
<li><a href="https://segmentfault.com/a/1190000010081065" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010081065</a></li>
<li>这里使用的是<code>collections.defaultdict</code>类。
<ul>
<li>defaultdict是Python内建dict类的一个子类，第一个参数为default_factory属性提供初始值，默认为None。它覆盖一个方法并添加一个可写实例变量。它的其他功能与dict相同，但会为一个不存在的键提供默认值，从而避免KeyError异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以list类名称作为参数，当访问不存在的键，会添加并返回默认值（一个空列表）</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对给定的 wordList 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line">                </span><br><span class="line">				<span class="comment"># 将包含 beginWord 和 1 的元组放入队列中，1 代表节点的层次。</span></span><br><span class="line">        <span class="comment"># 我们需要返回 endWord 的层次也就是从 beginWord 出发的最短距离。</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 为了防止出现环，使用访问数组记录。</span></span><br><span class="line">        visited = &#123;beginWord: <span class="literal">True</span>&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当队列中有元素的时候，取出第一个元素，记为 current_word。</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 找到current_word所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 all_combo_dict 来实现。</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="comment"># 从 all_combo_dict 获得的所有单词，都和 current_word 共有一个通用状态，所以都和 current_word 相连</span></span><br><span class="line">                <span class="comment"># 因此将他们加入到队列中。</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="literal">True</span></span><br><span class="line">                        <span class="comment"># 对于新获得的所有单词，向队列中加入元素 (word, level + 1) 其中 level 是 current_word 的层次。</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(M×N)，其中 M 是单词的长度 ，N 是单词表中单词的总数。找到所有的变换需要对每个单词做 M次操作。同时，最坏情况下广度优先搜索也要访问所有的 N 个单词。</li>
<li>空间复杂度：O(M×N)，要在 all_combo_dict 字典中记录每个单词的 M个通用状态。访问数组的大小是 N。广搜队列最坏情况下需要存储 N个单词。</li>
</ul>
<h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1>
<h2 id="思想-2"><a class="markdownIt-Anchor" href="#思想-2"></a> 思想</h2>
<p> 深度优先搜索就是把一些问题抽象成一个图，然后一个结点一个结点的遍历，直到没有新的结点可以遍历。</p>
<ul>
<li>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong> 问题。</li>
<li>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</strong></li>
</ul>
<p> 在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li><strong>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</strong></li>
<li><strong>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</strong></li>
</ul>
<h1 id="695-岛屿最大面积"><a class="markdownIt-Anchor" href="#695-岛屿最大面积"></a> 695-岛屿最大面积</h1>
<h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个包含了一些 <code>0</code> 和 <code>1</code> 的非空二维数组 <code>grid</code> 。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">对于上面这个给定的矩阵, 返回 0。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：给定的矩阵<code>grid</code> 的长度和宽度都不超过 50。</p>
</li>
</ul>
<h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2>
<ul>
<li>深度优先搜索：遍历网格，在每个网格上，搜索上、下、左、右四个方向的网格的1，连接起来的就是岛屿的面积</li>
<li>需求求解最大面积，因此，不断更新当前岛屿的最大面积</li>
<li>避免重复遍历，将已经搜索过的网格值置为0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n <span class="keyword">and</span> grid[i][j]:</span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, i + <span class="number">1</span>, j) + dfs(grid, i - <span class="number">1</span>, j) + dfs(grid, i, j + <span class="number">1</span>) + dfs(grid, i, j <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                result = max(result, dfs(grid, x, y))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m，n分别是网格行数和列数，每个网格最多遍历一遍</li>
<li>空间复杂度：O(m * n)，递归的深度最大可能是整个网格的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200-岛屿数量</h1>
<h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2>
<ul>
<li>本题和695题思路是一样的，不一样的地方在于，695题是找上下左右1的最大总数为题目所求，本题是搜索次数为题目所求。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i ,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; len(grid) <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[i][j] == <span class="string">'1'</span>:  </span><br><span class="line">                grid[i][j] = <span class="string">'0'</span></span><br><span class="line">                dfs(grid, i + <span class="number">1</span>, j)</span><br><span class="line">                dfs(grid, i - <span class="number">1</span>, j)</span><br><span class="line">                dfs(grid, i, j + <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m * n)，m，n分别是网格行数和列数，每个网格最多遍历一遍</li>
<li>空间复杂度：O(m * n)，递归的深度最大可能是整个网格的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="547-朋友圈"><a class="markdownIt-Anchor" href="#547-朋友圈"></a> 547-朋友圈</h1>
<h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[ i ] [ j ] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：</p>
<ul>
<li>N 在[1,200]的范围内。</li>
<li>对于所有学生，有M [ i  ] [ i ] = 1。</li>
<li>如果有M [ i ] [ j ]  = 1，则有M [ j ] [ i ]  = 1。</li>
</ul>
</li>
</ul>
<h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2>
<ul>
<li>
<p>给定的矩阵可以看成图的邻接矩阵。这样我们的问题可以变成无向图连通块的个数。</p>
</li>
<li>
<p>从每一个结点开始，我们使用一个大小为N的visited的数组（M的大小为N*N），这样visited[i]表示第 i 个元素是否被深度优先搜索访问过。</p>
</li>
<li>
<p>我们首先选择一个节点，访问任一相邻的节点。然后再访问这一节点的任一相邻节点。这样不断遍历到没有未访问的相邻节点时，回溯到之前的节点进行访问。</p>
</li>
<li>
<p>连通块就是可以从任意起点到达的所有节点。</p>
</li>
<li>
<p>因此，连通块的个数，我们从每个未被访问的节点开始深搜，每开始一次搜索就增加 count计数器一次。</p>
</li>
<li>
<blockquote>
<p>扩展：<a href="https://leetcode-cn.com/problems/friend-circles/solution/python-shen-du-you-xian-sou-suo-by-alg_bingoxiaodo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/friend-circles/solution/python-shen-du-you-xian-sou-suo-by-alg_bingoxiaodo/</a></p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, visited)</span>:</span></span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[j] <span class="keyword">and</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dfs(j, visited)</span><br><span class="line"></span><br><span class="line">        visited = [<span class="number">0</span>] * len(M)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">                dfs(i, visited)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n^2)，整个矩阵都要被遍历，大小为 n^2</li>
<li>空间复杂度：O(n)，visited 数组的大小。</li>
</ul>
<h1 id="130-被围绕的区域"><a class="markdownIt-Anchor" href="#130-被围绕的区域"></a> 130-被围绕的区域</h1>
<h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解释：</p>
<ul>
<li>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</li>
</ul>
</li>
</ul>
<h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2>
<ul>
<li>先处理边界上的O，把边界上的O先变成B，然后遍历整个二维矩阵，把O变成X，把B变成O。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        </span><br><span class="line">        row = len(board)</span><br><span class="line">        col = len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            board[i][j] = <span class="string">'B'</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                tmp_i = i + x</span><br><span class="line">                tmp_j = j + y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">1</span> &lt;= tmp_i &lt; row <span class="keyword">and</span> <span class="number">1</span> &lt;= tmp_j &lt; col <span class="keyword">and</span> board[tmp_i][tmp_j] == <span class="string">'O'</span>:</span><br><span class="line">                    dfs(tmp_i, tmp_j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            <span class="comment"># 第一行</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(<span class="number">0</span>, j)</span><br><span class="line">            <span class="comment"># 最后一行</span></span><br><span class="line">            <span class="keyword">if</span> board[row - <span class="number">1</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(row - <span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="comment"># 第一列</span></span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(i, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 最后一列</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col - <span class="number">1</span>] == <span class="string">'O'</span>:</span><br><span class="line">                dfs(i, col - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="comment"># O 变成 X</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">"O"</span>:</span><br><span class="line">                    board[i][j] = <span class="string">"X"</span></span><br><span class="line">                <span class="comment"># B 变成 O</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">"B"</span>:</span><br><span class="line">                    board[i][j] = <span class="string">"O"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(mn)，m和n分别是行数和列数</li>
<li>空间复杂度：O(mn)，递归的深度最大可能是整个矩阵的大小，因此最大可能使用O(m * n)的栈空间</li>
</ul>
<h1 id="417-太平洋大西洋水流问题"><a class="markdownIt-Anchor" href="#417-太平洋大西洋水流问题"></a> 417-太平洋大西洋水流问题</h1>
<h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2>
<ul>
<li>
<p>难度：中等</p>
</li>
<li>
<p>题目：给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p>
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p>
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
</li>
<li>
<p>提示：</p>
<ul>
<li>输出坐标的顺序不重要</li>
<li><em>m</em> 和 <em>n</em> 都小于150</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2>
<ul>
<li>分别从太平洋和大西洋的边界位置开始遍历，两次遍历的交集，就是所求。</li>
<li>遍历就是按照高度，从高到底，找下一个大于或等于当前的点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 流向太平洋的位置</span></span><br><span class="line">        res1 = set()</span><br><span class="line">        <span class="comment"># 流向大西洋的位置</span></span><br><span class="line">        res2 = set()</span><br><span class="line">        row = len(matrix)</span><br><span class="line">        col = len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从边界遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, cur, res)</span>:</span></span><br><span class="line">            res.add((i, j))</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>]]:</span><br><span class="line">                tmp_i = i + x</span><br><span class="line">                tmp_j = j + y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= tmp_i &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= tmp_j &lt; col <span class="keyword">and</span> matrix[i][j] &lt;= matrix[tmp_i][tmp_j] <span class="keyword">and</span> (tmp_i, tmp_j) <span class="keyword">not</span> <span class="keyword">in</span> res: </span><br><span class="line">                    dfs(tmp_i, tmp_j, matrix[i][j], res)</span><br><span class="line">        <span class="comment"># 太平洋</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            dfs(i, <span class="number">0</span>, <span class="number">0</span>, res1)</span><br><span class="line">        <span class="comment"># 太平洋</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            dfs(<span class="number">0</span>, j, <span class="number">0</span>, res1)</span><br><span class="line">        <span class="comment"># 大西洋</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            dfs(i, col - <span class="number">1</span>, <span class="number">0</span>, res2)</span><br><span class="line">        <span class="comment"># 大西洋</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            dfs(row - <span class="number">1</span>, j, <span class="number">0</span>, res2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1 &amp; res2</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lesy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lesylin.com/2020/07/04/leetcode-BFS-DFS/">https://lesylin.com/2020/07/04/leetcode-BFS-DFS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">文章声明: </span><span class="post-copyright-info">转载请注明文章链接</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/yourname2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/Wechat.jpeg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/apply.jpeg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/07/leetcode-%E5%9B%9E%E6%BA%AF/"><img class="prev_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>leetcode-回溯</span></div></a></div><div class="next-post pull_right"><a href="/2020/07/03/leetcode-%E5%88%86%E6%B2%BB/"><img class="next_cover lazyload" data-src="/img/yourname2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>leetcode-分治</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1XGg4LevIsbH9dlBJHeEMpiR-gzGzoHsz',
  appKey:'jiVdOFRAaqr62fNIeldKrmz8',
  placeholder:'请多指教！网址处留下你的博客呀 ~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer id="footer" style="background-image: url(/img/yourname2.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Lesy</div><div class="footer_custom_text">不要回头，继续往前走</div><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键字"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>